<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="en">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>Spring 主要源码分析 - Dionysun&#39;s Blog</title><meta name="author" content="Dionysun">
<meta name="author-link" content="https://github.com/GRedComeT">
<meta name="description" content="Bean的生命周期为：BeanFactory初始化 - Bean注册 - 实例化 - 属性注入 - 初始化 - 后处理
Bean的注册
  
    
  

扫描：Spring通过配置（XML配置或Java配置）或自动扫描（@ComponentScan）来发现应用中定义的Bean。对于自动扫描，Spring会在指定的包路径下查找标注了@Component、@Service、@Repository、@Controller等注解的类
解析：一旦Bean被发现，Spring将解析Bean的定义信息，包括Bean的作用域（如单例、原型）、生命周期回调（如@PostConstruct、@PreDestroy注解方法）、依赖注入的需求（通过@Autowired、@Resource等注解标记）等 &mdash;&mdash; BeanDefinition
注册：Spring将Bean的定义信息注册到BeanDefinitionRegistry中。这是一个重要步骤，因为注册后的Bean定义将被用于后续的Bean实例化和依赖注入过程。此时，Bean还没有被实例化。

BeanDefinition
  
    
  


BeanDefinition

Spring在初始化过程中，先收集所有bean的元数据信息并注册，bean的元数据描述为接口BeanDefinition，该接口定义了你能想到的一切有关bean的属性信息
BeanDefinition衍生出一系列实现类

AbstractBeanDefinition: 如同其他Spring类，大部分BeanDefinition接口的逻辑都由该抽象类实现
GenericBeanDefinition: 是一站式、用户可见的bean definition；可见的bean definition意味着可以在该bean definition上定义post-processor来对bean进行操作
RootBeanDefinition: 当bean definition存在父子关系的时候，RootBeanDefinition用来承载父元数据的角色（也可独立存在），同时它也作为一个可合并的bean definition使用，在Spring初始化阶段，所有的bean definition均会被（向父级）合并为RootBeanDefinition，子bean definition（GenericBeanDefinition/ChildBeanDefinition）中的定义会覆盖其父bean definition（由parentName指定）的定义
AnnotatedBeanDefinition: 用来定义注解Bean Definition

BeanDefinitionHolder只是简单捆绑了BeanDefinition、bean-name、bean-alias，用于注册BeanDefinition及别名alias ^BeanDefinitionHolder
BeanRegistry
  
    
  
Bean的注册逻辑分为两步，一为BeanDefinition的注册，二为别名的注册

BeanDefinition注册的定义在BeanDefinitionRegistry#registerBeanDefinition，其实现使用一个Map&lt;String, BeanDefinition&gt; 来保存bean-name和BeanDefinition的关系


别名的注册定义在AliasRegistry#registerAlias，其实现同样使用一个Map&lt;String, String&gt; 来保存别名alias-name和bean-name（或另一个别名alias-name）的关系

注意Bean的注册时机，通常应该在应用上下文的刷新过程之前进行(onRefresh())。一旦上下文被刷新，对Bean定义的任何修改可能不会被识别，或者可能会导致不一致的状态
Bean的实例化
  
    
  


BigMap

BeanFactory
  
    
  

几个核心接口：

AliasRegistry
bean别名注册和管理
BeanDefinitionRegistry
bean元数据注册和管理
SingletonBeanRegistry
单例bean注册和管理
BeanFactory
bean工厂，提供各种bean的获取及判断方法

通过上述的类依赖图，对于Bean的实例化，核心实现是在DefaultListableBeanFactory
DefaultListableBeanFactory - AbstractBeanFactory
  
    
  
bean的实例化过程发生在getBean调用阶段（对于singleton则发生在首次调用阶段），getBean的实现方法众多，我们追根溯源，找到最通用的方法AbstractBeanFactory#doGetBean
doGetBean
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22


// org.springframework.beans.factory.support.AbstractBeanFactory
protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,
        @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {

    // 1. 获取真正的beanName
    final String beanName = transformedBeanName(name);
    Object bean;

    // 2. 尝试获取(提前曝光的)singleton bean实例（为了解决循环依赖）
    Object sharedInstance = getSingleton(beanName);
    
    // 3. 如果存在
    if (sharedInstance != null &amp;&amp; args == null) { ... }
    
    // 4. 如果不存在
    else { ... }
    
    // 5. 尝试类型转换
    if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) { ... }
    
    return (T) bean;
}



doGetBean

Bean Name的转换
  
    
  
在使用bean-name获取bean的时候，除了可以使用原始bean-name之外，还可以使用alias别名等，bean-name的转换则是将传入的&rsquo;bean-name&rsquo;一层层转为最原始的bean-name

函数canonicalName的作用则是利用别名注册aliasMap，将别名alias转为原始bean-name
函数transformedBeanName比较特殊，其是将FactoryBean的bean-name前缀 &lsquo;&amp;&rsquo; 去除


尝试获取单例
  
    
  
拿到原始的bean-name之后，便可以实例化bean或者直接获取已经实例化的singleton-bean
在获取singleton-bean的时候一般存在三种情况：1. 还未实例化(或者不是单例)；2. 已经实例化；3. 正在实例化；

对于 &ldquo;1. 还未实例化&rdquo; ，返回null即可，后续进行实例化动作
对于 &ldquo;2. 已经实例化&rdquo;，直接返回实例化的singleton-bean
对于 &ldquo;3. 正在实例化&rdquo;，会存在循环依赖问题

Spring中对于singleton-bean，有一个sharedInstance的概念，在调用getSingleton函数时，返回的不一定是完全实例化的singleton-bean，有可能是一个中间状态（创建完成，但未进行属性依赖注入及其他后处理逻辑），这种中间状态会通过getSingleton函数提前曝光出来，目的是为了解决循环依赖
因此，Spring通过提供三层缓存来解决循环依赖问题，并且可以通过这种机制实现诸多的PostProcessor增强Bean，例如AOP

singletonObjects
缓存已经实例化完成的singleton-bean



earlySingletonObjects
缓存正在实例化的、提前曝光的singleton-bean，用于处理循环依赖


singletonFactories
缓存用于生成earlySingletonObject的 ObjectFactory



ObjectFactory，定义了一个用于创建、生成对象实例的工厂方法



1
2
3
4


@FunctionalInterface
public interface ObjectFactory&lt;T&gt; {
    T getObject() throws BeansException;
}

因此getSingleton的逻辑如下：

NOTE: 在提前暴露实体中，将相应的ObjectFactory放入了singletonFactories
FactoryBean的处理(sharedInstance存在的逻辑)
  
    
  
==sharedInstance不一定是我们所需要的bean实例==
例如，我们在定义Bean的时候可以通过实现FactoryBean接口来定制bean实例化的逻辑(实现FactoryBean)，通过注册FactoryBean类型的Bean，实例化后的原始实例类型同样为FactoryBean，但我们需要的是通过FactoryBean#getObject方法得到的实例，这需要针对FactoryBean做一些处理，即AbstractBeanFactory#getObjectForBeanInstance

Get the object for the given bean instance, either the bean instance itself or its created object in case of a FactoryBean.
Now we have the bean instance, which may be a normal bean or a FactoryBean. If it&rsquo;s a FactoryBean, we use it to create a bean instance.

该函数要实现的逻辑比较简单，如果sharedInstance是 FactoryBean，则使用getObject方法创建真正的实例

getObjectForBeanInstance是一个通用函数，并不只针对通过getSingleton得到的sharedInstance，任何通过缓存或者创建得到的 rawInstance，都需要经过getObjectForBeanInstance处理，拿到真正需要的 beanInstance



1
2
3
4
5
6
7
8


/**
 * @param beanInstance  sharedInstance / rawInstance，可能为FactoryBean
 * @param name            传入的未做转换的 bean name
 * @param beanName        对name做过转换后的原始 canonical bean name
 * @param mbd            合并后的RootBeanDefinition，下文会介绍
 */
protected Object getObjectForBeanInstance(
    Object beanInstance, String name, String beanName, RootBeanDefinition mbd)

getObjectBeanInstance
  
    
  


getObjectForBeanInstance

在这个判断逻辑中，如果入参name以&rsquo;&amp;&lsquo;开头则直接返回，这里兼容了一种情况，如果需要获取/注入FactoryBean而不是getObject生成的实例，则需要在bean-name/alias-name前加入&#39;&amp;&#39;
对于singleton，FactoryBean#getObject的结果会被缓存到factoryBeanObjectCache，对于缓存中不存在或者不是singleton的情况，会通过FactoryBean#getObject生成 ^factorybeangetobject
FactoryBeanRegistrySupport#getObjectFromFactoryBean
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47


protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) {  
    if (factory.isSingleton() &amp;&amp; this.containsSingleton(beanName)) {  
        synchronized(this.getSingletonMutex()) {  
            Object object = this.factoryBeanObjectCache.get(beanName);  
            if (object == null) {  
                object = this.doGetObjectFromFactoryBean(factory, beanName);  
                Object alreadyThere = this.factoryBeanObjectCache.get(beanName);  
                if (alreadyThere != null) {  
                    object = alreadyThere;  
                } else {  
                    if (shouldPostProcess) {  
                        if (this.isSingletonCurrentlyInCreation(beanName)) {  
                            return object;  
                        }  
  
                        this.beforeSingletonCreation(beanName);  
  
                        try {  
                            object = this.postProcessObjectFromFactoryBean(object, beanName);  
                        } catch (Throwable var14) {  
                            throw new BeanCreationException(beanName, &#34;Post-processing of FactoryBean&#39;s singleton object failed&#34;, var14);  
                        } finally {  
                            this.afterSingletonCreation(beanName);  
                        }  
                    }  
  
                    if (this.containsSingleton(beanName)) {  
                        this.factoryBeanObjectCache.put(beanName, object);  
                    }  
                }  
            }  
  
            return object;  
        }  
    } else {  
        Object object = this.doGetObjectFromFactoryBean(factory, beanName);  
        if (shouldPostProcess) {  
            try {  
                object = this.postProcessObjectFromFactoryBean(object, beanName);  
            } catch (Throwable var17) {  
                throw new BeanCreationException(beanName, &#34;Post-processing of FactoryBean&#39;s object failed&#34;, var17);  
            }  
        }  
  
        return object;  
    }  
}

对于Singleton:

首先从缓存中尝试获取，如获取失败，调用[doGetObjectFromFactoryBean](#FactoryBeanRegistrySupport doGetObjectFromFactoryBean &ldquo;wikilink&rdquo;)，其中内核是调用FactoryBean#getObject()方法
对于需要后处理的Bean，首先判断是否处于正在创建状态(isSingletonCurrentlyInCreation)，并且通过this.beforeSingletonCreate() this.afterSingletonCreation()将实际的BeanPostProcessor过程保护
对于BeanPostProcessor，调用this.postProcessObjectFromFactoryBean，其具体实现在[AbstractAutowireCapableBeanFactory#applyBeanPostProcessorAfterInitialization](#AbstractAutowireCapableBeanFactory applyBeanPostProcessorAfterInitialization &ldquo;wikilink&rdquo;)

FactoryBeanRegistrySupport#doGetObjectFromFactoryBean
  
    
  


FactoryBeanRegistrySupport_doGetObjectFromFactoryBean

AbstractAutowireCapableBeanFactory#applyBeanPostProcessorAfterInitialization
  
    
  
postProcessAfterInitialization函数可以对现有bean instance做进一步的处理，甚至可以返回新的bean instance，这就为bean的增强提供了一个非常方便的扩展方式
加载Bean实例 (sharedInstance不存在的逻辑)
  
    
  


createBeanInstance

Bean的加载/创建分为三大部分

将BeanDefinition合并为RootBeanDefinition，类似类继承，子BeanDefinition属性会覆盖父BeanDefinition
依次加载所依赖的bean，对于有依赖的情况，优先递归加载依赖的bean
按照不同的bean类型，根据BeanDefinition的定义进行加载/创建

BeanDefinition合并 (RootBeanDefinition)
  
    
  
在AbstractBeanFactory#getMergedLocalBeanDefinition中执行核心逻辑
加载dependes-On beans
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13


String[] dependsOn = mbd.getDependsOn();
if (dependsOn != null) {
    // 遍历所有的依赖
    for (String dep : dependsOn) {
        // 检测循环依赖
        if (isDependent(beanName, dep)) { /* throw exception */ }
        // 注册依赖关系
        registerDependentBean(dep, beanName);
        // 递归getBean，加载依赖bean
        try { getBean(dep); }
        catch (NoSuchBeanDefinitionException ex) { /* throw exception */ }
    }
}

该过程中涉及两个中间态

dependentBeanMap
存储哪些bean依赖了我（哪些bean里注入了我）
如果 beanB -&gt; beanA, beanC -&gt; beanA，key为beanA，value为[beanB, beanC]


dependenciesForBeanMap
存储我依赖了哪些bean（我注入了哪些bean）
如果 beanA -&gt; beanB, beanA -&gt; beanC，key为beanA，value为[beanB, beanC]

加载singleton bean实例
  
    
  


1
2
3
4
5
6
7
8


if (mbd.isSingleton()) {
    sharedInstance = getSingleton(beanName, () -&gt; {
        // singletonFactory - ObjectFactory
        try { return createBean(beanName, mbd, args); }
        catch (BeansException ex) {    destroySingleton(beanName);    throw ex; }
    });
    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
}

其中核心为createBean与getObjectForBeanInstance

createBean
根据BeanDefinition的内容，创建/初始化 bean instance
#getObjectBeanInstance
主要处理FactoryBean

createBean被包装在lambda(singletonFactory)，重写ObjectFactory#getObject()，作为[getSingleton](#DefaultSingletonBeanRegistry getSingleton(String, ObjectFactory) &ldquo;wikilink&rdquo;)的参数
DefaultSingletonBeanRegistry#getSingleton(String, ObjectFactory)
  
    
  


createSingletonBean

同样的，会先在缓存中查找该singleton，如果不存在，创建的核心逻辑在于[createBean](#AbstractAutowireCapableBeanFactory createBean &ldquo;wikilink&rdquo;)
AbstractAutowireCapableBeanFactory#createBean
  
    
  


createBean


resolveBeanClass
这一步骤用于锁定bean class，在没有显示指定beanClass的情况下，使用className加载beanClass
验证method overrides
==在BeanDefinitionReader 中有提到过lookup-method及replace-method，该步骤是为了确认以上两种配置中的method是否存在==
执行InstantiationAwareBeanPostProcessor前处理器(postProcessBeforeInstantiation)
如果这个步骤中生成了&quot;代理&quot;bean instance，则会有一个短路操作，直接返回该bean instance而不再执行doCreate，其中的核心逻辑为调用this.applyBeanPostProcessorsBeforeInstantiation() ^fcb215



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


try {
    // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
    Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
    if (bean != null) {
          // 如果这里生成了代理的bean instance会直接返回
        return bean;
    }
} cache (Throwable ex) { // throw exception }

try {
  // 创建bean instance
  Object beanInstance = doCreateBean(beanName, mbdToUse, args);
  // ...
}


doCreateBean (AbstractAutowireCapableBeanFactory)
真正bean的创建及初始化过程在此处实现

doCreateBean
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86


protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {  
    BeanWrapper instanceWrapper = null;  
    if (mbd.isSingleton()) {  
        instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName);  
    }  
  
    if (instanceWrapper == null) {  
        instanceWrapper = this.createBeanInstance(beanName, mbd, args);  
    }  
  
    Object bean = instanceWrapper.getWrappedInstance();  
    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();  
    if (beanType != NullBean.class) {  
        mbd.resolvedTargetType = beanType;  
    }  
  
    synchronized(mbd.postProcessingLock) {  
        if (!mbd.postProcessed) {  
            try {  
                this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);  
            } catch (Throwable var17) {  
                throw new BeanCreationException(mbd.getResourceDescription(), beanName, &#34;Post-processing of merged bean definition failed&#34;, var17);  
            }  
  
            mbd.markAsPostProcessed();  
        }  
    }  
  
    boolean earlySingletonExposure = mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; this.isSingletonCurrentlyInCreation(beanName);  
    if (earlySingletonExposure) {  
        if (this.logger.isTraceEnabled()) {  
            this.logger.trace(&#34;Eagerly caching bean &#39;&#34; &#43; beanName &#43; &#34;&#39; to allow for resolving potential circular references&#34;);  
        }  
  
        this.addSingletonFactory(beanName, () -&gt; {  
            return this.getEarlyBeanReference(beanName, mbd, bean);  
        });  
    }  
  
    Object exposedObject = bean;  
  
    try {  
        this.populateBean(beanName, mbd, instanceWrapper);  
        exposedObject = this.initializeBean(beanName, exposedObject, mbd);  
    } catch (Throwable var18) {  
        if (var18 instanceof BeanCreationException bce) {  
            if (beanName.equals(bce.getBeanName())) {  
                throw bce;  
            }  
        }  
  
        throw new BeanCreationException(mbd.getResourceDescription(), beanName, var18.getMessage(), var18);  
    }  
  
    if (earlySingletonExposure) {  
        Object earlySingletonReference = this.getSingleton(beanName, false);  
        if (earlySingletonReference != null) {  
            if (exposedObject == bean) {  
                exposedObject = earlySingletonReference;  
            } else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; this.hasDependentBean(beanName)) {  
                String[] dependentBeans = this.getDependentBeans(beanName);  
                Set&lt;String&gt; actualDependentBeans = new LinkedHashSet(dependentBeans.length);  
                String[] var12 = dependentBeans;  
                int var13 = dependentBeans.length;  
  
                for(int var14 = 0; var14 &lt; var13; &#43;&#43;var14) {  
                    String dependentBean = var12[var14];  
                    if (!this.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {  
                        actualDependentBeans.add(dependentBean);  
                    }  
                }  
  
                if (!actualDependentBeans.isEmpty()) {  
                    throw new BeanCurrentlyInCreationException(beanName, &#34;Bean with name &#39;&#34; &#43; beanName &#43; &#34;&#39; has been injected into other beans [&#34; &#43; StringUtils.collectionToCommaDelimitedString(actualDependentBeans) &#43; &#34;] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using &#39;getBeanNamesForType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&#34;);  
                }  
            }  
        }  
    }  
  
    try {  
        this.registerDisposableBeanIfNecessary(beanName, bean, mbd);  
        return exposedObject;  
    } catch (BeanDefinitionValidationException var16) {  
        throw new BeanCreationException(mbd.getResourceDescription(), beanName, &#34;Invalid destruction signature&#34;, var16);  
    }  
}

可以将该流程细分为如下：

[创建Bean实体](#创建Bean实体 AbstractAutowireCapableBeanFactory createBeanInstance &ldquo;wikilink&rdquo;)
[BeanDefinition后处理](#BeanDefinition后处理 - AbstractAutowireCapableBeanFactory applyMergedBeanDefinitionPostProcessors &ldquo;wikilink&rdquo;)
提前暴露实体
[属性注入](#属性注入 - AbstractAutowireCapableBeanFactory populateBean &ldquo;wikilink&rdquo;)
[初始化](#初始化 - AbstractAutowireCapableBeanFactory initializeBean &ldquo;wikilink&rdquo;)
[注册Disposable](#注册Disposable - AbstractBeanFactory registerDisposableBeanIfNecessary &ldquo;wikilink&rdquo;)

创建Bean实体 - AbstractAutowireCapableBeanFactory#createBeanInstance
  
    
  


createBeanInstance_2


instanceSupplier
从上面的流程图可以看出，创建bean实体不一定会使用到构造函数，可以使用Supplier的方式
factory method
工厂模式
@Configuration &#43; @Bean的实现方式就是factory-bean &#43; factory-method
[对应的参数获取](#ConstructorResolver resolvePreparedArguments &ldquo;wikilink&rdquo;)
有参构造函数
AbstractAutowireCapableBeanFactory#autowireConstructor -&gt; [ConstructorResolver#autowireConstructor](#**ConstructorResolver autowireConstructor** &ldquo;wikilink&rdquo;)
无参构造函数
与有参构造创建过程一致，除了不需要参数的依赖注入，使用默认无参构造函数进行实例化

ConstructorResolver#resolvePreparedArguments
  
    
  
使用指定（类）bean的（静态）方法创建bean实体的逻辑在ConstructorResolver#instantiate(String, RootBeanDefinition, Object, Method, args)，而真正的逻辑在SimpleInstantiationStrategy#instantiate(RootBeanDefinition, String, BeanFactory, Object, Method, Object&hellip;)，其核心的执行逻辑非常简单，有了方法factoryMethod(factoryBean)及入参args，便可以调用该方法创建bean实体


1


Object result = factoryMethod.invoke(factoryBean, args);

factoryBean可以通过beanFactory.getBean获取到（正是当前在讲的逻辑），factoryMethod可以通过反射获取到，而入参args就从ConstructorResolver#resolvePreparedArguments中获取，即是Spring中依赖注入的核心实现
该函数的作用是将BeanDefinition中定义的入参转换为需要的参数(==将BeanDefinitionReader中封装的对象转换==)


resolvePreparedArguments

More in blogs
ConstructorResolver#autowireConstructor
  
    
  
同样的，调用ConstructorResolver#resolvePreparedArguments进行参数的解析和转换(参数的依赖注入)，然后调用 [ConstructorResolver#instantiate](#ConstructorResolver instantiate &ldquo;wikilink&rdquo;) 来创建Bean实例
ConstructorResolver#instantiate
  
    
  
内部并没有统一利用反射技术直接使用构造函数创建，而是通过InstantiationStrategy.instantiate进行创建


Instantiate


没有设置override-method时，直接使用构造函数创建
设置了override-method时，使用cglib技术构造代理类，并代理override方法

Spring默认的实例化策略为CglibSubclassingInstantiationStrategy
BeanDefinition后处理 - AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors
  
    
  
在属性注入之前提供一次机会来对BeanDefinition进行处理，内部执行所有注册MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition方法

[!hint] MergedBeanDefinitionPostProcessor
MergedBeanDefinitionPostProcessor 是一个特定类型的 BeanPostProcessor。MergedBeanDefinitionPostProcessor 的 postProcessMergedBeanDefinition 方法允许在实例化bean之后但在设置bean属性之前，对bean的定义（BeanDefinition）进行后处理。这个阶段是用于修改或增强bean定义的，例如，可以解析注解并相应地修改 BeanDefinition 的属性。

对于MergedBeanDefinitionPostProcessor的实现类AutowiredAnnotationBeanPostProcessor，其内部方法AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata 实现了两个注解类的解析 @Value 及 @Autowired ，找到注解修饰的Filed或者Method并缓存，具体逻辑在[属性注入](#属性注入 - AbstractAutowireCapableBeanFactory populateBean &ldquo;wikilink&rdquo;) ^autowiredAnnotationBeanPostProcessor1
提前暴露实体
  
    
  
通过将AbstractAutowireCapableBeanFactory#getEarlyBeanReference封装为ObjectFactory，调用DefaultSingletonBeanRegistry#addSingletonFactory，将该ObjectFactory缓存在DefaultSingletonBeanRegistry.singletonFactories中，在getBean逻辑中的getSingleton会执行ObjectFactory将singleton提前暴露
==此处即为何时添加ObjectFactory进入singletonFactories中，解决循环依赖==

此时暴露的singleton-bean仅完成了bean的实例化，属性注入、初始化等逻辑均暂未执行

属性注入 - AbstractAutowireCapableBeanFactory#populateBean
  
    
  
在[创建Bean实体](#创建Bean实体 - AbstractAutowireCapableBeanFactory createBeanInstance &ldquo;wikilink&rdquo;)中介绍了factory method方式及有参构造函数方式的参数注入逻辑，除此之外还有一种注入便是属性注入


populateBean

流程中出现了两次InstantiationAwareBeanPostProcessor，在第一次出现中调用的postProcessorAfterInstantiation也与前面的InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation相同，拥有短路操作：如果该步骤生成了&quot;代理&quot;bean instance，直接返回该bean instance而不再执行后续的doCreate；如果有任意一个InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation方法返回false，则会跳出属性注入的逻辑，官方对此的解释如下

Give any InstantiationAwareBeanPostProcessors the opportunity to modify the state of the bean before properties are set. This can be used, for example, to support styles of field injection.

autowireByName及autowireByType方法作为&quot;候补&quot;补充BeanDefinition的propertyValues
PropertyValue中记录了需要注入的属性信息及需要注入的属性值，那BeanDefinition的propertyValues都来自哪里？xml中的bean配置、自定义的BeanDefinition等
通过注解修饰的属性(方法)通过InstantiationAwareBeanPostProcessor#postProcessProperties进行注入 -&gt; ==AutowiredAnnotationBeanPostProcessor#postProcessProperties &amp; CommonAnnotationBeanPostProcessor#postProcessProperties==
最后，通过AbstractAutowireCapableBeanFactory#applyPropertyValues 将PropertyValue中记录的需要注入的属性，已经依赖的类型（String、RuntimeBeanReference、等），根据不同的类型解析依赖的bean并设置到对应的属性上（==此过程与DefaultListableBeanFactory#doResolveDependency相似==）
初始化 - AbstractAutowireCapableBeanFactory#initializeBean
  
    
  
以上，完成了bean实例的创建和属性注入，之后还有一些初始化的方法，比如各种Aware的setXxx是如何调用的、@PostConstruct是怎么调用的？


initializeBean

注册Disposable - AbstractBeanFactory#registerDisposableBeanIfNecessary
  
    
  
至此，终于完成了bean实例的创建、属性注入以及之后的初始化，此后便可以开始使用了
在使用Spring的过程中经常还会碰到设置销毁逻辑的情况，如数据库连接池、线程池等等，在Spring销毁bean的时候还需要做一些处理，类似于C&#43;&#43;中的析构
在bean的创建逻辑中，最后一个步骤则是注册bean的销毁逻辑（DisposableBean）
销毁逻辑的注册有几个条件

非prototype（singleton或者注册的scope）
非NullBean
指定了destroy-method（如xml中指定或者BeanDefinition中直接设置）或者存在**@PreDestroy** 注解的方法（CommonAnnotationBeanPostProcessor.requiresDestruction）



1


if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd))

满足以上条件的bean会被封装为DisposableBeanAdapter，并注册在DefaultSingletonBeanRegistry.disposableBeans中
加载prototype bean实例
  
    
  


1
2
3
4
5
6
7
8
9


else if (mbd.isPrototype()) {
    Object prototypeInstance = null;
    try {
        beforePrototypeCreation(beanName);
        prototypeInstance = createBean(beanName, mbd, args);
    }
    finally { afterPrototypeCreation(beanName);    }
    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
}

prototype bean的创建与singleton bean类似，只是不会缓存创建完成的bean
加载其他scope bean实例
  
    
  
scope，即作用域，或者可以理解为生命周期
上文介绍了singleton-bean及prototype-bean的创建过程，严格意义上讲以上两种都是一种特殊的scope-bean，分别对应ConfigurableBeanFactory#SCOPE_SINGLETON及ConfigurableBeanFactory#SCOPE_PROTOTYPE，前者作用域为整个IOC容器，也可理解为单例，后者作用域为所注入的bean，每次注入(每次触发getBean)都会重新生成
Spring中还提供很多其他的scope，如WebApplicationContext#SCOPE_REQUEST或WebApplicationContext#SCOPE_SESSION，前者作用域为一次web request，后者作用域为一个web session周期
自定义scope的bean实例创建过程与singleton bean的创建过程十分相似，需要实现Scope的get方法(org.springframework.beans.factory.config.Scope#get)


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


else {
    String scopeName = mbd.getScope();
    final Scope scope = this.scopes.get(scopeName);
    if (scope == null) { /* throw exception */ }
    try {
        Object scopedInstance = scope.get(beanName, () -&gt; {
            beforePrototypeCreation(beanName);
            // createBean被封装在Scope#get函数的lambda参数ObjectFactory中
            try { return createBean(beanName, mbd, args); }
            finally { afterPrototypeCreation(beanName); }
        });
        bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
    } catch (IllegalStateException ex) { /* throw exception */}
}

Scope接口除了get方法之外，还有一个remove方法，前者用于定义bean的初始化逻辑，后者用于定义bean的销毁逻辑


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


public interface Scope {
  /**
   * Return the object with the given name from the underlying scope
   */
  Object get(String name, ObjectFactory&lt;?&gt; objectFactory);
  
   /**
   * Remove the object with the given name from the underlying scope.
   */
  Object remove(String name);
}

WebApplicationContext#SCOPE_SESSION对应的Scope实现见org.springframework.web.context.request.SessionScope
WebApplicationContext#SCOPE_REQUEST对应的Scope实现见org.springframework.web.context.request.RequestScope
以上两种Scope实现都较为简单，前者将初始化的bean存储在request attribute中，后者将初始化的bean存储在http session中
尝试类型转换
  
    
  
以上，完成了bean的创建、属性的注入、dispose逻辑的注册，但获得的bean类型与实际需要的类型可能依然不相符，在最终交付bean之前（getBean）还需要进行一次类型转换，使用PropertyEditor进行类型转换，将bean转换为真正需要的类型后，便完成了整个getBean的使命
Bean销毁过程
  
    
  
bean的创建过程始于DefaultListableBeanFactory#getBean，销毁过程则终于ConfigurableApplicationContext#close，跟踪下去，具体的逻辑在DefaultSingletonBeanRegistry#destroySingletons

DefaultSingletonBeanRegistry.disposableBeans
需要注册销毁逻辑的bean会被封装为DisposableBeanAdapter并缓存在此处
DefaultSingletonBeanRegistry.dependentBeanMap
对于存在依赖注入关系的bean，会将bean的依赖关系缓存在此处（dependentBeanMap: 哪些bean依赖了我; dependenciesForBeanMap: 我依赖了哪些bean）



destory

从上图中可以看出，bean的销毁顺序与创建顺序正好相反，如果有 beanA &ndash;dependsOn&ndash;&gt; beanB &ndash;&gt; beanC ，创建（getBean）时一定是beanC -&gt; beanB -&gt; beanA，销毁时一定是 beanA -&gt; beanB -&gt; beanC，以此避免因为依赖关系造成的一些异常情况
循环依赖
  
    
  
earlySingletonObject是用来解决循环依赖的问题，具体时机是在实例化完后属性注入之前，会提前将当前的bean实体暴露出来，以防止在属性注入过程中所注入的bean又依赖当前的bean造成的类似&quot;死锁&quot;的状态
但是存在以下情况，Spring依旧会陷入循环依赖死锁：

显式设置dependsOn的循环依赖



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


@DependsOn(&#34;beanB&#34;)
@Component
public class BeanA {}

@DependsOn(&#34;beanC&#34;)
@Component
public class BeanB {}

@DependsOn(&#34;beanA&#34;)
@Component
public class BeanC {}


构造函数循环依赖



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17


@Component
public class BeanA {
    public BeanA(BeanB beanB) {
    }
}

@Component
public class BeanB {
    public BeanB(BeanC beanC) {
    }
}

@Component
public class BeanC {
    public BeanC(BeanA beanA) {
    }
}


factory-method循环依赖



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


@Bean
public BeanA beanA(BeanB beanB) {
    return new BeanA();
}

@Bean
public BeanB beanB(BeanC beanC) {
    return new BeanB();
}

@Bean
public BeanC beanC(BeanA beanA) {
    return new BeanC();
}


上述三种依赖混合

只要一个循环依赖中的所有bean，其依赖关系都需要在创建bean实例之前进行解决，此循环依赖则一定无解
要打破无解的循环依赖，在构成循环依赖的一个环中，只需要保证其中至少一个Bean的依赖在该Bean创建且暴露earlySingleton之后处理即可，即在属性注入阶段进行属性依赖的处理


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16


@Component
public class BeanA {
    @Autowired
    private BeanB beanB;
}

@Component
public class BeanB {
    public BeanB(BeanC beanC) {
    }
}

@Bean
public BeanC beanC(BeanA beanA) {
    return new BeanC();
}

以&quot;bean创建且暴露earlySingleton&quot;为节点，在此之前处理依赖的有instance supplier parameter、factory method parameter、constructor parameter、等，在此之后处理的依赖有 class property、setter parameter等
ApplicationContext
  
    
  
BeanFactory实现了IoC的基础能力，而ApplicationContext是BeanFactory的子类，除了继承IoC的基础能力外

支持国际化 (MessageSource)
支持资源访问 (ResourcePatternResolver)
事件机制 (ApplicationEventPublisher)
默认初始化所有Singleton
提供扩展能力



ApplicationContext

无论何种功能的ApplicationContext，在做完基本的初始化后均会调用AbstractApplicationContext#Refresh
AbstractApplicationContext#Refresh
  
    
  


refresh

准备上下文 - AbstractApplicationContext#prepareRefresh
  
    
  
该部分主要实现对上下文的准备工作，其主要涉及到两个接口AbstractApplicationContext#initPropertySources及ConfigurablePropertyResolver#validateRequiredProperties，前者由子类实现，用于初始化PropertySource；后者用于对必要属性进行验证


1
2
3
4
5
6
7


public class MyClasspathXmlApplicationContext extends ClassPathXmlApplicationContext {
    @Override
    protected void initPropertySources() {
        super.initPropertySources();
        getEnvironment().setRequiredProperties(&#34;runtimeEnv&#34;);
    }
}

重写initPropertySources方法，并添加runtimeEnv为必须的环境变量属性，如此在系统启动的时候便会进行检测，对于不存在任何一个必要环境变量的情况均会抛出异常终止启动
加载BeanFactory - AbstractApplicationContext#obtainFreshBeanFactory
  
    
  
该函数内部实现比较简单，重点在refreshBeanFactory，该函数同样由子类实现
对于AbstractRefreshableApplicationContext，refreshBeanFactory基本步骤为

创建BeanFactory (DefaultListableBeanFactory)
设置BeanFactory
加载BeanDefinition

在第3步中，AbstractXmlApplicationContext的实现则是对xml配置文件的解析及加载；AnnotationConfigWebApplicationContext的实现则是对class文件的扫描并加载，以及其他基于AbstractRefreshableApplicationContext的ApplicationContext实现
对于GenericApplicationContext，BeanFactory的创建及BeanDefinition的加载在refresh调用之前早已完成，refreshBeanFactory的实现则是对BeanFactory加载状态的简单校验
AbstractRefreshableApplicationContext &amp; GenericApplicationContext
  
    
  
AbstractRefreshableApplicationContext
  
    
  
对于继承自 AbstractRefreshableApplicationContext 的上下文，例如 ClassPathXmlApplicationContext 或 AnnotationConfigApplicationContext，它们通过覆盖 refreshBeanFactory() 方法来实现具体的 BeanDefinition 加载逻辑。这些上下文类型专门用于从外部资源（如 XML 文件、Java 配置类等）加载配置信息，并将这些配置信息解析为一组 BeanDefinition，然后注册到内部的 BeanFactory 中。这个过程通常发生在上下文的 refresh() 方法调用过程中（我们正在讨论的），这个方法不仅负责加载和注册 BeanDefinition，还包括初始化单例bean、处理别名定义、注册BeanPostProcessor等一系列容器启动时的活动。

[!QUOTE] refresh()关键步骤 ^configurerRelated

创建 BeanFactory：AbstractRefreshableApplicationContext 首先会创建一个新的 BeanFactory 实例，这通常是一个 DefaultListableBeanFactory 实例。这个 BeanFactory 实现了 BeanDefinitionRegistry 接口，使得它能够注册 BeanDefinition。
==加载 BeanDefinition：接着，上下文会调用特定的方法（例如，对于基于 XML 的配置，会使用 XmlBeanDefinitionReader；对于基于注解的配置，会使用 AnnotatedBeanDefinitionReader 和 ClassPathBeanDefinitionScanner）来加载 BeanDefinition。这些 Reader 和 Scanner 实现了 BeanDefinitionRegistry 接口的 registerBeanDefinition 方法来实际完成注册工作。==
刷新 BeanFactory：加载完所有 BeanDefinition 后，AbstractRefreshableApplicationContext 会对 BeanFactory 进行刷新，这涉及到预实例化单例、注册 BeanPostProcessor、初始化剩余的非懒加载单例等一系列操作。
发布事件：在整个容器刷新过程中，还会发布各种应用事件，如 ContextRefreshedEvent，允许应用中的其他组件对这些事件作出响应。

通过上述步骤，AbstractRefreshableApplicationContext 完成了 BeanDefinition 的加载、注册以及整个 Spring 容器的初始化和刷新工作。在这个过程中，BeanDefinitionRegistry 接口扮演了 BeanDefinition 注册的关键角色
GenericApplicationContext
  
    
  

GenericApplicationContext 直接实现了 BeanDefinitionRegistry 接口，使得它可以在运行时动态注册 BeanDefinition。与 AbstractRefreshableApplicationContext 的子类不同，GenericApplicationContext 并不专门依赖于外部资源来加载 BeanDefinition。相反，它提供了一套程序化的接口，允许开发者直接在代码中通过调用 registerBeanDefinition(String beanName, BeanDefinition beanDefinition) 方法来注册 BeanDefinition。这种方式使得 GenericApplicationContext 非常灵活，适用于那些需要在运行时动态调整 Spring 配置的场景。
关系和区别
  
    
  

加载方式的区别：AbstractRefreshableApplicationContext 的子类通常通过解析配置资源（XML、注解等）来加载 BeanDefinition，而 GenericApplicationContext 允许以编程方式直接注册 BeanDefinition。
使用场景的区别：AbstractRefreshableApplicationContext 的子类适合于静态配置资源的场景，其中配置信息在应用启动时已经确定。GenericApplicationContext 更适合于动态配置的场景，比如基于条件的 BeanDefinition 注册或运行时的配置调整。
刷新容器的能力：虽然两者都可以通过 refresh() 方法来刷新应用上下文，但 AbstractRefreshableApplicationContext 的子类通常在设计时就考虑了完整的容器刷新流程（包括重新加载配置资源），而 GenericApplicationContext 刷新主要是为了应用新注册的 BeanDefinition。==前者会重置BeanFactory而后者不会==

填充部分扩展 - AbstractApplicationContext#prepareBeanFactory
  
    
  
该函数执行以下逻辑

设置BeanFactory的ClassLoader
注册默认BeanExpressionResolver，用于依赖注入时SpEL的支持
注册默认PropertyEditor，用于依赖注入时对参数的解析转换
注册几个特殊Aware的处理逻辑
注册AspectJ相关的几个处理器，用于AOP的支持
注册几个特殊的BeanDefinition

==2-3 的核心逻辑在于解析依赖的值，DefaultListableBenFactory#doResolveDependency==
注册几个特殊Aware的处理逻辑
  
    
  
在Bean实例化、注入依赖之后会对Bean进行[最后的初始化](#初始化 - AbstractAutowireCapableBeanFactory initializeBean &ldquo;wikilink&rdquo;)，调用相应的setter方法分别针对BeanNameAware、BeanClassLoaderAware、BeanFactoryAware进行处理
在该函数中，会注册几个特殊的BeanPostProcessor


1


beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));

其实现了postProcessBeforeInitialization方法，内部调用ApplicationContextAwareProcessor#invokeAwareInterfaces针对另外的几类Aware进行了处理
除此之外，Spring会将上述几类Aware设置为ignoreDependencyInterface，这意味着以上几类Bean的注入只能通过Aware的方式而不能通过其他属性依赖注入的方式（属性注入、函数参数注入等）
注册特殊的Bean
  
    
  
在使用Spring时，是否有过直接注入BeanFactory亦或是ResourceLoader，这些bean正是在这里被Spring注册进去的，除以上外Spring还注入了

BeanFactory
ResourceLoader
ApplicationEventPublisher
ApplicationContext
Environment
systemProperties - Environment#.getSystemProperties:Map&lt;String, Object&gt;
systemEnvironment - Environment#.getSystemEnvironment:Map&lt;String, Object&gt;
AbstractApplicationContext#refresh#postProcessBeanFactory()
  
    
  


对于不同的实现类，注册相应的BeanPostProcessor，例如ServletWebServerApplicationContext
激活BeanFactoryPostProcessor - AbstractApplicationContext#invokeBeanFactoryPostProcessors
  
    
  
其内部实现在PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors
BeanFactoryPostProcessor的定义非常简单，其postProcessBeanFactory方法允许在bean实例化前对BeanFactory做一些额外的设置


1
2
3
4
5
6
7
8
9


public interface BeanFactoryPostProcessor {
    /**
     * Modify the application context&#39;s internal bean factory after its standard
     * initialization. All bean definitions will have been loaded, but no beans
     * will have been instantiated yet. This allows for overriding or adding
     * properties even to eager-initializing beans.
     */
    void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;
}

核心逻辑如下


invokeBeanFactoryPostProcessors

其中涉及两种类型，BeanDefinitionRegistryPostProcessor及BeanFactoryPostProcessor，前者为后者的子类，BeanDefinitionRegistryPostProcessors提供了额外的接口postProcessBeanDefinitionRegistry，用于更加方便地动态地注册额外的BeanDefinition (registryProcessor.postProcessBeanDefinitionRegistry(registry))，如读取配置文件（json、properties、yml）并解析（或者任何其他的形式），并通过该接口注册相应的BeanDefinition，基于Spring Boot Starter的很多框架均使用该方式进行bean的注册
以上流程图可以看出，优先执行BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry，再执行BeanFactoryPostProcessor#postProcessBeanFactory，各自内部优先执行PriorityOrdered实现，再执行Ordered实现，最后执行无任何排序的实现
注册BeanPostProcessor - AbstractApplicationContext#registerBeanPostProcessors
  
    
  
其内部实现在PostProcessorRegistrationDelegate#registerBeanPostProcessors
b
BeanPostProcessor
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23


public interface BeanPostProcessor {
    /**
     * Apply this BeanPostProcessor to the given new bean instance before any bean
     * initialization callbacks (like InitializingBean&#39;s afterPropertiesSet
     * or a custom init-method). 
     * The returned bean instance may be a wrapper around the original.
     */
    @Nullable
    default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }

    /**
     * Apply this BeanPostProcessor to the given new bean instance after any bean
     * initialization callbacks (like InitializingBean&#39;s afterPropertiesSet
     * or a custom init-method).
     * The returned bean instance may be a wrapper around the original.
     */
    @Nullable
    default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }
}


postProcessBeforeInitialization方法在调用bean的init-method之前执行
postProcessAfterInitialization方法在调用bean的init-method之后执行
任何一个方法可对现有bean实例做进一步的修改
任何一个方法可返回新的bean实例，用来替代现有的bean实例

第四点即是AOP生成当前Bean代理的方法
InstantiationAwareBeanPostProcessor
  
    
  
该接口继承自BeanPostProcessor，其同样有两个方法，一个在创建bean实例之前调用([createBean](#AbstractAutowireCapableBeanFactory createBean &ldquo;wikilink&rdquo;))，一个在创建bean实例之后、属性注入之前调用([属性注入](#属性注入 - AbstractAutowireCapableBeanFactory populateBean &ldquo;wikilink&rdquo;))


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15


public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor {  
    @Nullable  
    default Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException {  
        return null;  
    }  
  
    default boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {  
        return true;  
    }  
  
    @Nullable  
    default PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException {  
        return pvs;  
    }  
}

AbstractApplicationContext#registerBeanPostProcessors，其内部逻辑与BeanFactoryPostProcessor的注册逻辑类似：

找到所有BeanPostProcessor并实例化
按照实现的Ordered接口分别放入priorityOrderedPostProcessors、orderedPostProcessors、nonOrderedPostProcessors并各自排序
如果实现了MergedBeanDefinitionPostProcessor则放入internalPostProcessors并排序
按顺序依次注册priorityOrderedPostProcessors、orderedPostProcessors、nonOrderedPostProcessors
最后注册internalPostProcessors

MergedBeanDefinitionPostProcessor其有一个接口postProcessMergedBeanDefinition，在bean实例化完成后属性注入之前被调用，可以用来对当前的BeanDefinition做进一步的修改，如增加PropertyValue等，实现特殊的属性依赖注入，参考[BeanDefinition后处理](#BeanDefinition后处理 - AbstractAutowireCapableBeanFactory applyMergedBeanDefinitionPostProcessors &ldquo;wikilink&rdquo;)与[属性注入](#属性注入 - AbstractAutowireCapableBeanFactory populateBean &ldquo;wikilink&rdquo;)
初始化MessageSource - AbstractApplicationContext#initMessageSource
  
    
  
Spring的MessageSource提供了国际化能力，在开发者未注册MessageSource的情况下Spring会提供一个默认的DelegatingMessageSource
初始化ApplicationEventMulticaster - AbstractApplicationContext#initApplicationEventMulticaster
  
    
  
Spring提供了一套事件（ApplicationEvent）的发布&amp;订阅机制，开发者可自定义事件（继承ApplicationEvent），注册事件监听器来订阅消费事件（实现ApplicationListener 或使用@EventListener 注解），并使用ApplicationEventPublisher（直接依赖注入或者使用ApplicationEventPublisherAware）发送事件，使用示例可参考https://www.baeldung.com/spri&hellip;
其实ApplicationContext实现了ApplicationEventPublisher，跟踪其publishEvent方法会发现，最终调用了AbstractApplicationContext#applicationEventMulticaster.multicastEvent，开发者可以自行注册一个ApplicationEventMulticaster，如果没有Spring会提供一个默认的SimpleApplicationEventMulticaster
SimpleApplicationEventMulticaster#multicastEvent的逻辑比较简单，会根据事件的类型找到可以处理的所有ApplicationListener，依次调用它们的onApplicationEvent方法消费事件


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15


@Override
public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {
    ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
    Executor executor = getTaskExecutor();
    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {
        if (executor != null) {
      // 设置了executor，则异步执行
            executor.execute(() -&gt; invokeListener(listener, event));
        }
        else {
      // 否则同步执行
            invokeListener(listener, event);
        }
    }
}

默认情况下会同步、顺序的调用listeners的onApplicationEvent方法，只有设置了executor才会异步调用，不过这样的控制粒度比较粗，要么全部同步消费要么全部异步消费，比较细粒度的控制事件的消费有几种常用方法

使用@Async注解，独立控制某一listener异步消费（https://www.baeldung.com/spri&hellip;）
自行编码，将onApplicationEvent逻辑放在线程中执行
注册自定义的ApplicationEventMulticaster，内部实现自己的同步、异步Event处理逻辑

注册ApplicationListener - AbstractApplicationContext#registerListeners
  
    
  
这里的逻辑比较简单

在BeanFactory中找到ApplicationListener类型的bean并实例化
调用ApplicationEventMulticaster#addApplicationListenerBean方法将ApplicationListeners注册进去

初始化所有非Lazy Bean - AbstractApplicationContext#finishBeanFactoryInitialization
  
    
  
对于Singleton Bean而言，实例化发生在首次getBean，但你是否有疑惑，我们只是注册了众多Singleton Bean，但在Spring初始化完成后所有的Singleton Bean（Lazy Bean除外）均已经完成实例化
回到AbstractApplicationContext#finishBeanFactoryInitialization，该函数会实现几个逻辑

如果自定义了ConversionService(另一种注入类型转换的方式)类型bean且bean-name为conversionService，则将其注册到BeanFactory中
如果BeanFactory中不存在EmbeddedValueResolver（PropertyResourceConfigurer会注册一个PlaceholderResolvingStringValueResolver到BeanFactory中），则会注册一个默认的StringValueResolver用来处理 ${ ... }类型的值（Environment#resolvePlaceholders）
找到所有非Lazy的Singleton BeanDefinition进行实例化（getBean）

如果是FactoryBean，则在bean name前加上&rsquo;&amp;&rsquo;，并实例化该FactoryBean，随后实例化真实的bean
如果不是FactoryBean，则直接实例化该bean


执行SmartInitializingSingleton实现类的afterSingletonsInstantiated方法

Refresh的后续动作 - AbstractApplicationContext#finishRefresh
  
    
  
除了一些中间状态需要清理外，还有两件比较特殊的地方
LifecycleProcessor - AbstractApplicationContext#initLifecycleProcessor
  
    
  
Spring提供了LifecycleProcessor用于监听BeanFactory的refresh及close，在BeanFactory的各阶段会调用LifecycleProcessor的onFresh及onClose方法
开发者可以自行注册LifecycleProcessor类型的bean，bean-name必须为&quot;lifecycleProcessor&quot;，否则Spring会提供一个默认的DefaultLifecycleProcessor
之后则会触发LifecycleProcessor的onFresh方法

除此之外，还可以监听ContextRefreshedEvent及ContextClosedEvent消息

refresh事件
  
    
  
在BeanFactory初始化完成后，则会发出ContextRefreshedEvent事件
BeanFactory的销毁 - AbstractApplicationContext#registerShutdownHook
  
    
  
该函数用来注册BeanFactory的销毁逻辑


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13


public void registerShutdownHook() {  
    if (this.shutdownHook == null) {  
        this.shutdownHook = new Thread(&#34;SpringContextShutdownHook&#34;) {  
            public void run() {  
                synchronized(AbstractApplicationContext.this.startupShutdownMonitor) {  
                    AbstractApplicationContext.this.doClose();  
                }  
            }  
        };  
        Runtime.getRuntime().addShutdownHook(this.shutdownHook);  
    }  
  
}

其直接使用了java的addShutdownHook函数，在jvm进程正常退出的时候触发
AbstractApplicationContext#doClose函数定义了BeanFactory具体的销毁过程

发出ContextClosedEvent事件
触发LifecycleProcessor的onClose方法
销毁bean，细节参考Bean销毁过程
由子类实现的AbstractApplicationContext#closeBeanFactory及AbstractApplicationContext#onClose方法

ASIDE
  
    
  

BeanDefinition的加载在[AbstractApplicationContext#obtainFreshBeanFactory](#加载BeanFactory - AbstractApplicationContext obtainFreshBeanFactory &ldquo;wikilink&rdquo;)中实现
TODO

#{ ... }类型值的解析由StandardBeanExpressionResolve实现
${ ... }类型值的解析由PlaceholderResolvingStringValueResolver实现
Spring提供了众多默认的PropertyEditor，若需要自定义PropertyEditor可以通过注册CustomEditorConfigurer实现
Spring提供了众多Aware，若需要自定义Aware可以通过BeanPostProcessor实现
BeanFactoryPostProcessor用于在实例化bean之前对BeanFactory做额外的动作
如，PropertyResourceConfigurer用来将PlaceholderResolvingStringValueResolver注册到BeanFactory的embeddedValueResolvers中


[BeanDefinitionRegistryPostProcessor](#激活BeanFactoryPostProcessor - AbstractApplicationContext invokeBeanFactoryPostProcessors &ldquo;wikilink&rdquo;)用于在实例化bean之前（动态）注册额外的BeanDefinition ^fa1ce8
BeanPostProcessor用于在调用bean的init-method前后，对实例化完成的bean做一些额外的干预
如，CommonAnnotationBeanPostProcessor用来处理@PostConstructor，AbstractAdvisingBeanPostProcessor用来实现AOP

ApplicationContext具体实现类 - AnnotationConfigApplicationContext
  
    
  


1
2
3
4
5


public AnnotationConfigApplicationContext(Class&lt;?&gt;... componentClasses) { 
    this(); //1. 首先会调用自己的无参构造 
    register(componentClasses); //2. 然后注册我们传入的配置类 
    refresh(); //3. 最后进行刷新操作（关键） 
}

无参构造
  
    
  


1
2
3
4
5
6
7
8


public AnnotationConfigApplicationContext() {
        StartupStep createAnnotatedBeanDefReader = this.getApplicationStartup().start(&#34;spring.context.annotated-bean-reader.create&#34;);
      //创建AnnotatedBeanDefinitionReader对象，用于后续处理 @Bean 注解
        this.reader = new AnnotatedBeanDefinitionReader(this);
        createAnnotatedBeanDefReader.end();
      //创建ClassPathBeanDefinitionScanner对象，用于扫描类路径上的Bean
        this.scanner = new ClassPathBeanDefinitionScanner(this);
}

AnnotatedBeanDefinitionReader
  
    
  


1
2
3
4
5
6
7
8


public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
        Assert.notNull(registry, &#34;BeanDefinitionRegistry must not be null&#34;);
        Assert.notNull(environment, &#34;Environment must not be null&#34;);
        this.registry = registry;
        this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);
      //这里注册了注解处理配置相关的后置处理器
        AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
}

这里会将ConfigurationClassPostProcessor后置处理器加入到BeanFactory中，它继承自BeanFactoryPostProcessor，也就是说一会会在BeanFactory初始化完成之后进行后置处理，同时这里也会注册一个AutowiredAnnotationBeanPostProcessor后置处理器到BeanFactory，它继承自BeanPostProcessor，用于处理后续生成的Bean对象，其实看名字就知道，这玩意就是为了处理@Autowire、@Value这种注解，用于自动注入
注册传入的配置类 - register
  
    
  


1
2
3
4
5
6
7
8
9


@Override
public void register(Class&lt;?&gt;... componentClasses) {
        Assert.notEmpty(componentClasses, &#34;At least one component class must be specified&#34;);
        StartupStep registerComponentClass = this.getApplicationStartup().start(&#34;spring.context.component-classes.register&#34;)
                .tag(&#34;classes&#34;, () -&gt; Arrays.toString(componentClasses));
      //使用我们上面创建的Reader注册配置类
        this.reader.register(componentClasses);
        registerComponentClass.end();
}

[Refresh](#AbstractApplicationContext Refresh &ldquo;wikilink&rdquo;)
  
    
  
==TODO==
  
    
  

☒ Spring AOP
☐ 注解运行逻辑

@Component与@Bean的区别
JavaSSM#^473168
☐ @Bean 在处理属性注入时？


☒ AnnotationConfigApplicationContext - 与 配置类的关系 - 具体例子
☐ BeanDefinitionReader和BeanDefinitionRegistry
☐ 完善调用链图
配置类的注册 - ConfigurationClassPostProcessor
  
    
  


ConfigurationClassPostProcessor继承自BeanDefinitionRegistryPostProcessor -&gt; BeanFactoryPostProcessor，这个后置处理器是Spring中提供的，这是专门用于处理配置类的后置处理器，其中ImportBeanDefinitionRegistrar，还有ImportSelector都是靠它来处理
ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry
  
    
  
内部调用 processConfigBeanDefinitions(BeanDefinitionRegistry) 方法


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50


public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
    // 将Spring认为可能是配置类的候选类加入candidates，例如@Configuration、@Component
    // @ComponentScan、@Import，以及通过实现ImportSelector或ImportBeanDefinitionRegistrar间接引入的配置
    List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
    // 直接取出所有已注册Bean的名称
    String[] candidateNames = registry.getBeanDefinitionNames();
    for (String beanName : candidateNames) {
       // 依次拿到对应的Bean定义，然后进行判断
       BeanDefinition beanDef = registry.getBeanDefinition(beanName);
       if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) {
          ...
       }
       // 检查一个Bean定义是否符合作为配置类的条件，即使它没有直接使用@Configuration注解
       else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
          configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
       }
    }
    // 如果一个打了 @Configuration 的类都没发现，直接返回
    if (configCandidates.isEmpty()) {
       return;
    }
    // 对所有的配置类依据 @Order 进行排序
    configCandidates.sort((bd1, bd2) -&gt; {
       int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
       int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
       return Integer.compare(i1, i2);
    });
    ...
    // 这里使用do-while语句依次解析所有的配置类
    ConfigurationClassParser parser = new ConfigurationClassParser(
          this.metadataReaderFactory, this.problemReporter, this.environment,
          this.resourceLoader, this.componentScanBeanNameGenerator, registry);
    Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
    Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
    do {
       StartupStep processConfig = this.applicationStartup.start(&#34;spring.context.config-classes.parse&#34;);
       //这里就会通过Parser解析配置类中大部分内容，包括我们之前遇到的@Import注解
             parser.parse(candidates);
             parser.validate();
       //解析完成后读取到所有的配置类
       Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
             configClasses.removeAll(alreadyParsed);
       ... 
       //将上面读取的配置类加载为Bean
       this.reader.loadBeanDefinitions(configClasses);
       ...
    }
    while (!candidates.isEmpty());
    ...
}

ConfigurationClassParser#parse(candidates)
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25


public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) {
    for (BeanDefinitionHolder holder : configCandidates) {
        BeanDefinition bd = holder.getBeanDefinition();
        try {
            if (bd instanceof AnnotatedBeanDefinition annotatedBeanDef) {
                parse(annotatedBeanDef, holder.getBeanName());
            }
            else if (bd instanceof AbstractBeanDefinition abstractBeanDef &amp;&amp; abstractBeanDef.hasBeanClass()) {
                parse(abstractBeanDef.getBeanClass(), holder.getBeanName());
            }
            else {
                parse(bd.getBeanClassName(), holder.getBeanName());
            }
        }
        catch (BeanDefinitionStoreException ex) {
            throw ex;
        }
        catch (Throwable ex) {
            throw new BeanDefinitionStoreException(
                    &#34;Failed to parse configuration class [&#34; &#43; bd.getBeanClassName() &#43; &#34;]&#34;, ex);
        }
    }

    this.deferredImportSelectorHandler.process();
}

内部遍历candidates中的每一个BeanDefinitionHolder，调用parse的多态方法，最终调用ConfigurationClassParser#processConfigurationClass，最后调用deferredImportSelectorHandler.process()处理DeferredImportSelector相关的Bean注册 ^processConfigurationClass
首先判断条件注释，即处理@Conditional相关注解
然后将不同来源的配置类源信息通过asSourceClass进行封装，交给最核心的调用[doProcessConfigurationClass](#ConfigurationClassParser doProcessConfigurationClass &ldquo;wikilink&rdquo;)

将配置类ConfigurationClass实例化为SourceClass。这样做的目的是为了让后续的处理逻辑能够通过SourceClass访问到配置类中定义的所有相关信息（比如注解信息，Meta-info），并进行相应的处理。例如，通过SourceClass可以读取配置类上的@ComponentScan注解，并执行组件扫描；读取@Import注解，并处理导入的配置类或组件；读取@Bean方法，并注册对应的Bean定义等。

ConfigurationClassParser#doProcessConfigurationClass
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98


@Nullable
protected final SourceClass doProcessConfigurationClass(
        ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter)
        throws IOException {

    if (configClass.getMetadata().isAnnotated(Component.class.getName())) {
        // Recursively process any member (nested) classes first
        processMemberClasses(configClass, sourceClass, filter);
    }

    // Process any @PropertySource annotations
    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
            sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class,
            PropertySources.class, true)) {
        if (this.propertySourceRegistry != null) {
            this.propertySourceRegistry.processPropertySource(propertySource);
        }
        else {
            logger.info(&#34;Ignoring @PropertySource annotation on [&#34; &#43; sourceClass.getMetadata().getClassName() &#43;
                    &#34;]. Reason: Environment must implement ConfigurableEnvironment&#34;);
        }
    }

    // Search for locally declared @ComponentScan annotations first.
    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
            sourceClass.getMetadata(), ComponentScan.class, ComponentScans.class,
            MergedAnnotation::isDirectlyPresent);

    // Fall back to searching for @ComponentScan meta-annotations (which indirectly
    // includes locally declared composed annotations).
    if (componentScans.isEmpty()) {
        componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(),
                ComponentScan.class, ComponentScans.class, MergedAnnotation::isMetaPresent);
    }

    if (!componentScans.isEmpty()) {
        List&lt;Condition&gt; registerBeanConditions = collectRegisterBeanConditions(configClass);
        if (!registerBeanConditions.isEmpty()) {
            throw new ApplicationContextException(
                    &#34;Component scan could not be used with conditions in REGISTER_BEAN phase: &#34; &#43; registerBeanConditions);
        }
        for (AnnotationAttributes componentScan : componentScans) {
            // The config class is annotated with @ComponentScan -&gt; perform the scan immediately
            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
                    this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
            // Check the set of scanned definitions for any further config classes and parse recursively if needed
            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                if (bdCand == null) {
                    bdCand = holder.getBeanDefinition();
                }
                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
                    parse(bdCand.getBeanClassName(), holder.getBeanName());
                }
            }
        }
    }

    // Process any @Import annotations
    processImports(configClass, sourceClass, getImports(sourceClass), filter, true);

    // Process any @ImportResource annotations
    AnnotationAttributes importResource =
            AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
    if (importResource != null) {
        String[] resources = importResource.getStringArray(&#34;locations&#34;);
        Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&#34;reader&#34;);
        for (String resource : resources) {
            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
            configClass.addImportedResource(resolvedResource, readerClass);
        }
    }

    // Process individual @Bean methods
    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
    for (MethodMetadata methodMetadata : beanMethods) {
        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
    }

    // Process default methods on interfaces
    processInterfaces(configClass, sourceClass);

    // Process superclass, if any
    if (sourceClass.getMetadata().hasSuperClass()) {
        String superclass = sourceClass.getMetadata().getSuperClassName();
        if (superclass != null &amp;&amp; !superclass.startsWith(&#34;java&#34;)) {
            boolean superclassKnown = this.knownSuperclasses.containsKey(superclass);
            this.knownSuperclasses.add(superclass, configClass);
            if (!superclassKnown) {
                // Superclass found, return its annotation metadata and recurse
                return sourceClass.getSuperClass();
            }
        }
    }

    // No superclass -&gt; processing is complete
    return null;
}

该函数依次解决如下问题：

处理@Component注解
处理@PropertySource和@PropertySources注解
处理@ComponentScan和@ComponentScans
处理@Import注解
处理@ImportResource注解
处理@Bean注解的方法
处理接口上的默认方法和超类

其中的核心是处理@Import注解，通过调用 [ConfigurationClassParser#processImports](#ConfigurationClassParser processImports &ldquo;wikilink&rdquo;)
ConfigurationClassParser#processImports
  
    
  
注意其第三个入参Collection&lt;SourceClass&gt; importCandidates，它是通过调用getImports(sourceClass)方法，从给定的sourceClass中提取所有@Import注解指定的类，如果sourceClass是普通的配置类，直接通过isEmpty()返回


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63


private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
        Collection&lt;SourceClass&gt; importCandidates, Predicate&lt;String&gt; filter, boolean checkForCircularImports) {

    if (importCandidates.isEmpty()) {
        return;
    }

    if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) {
        this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
    }
    else {
        this.importStack.push(configClass);
        try {
            for (SourceClass candidate : importCandidates) {
                if (candidate.isAssignable(ImportSelector.class)) {
                    // Candidate class is an ImportSelector -&gt; delegate to it to determine imports
                    Class&lt;?&gt; candidateClass = candidate.loadClass();
                    ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class,
                            this.environment, this.resourceLoader, this.registry);
                    Predicate&lt;String&gt; selectorFilter = selector.getExclusionFilter();
                    if (selectorFilter != null) {
                        filter = filter.or(selectorFilter);
                    }
                    if (selector instanceof DeferredImportSelector deferredImportSelector) {
                        this.deferredImportSelectorHandler.handle(configClass, deferredImportSelector);
                    }
                    else {
                        String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                        Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames, filter);
                        processImports(configClass, currentSourceClass, importSourceClasses, filter, false);
                    }
                }
                else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
                    // Candidate class is an ImportBeanDefinitionRegistrar -&gt;
                    // delegate to it to register additional bean definitions
                    Class&lt;?&gt; candidateClass = candidate.loadClass();
                    ImportBeanDefinitionRegistrar registrar =
                            ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class,
                                    this.environment, this.resourceLoader, this.registry);
                    configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
                }
                else {
                    // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;
                    // process it as an @Configuration class
                    this.importStack.registerImport(
                            currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
                    processConfigurationClass(candidate.asConfigClass(configClass), filter);
                }
            }
        }
        catch (BeanDefinitionStoreException ex) {
            throw ex;
        }
        catch (Throwable ex) {
            throw new BeanDefinitionStoreException(
                    &#34;Failed to process import candidates for configuration class [&#34; &#43;
                    configClass.getMetadata().getClassName() &#43; &#34;]: &#34; &#43; ex.getMessage(), ex);
        }
        finally {
            this.importStack.pop();
        }
    }
}

代码遍历每一个@Import注解指定的候选类，根据不同类型进行处理

ImportSelector实现
ImportSelector
DeferredImportSelector
ImportBeanDefinitionRegistar实现
普通的配置类

针对ImportSelector
  
    
  
通过selector.selectImports()与asSourceClasses()方法将需要导入的类重新封装为SourceClass，递归调用processImports
针对DeferredImportSelector
  
    
  
通过调用ConfigurationClassParser的内部类DeferredImportSelectorHandler#handle()方法，将其封装为DeferredImportSelectorHolder ，加入待处理的List - deferredImportSelectors
在ConfigurationClassParser#parse[处理完所有候选配置类后](#ConfigurationClassParser parse(candidates) &ldquo;wikilink&rdquo;)，调用DeferredImportSelectorHandler#process()方法，该方法将加入deferredImportSelectors中的所有DeferredImportSelectorHolder执行内部类的DeferredImportSelectorGroupingHandler#register方法，得到包装好的、已经分组完毕的DeferredImportSelectorGrouping，然后调用DeferredImportSelectorGroupingHandler#processGroupImports()，处理组内所有的延迟导入 (DeferredImportSelector)
DeferredImportSelectorGroupingHandler#register
  
    
  


1
2
3
4
5
6
7
8
9


void register(DeferredImportSelectorHolder deferredImport) {
            Class&lt;? extends Group&gt; group = deferredImport.getImportSelector().getImportGroup();
            DeferredImportSelectorGrouping grouping = this.groupings.computeIfAbsent(
                    (group != null ? group : deferredImport),
                    key -&gt; new DeferredImportSelectorGrouping(createGroup(group)));
            grouping.add(deferredImport);
            this.configurationClasses.put(deferredImport.getConfigurationClass().getMetadata(),
                    deferredImport.getConfigurationClass());
        }


首先尝试获取DeferredImportSelector指定的导入组 (ImportGroup)，如果没有指定特定的导入组，则使用DeferredImportSelector本身作为组的Key
尝试从一个名为groupings的映射中获取或创建一个与导入组对应的DeferredImportSelectorGrouping对象。如果映射中尚未存在与当前组对应的分组，那么将创建一个新的分组，并将其加入到映射中

注意，此处的Group逻辑是将DeferredImportSelector.Group这个内部接口包装到ConfigurationClassParser.DeferredImportSelectorGourping这个内部类中，其内部维护了一个DeferredImportSelector.Group对象和List&lt;DeferredImportSelectorHolder&gt;对象


调用DeferredImportSelectGrouping#add(DeferredImportSelectorHolder)，将DeferredImportSelectorHolder加入内部类维护的Grouping中 (静态类)
最后，代码将当前DeferredImportSelectorHolder对应的配置类(ConfigurationClass)及其元数据添加到一个名为configurationClasses的映射中。这确保了后续能够快速访问到与特定DeferredImportSelector相关联的配置类

DeferredImportSelectorGroupingHandler#processGroupImports
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21


void processGroupImports() {
    for (DeferredImportSelectorGrouping grouping : this.groupings.values()) {
        Predicate&lt;String&gt; filter = grouping.getCandidateFilter();
        grouping.getImports().forEach(entry -&gt; {
            ConfigurationClass configurationClass = this.configurationClasses.get(entry.getMetadata());
            try {
                processImports(configurationClass, asSourceClass(configurationClass, filter),
                        Collections.singleton(asSourceClass(entry.getImportClassName(), filter)),
                        filter, false);
            }
            catch (BeanDefinitionStoreException ex) {
                throw ex;
            }
            catch (Throwable ex) {
                throw new BeanDefinitionStoreException(
                        &#34;Failed to process import candidates for configuration class [&#34; &#43;
                                configurationClass.getMetadata().getClassName() &#43; &#34;]&#34;, ex);
            }
        });
    }
}


遍历保存在Groups - DeferredImportSelectorGroupingHandler中的 DeferredImportSelectorGroup对象，调用 DeferredImportSelectorGroup#getImports()方法
DeferredImportSelectorGroup#getImports()方法调用DeferredImportSelectorGroup中维护的真实的Group - DeferredImportSelector.Group#process方法，然后返回含有meta-info的Entry
使用内部维护的Map(在register中put)，根据Entry.meta-info得到对应的ConfigurationClass ，调用ConfigurationClassParser#processImports，和[前面](#ConfigurationClassParser processImports &ldquo;wikilink&rdquo;)一样递归调用进行处理

所以根据以上分析，DeferredImportSelector最终的处理逻辑在于DeferredImportSelector.Group#process() ^db8805
针对ImportBeanDefinitionRegistar
  
    
  


1
2
3
4
5
6
7
8


public interface ImportBeanDefinitionRegistrar {  
    default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator) {  
        this.registerBeanDefinitions(importingClassMetadata, registry);  
    }  
  
    default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {  
    }  
}

调用ConfigurationClass#addImportBeanDefinitionRegistrar方法，将对应的实例加入configClass对应的Collection类中，后续在[loadBeanDefinitions](#ConfigurationClassBeanDefinitionReader loadBeanDefinitions &ldquo;wikilink&rdquo;)中调用其registerBeanDefinitions，注册相应的BeanDefinition
针对普通配置类
  
    
  
不使用特殊机制，直接递归调用processConfigurationClass
ConfigurationClassParser#getConfigurationClasses
  
    
  
返回从前面得到的所有待配置的配置类
ConfigurationClassBeanDefinitionReader#loadBeanDefinitions
  
    
  
^98f726


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33


public void loadBeanDefinitions(Set&lt;ConfigurationClass&gt; configurationModel) {
        TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator();
        for (ConfigurationClass configClass : configurationModel) {
            loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
        }
    }

/**
 * Read a particular {@link ConfigurationClass}, registering bean definitions
 * for the class itself and all of its {@link Bean} methods.
 */
private void loadBeanDefinitionsForConfigurationClass(
        ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {

    if (trackedConditionEvaluator.shouldSkip(configClass)) {
        String beanName = configClass.getBeanName();
        if (StringUtils.hasLength(beanName) &amp;&amp; this.registry.containsBeanDefinition(beanName)) {
            this.registry.removeBeanDefinition(beanName);
        }
        this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());
        return;
    }

    if (configClass.isImported()) {
        registerBeanDefinitionForImportedConfigurationClass(configClass);
    }
    for (BeanMethod beanMethod : configClass.getBeanMethods()) {
        loadBeanDefinitionsForBeanMethod(beanMethod);
    }

    loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
    loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
}

通过遍历每一个配置类，调用loadBeanDefinitionsForConfigurationClass方法 ^f6a27a

registerBeanDefinitionForImportedConfigurationClass(configClass)
注册配置类自身
loadBeanDefinitionsForBeanMethod(beanMethod)
注册@Bean注解标识的方法
loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
注册@ImportResource引入的XML配置文件中读取的bean定义
loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
注册configClass中经过解析后保存的所有ImportBeanDefinitionRegistrar，注册对应的BeanDefinition

AOP
  
    
  
AOP的实现类是AnnotationAwareAspectJAutoProxyCreator，其是BeanPostProcessor的实现类，具体来说，是InstantiationAwareBeanPostProcessor的实现类，在实例化Bean过程中，通过调用BeanPostProcessor中的实例化前处理器进行短路，得到相应的代理Bean
@EnableAspectJAutoProxy
  
    
  


1
2
3
4
5
6
7
8


@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import({AspectJAutoProxyRegistrar.class})
public @interface EnableAspectJAutoProxy {
    boolean proxyTargetClass() default false;
    boolean exposeProxy() default false;
}

这个注解使用@Import导入了AspectJAutoProxyRegistrar，其是ImportBeanDefinitionRegistrar的实现类，会在处理配置类相应@Import机制的时候将AnnotationAwareAspectJAutoProxyCreator实现类注册到容器中，即注册到BeanDefinition中，实现相应的实例化前处理器功能 (InstantiationAwareBeanPostProcessor)" /><meta name="keywords" content='Java, Spring' />
  <meta itemprop="name" content="Spring 主要源码分析">
  <meta itemprop="description" content="Bean的生命周期为：BeanFactory初始化 - Bean注册 - 实例化 - 属性注入 - 初始化 - 后处理
Bean的注册
  
    
  

扫描：Spring通过配置（XML配置或Java配置）或自动扫描（@ComponentScan）来发现应用中定义的Bean。对于自动扫描，Spring会在指定的包路径下查找标注了@Component、@Service、@Repository、@Controller等注解的类
解析：一旦Bean被发现，Spring将解析Bean的定义信息，包括Bean的作用域（如单例、原型）、生命周期回调（如@PostConstruct、@PreDestroy注解方法）、依赖注入的需求（通过@Autowired、@Resource等注解标记）等 &mdash;&mdash; BeanDefinition
注册：Spring将Bean的定义信息注册到BeanDefinitionRegistry中。这是一个重要步骤，因为注册后的Bean定义将被用于后续的Bean实例化和依赖注入过程。此时，Bean还没有被实例化。

BeanDefinition
  
    
  


BeanDefinition

Spring在初始化过程中，先收集所有bean的元数据信息并注册，bean的元数据描述为接口BeanDefinition，该接口定义了你能想到的一切有关bean的属性信息
BeanDefinition衍生出一系列实现类

AbstractBeanDefinition: 如同其他Spring类，大部分BeanDefinition接口的逻辑都由该抽象类实现
GenericBeanDefinition: 是一站式、用户可见的bean definition；可见的bean definition意味着可以在该bean definition上定义post-processor来对bean进行操作
RootBeanDefinition: 当bean definition存在父子关系的时候，RootBeanDefinition用来承载父元数据的角色（也可独立存在），同时它也作为一个可合并的bean definition使用，在Spring初始化阶段，所有的bean definition均会被（向父级）合并为RootBeanDefinition，子bean definition（GenericBeanDefinition/ChildBeanDefinition）中的定义会覆盖其父bean definition（由parentName指定）的定义
AnnotatedBeanDefinition: 用来定义注解Bean Definition

BeanDefinitionHolder只是简单捆绑了BeanDefinition、bean-name、bean-alias，用于注册BeanDefinition及别名alias ^BeanDefinitionHolder
BeanRegistry
  
    
  
Bean的注册逻辑分为两步，一为BeanDefinition的注册，二为别名的注册

BeanDefinition注册的定义在BeanDefinitionRegistry#registerBeanDefinition，其实现使用一个Map&lt;String, BeanDefinition&gt; 来保存bean-name和BeanDefinition的关系


别名的注册定义在AliasRegistry#registerAlias，其实现同样使用一个Map&lt;String, String&gt; 来保存别名alias-name和bean-name（或另一个别名alias-name）的关系

注意Bean的注册时机，通常应该在应用上下文的刷新过程之前进行(onRefresh())。一旦上下文被刷新，对Bean定义的任何修改可能不会被识别，或者可能会导致不一致的状态
Bean的实例化
  
    
  


BigMap

BeanFactory
  
    
  

几个核心接口：

AliasRegistry
bean别名注册和管理
BeanDefinitionRegistry
bean元数据注册和管理
SingletonBeanRegistry
单例bean注册和管理
BeanFactory
bean工厂，提供各种bean的获取及判断方法

通过上述的类依赖图，对于Bean的实例化，核心实现是在DefaultListableBeanFactory
DefaultListableBeanFactory - AbstractBeanFactory
  
    
  
bean的实例化过程发生在getBean调用阶段（对于singleton则发生在首次调用阶段），getBean的实现方法众多，我们追根溯源，找到最通用的方法AbstractBeanFactory#doGetBean
doGetBean
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22


// org.springframework.beans.factory.support.AbstractBeanFactory
protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,
        @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {

    // 1. 获取真正的beanName
    final String beanName = transformedBeanName(name);
    Object bean;

    // 2. 尝试获取(提前曝光的)singleton bean实例（为了解决循环依赖）
    Object sharedInstance = getSingleton(beanName);
    
    // 3. 如果存在
    if (sharedInstance != null &amp;&amp; args == null) { ... }
    
    // 4. 如果不存在
    else { ... }
    
    // 5. 尝试类型转换
    if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) { ... }
    
    return (T) bean;
}



doGetBean

Bean Name的转换
  
    
  
在使用bean-name获取bean的时候，除了可以使用原始bean-name之外，还可以使用alias别名等，bean-name的转换则是将传入的&rsquo;bean-name&rsquo;一层层转为最原始的bean-name

函数canonicalName的作用则是利用别名注册aliasMap，将别名alias转为原始bean-name
函数transformedBeanName比较特殊，其是将FactoryBean的bean-name前缀 &lsquo;&amp;&rsquo; 去除


尝试获取单例
  
    
  
拿到原始的bean-name之后，便可以实例化bean或者直接获取已经实例化的singleton-bean
在获取singleton-bean的时候一般存在三种情况：1. 还未实例化(或者不是单例)；2. 已经实例化；3. 正在实例化；

对于 &ldquo;1. 还未实例化&rdquo; ，返回null即可，后续进行实例化动作
对于 &ldquo;2. 已经实例化&rdquo;，直接返回实例化的singleton-bean
对于 &ldquo;3. 正在实例化&rdquo;，会存在循环依赖问题

Spring中对于singleton-bean，有一个sharedInstance的概念，在调用getSingleton函数时，返回的不一定是完全实例化的singleton-bean，有可能是一个中间状态（创建完成，但未进行属性依赖注入及其他后处理逻辑），这种中间状态会通过getSingleton函数提前曝光出来，目的是为了解决循环依赖
因此，Spring通过提供三层缓存来解决循环依赖问题，并且可以通过这种机制实现诸多的PostProcessor增强Bean，例如AOP

singletonObjects
缓存已经实例化完成的singleton-bean



earlySingletonObjects
缓存正在实例化的、提前曝光的singleton-bean，用于处理循环依赖


singletonFactories
缓存用于生成earlySingletonObject的 ObjectFactory



ObjectFactory，定义了一个用于创建、生成对象实例的工厂方法



1
2
3
4


@FunctionalInterface
public interface ObjectFactory&lt;T&gt; {
    T getObject() throws BeansException;
}

因此getSingleton的逻辑如下：

NOTE: 在提前暴露实体中，将相应的ObjectFactory放入了singletonFactories
FactoryBean的处理(sharedInstance存在的逻辑)
  
    
  
==sharedInstance不一定是我们所需要的bean实例==
例如，我们在定义Bean的时候可以通过实现FactoryBean接口来定制bean实例化的逻辑(实现FactoryBean)，通过注册FactoryBean类型的Bean，实例化后的原始实例类型同样为FactoryBean，但我们需要的是通过FactoryBean#getObject方法得到的实例，这需要针对FactoryBean做一些处理，即AbstractBeanFactory#getObjectForBeanInstance

Get the object for the given bean instance, either the bean instance itself or its created object in case of a FactoryBean.
Now we have the bean instance, which may be a normal bean or a FactoryBean. If it&rsquo;s a FactoryBean, we use it to create a bean instance.

该函数要实现的逻辑比较简单，如果sharedInstance是 FactoryBean，则使用getObject方法创建真正的实例

getObjectForBeanInstance是一个通用函数，并不只针对通过getSingleton得到的sharedInstance，任何通过缓存或者创建得到的 rawInstance，都需要经过getObjectForBeanInstance处理，拿到真正需要的 beanInstance



1
2
3
4
5
6
7
8


/**
 * @param beanInstance  sharedInstance / rawInstance，可能为FactoryBean
 * @param name            传入的未做转换的 bean name
 * @param beanName        对name做过转换后的原始 canonical bean name
 * @param mbd            合并后的RootBeanDefinition，下文会介绍
 */
protected Object getObjectForBeanInstance(
    Object beanInstance, String name, String beanName, RootBeanDefinition mbd)

getObjectBeanInstance
  
    
  


getObjectForBeanInstance

在这个判断逻辑中，如果入参name以&rsquo;&amp;&lsquo;开头则直接返回，这里兼容了一种情况，如果需要获取/注入FactoryBean而不是getObject生成的实例，则需要在bean-name/alias-name前加入&#39;&amp;&#39;
对于singleton，FactoryBean#getObject的结果会被缓存到factoryBeanObjectCache，对于缓存中不存在或者不是singleton的情况，会通过FactoryBean#getObject生成 ^factorybeangetobject
FactoryBeanRegistrySupport#getObjectFromFactoryBean
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47


protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) {  
    if (factory.isSingleton() &amp;&amp; this.containsSingleton(beanName)) {  
        synchronized(this.getSingletonMutex()) {  
            Object object = this.factoryBeanObjectCache.get(beanName);  
            if (object == null) {  
                object = this.doGetObjectFromFactoryBean(factory, beanName);  
                Object alreadyThere = this.factoryBeanObjectCache.get(beanName);  
                if (alreadyThere != null) {  
                    object = alreadyThere;  
                } else {  
                    if (shouldPostProcess) {  
                        if (this.isSingletonCurrentlyInCreation(beanName)) {  
                            return object;  
                        }  
  
                        this.beforeSingletonCreation(beanName);  
  
                        try {  
                            object = this.postProcessObjectFromFactoryBean(object, beanName);  
                        } catch (Throwable var14) {  
                            throw new BeanCreationException(beanName, &#34;Post-processing of FactoryBean&#39;s singleton object failed&#34;, var14);  
                        } finally {  
                            this.afterSingletonCreation(beanName);  
                        }  
                    }  
  
                    if (this.containsSingleton(beanName)) {  
                        this.factoryBeanObjectCache.put(beanName, object);  
                    }  
                }  
            }  
  
            return object;  
        }  
    } else {  
        Object object = this.doGetObjectFromFactoryBean(factory, beanName);  
        if (shouldPostProcess) {  
            try {  
                object = this.postProcessObjectFromFactoryBean(object, beanName);  
            } catch (Throwable var17) {  
                throw new BeanCreationException(beanName, &#34;Post-processing of FactoryBean&#39;s object failed&#34;, var17);  
            }  
        }  
  
        return object;  
    }  
}

对于Singleton:

首先从缓存中尝试获取，如获取失败，调用[doGetObjectFromFactoryBean](#FactoryBeanRegistrySupport doGetObjectFromFactoryBean &ldquo;wikilink&rdquo;)，其中内核是调用FactoryBean#getObject()方法
对于需要后处理的Bean，首先判断是否处于正在创建状态(isSingletonCurrentlyInCreation)，并且通过this.beforeSingletonCreate() this.afterSingletonCreation()将实际的BeanPostProcessor过程保护
对于BeanPostProcessor，调用this.postProcessObjectFromFactoryBean，其具体实现在[AbstractAutowireCapableBeanFactory#applyBeanPostProcessorAfterInitialization](#AbstractAutowireCapableBeanFactory applyBeanPostProcessorAfterInitialization &ldquo;wikilink&rdquo;)

FactoryBeanRegistrySupport#doGetObjectFromFactoryBean
  
    
  


FactoryBeanRegistrySupport_doGetObjectFromFactoryBean

AbstractAutowireCapableBeanFactory#applyBeanPostProcessorAfterInitialization
  
    
  
postProcessAfterInitialization函数可以对现有bean instance做进一步的处理，甚至可以返回新的bean instance，这就为bean的增强提供了一个非常方便的扩展方式
加载Bean实例 (sharedInstance不存在的逻辑)
  
    
  


createBeanInstance

Bean的加载/创建分为三大部分

将BeanDefinition合并为RootBeanDefinition，类似类继承，子BeanDefinition属性会覆盖父BeanDefinition
依次加载所依赖的bean，对于有依赖的情况，优先递归加载依赖的bean
按照不同的bean类型，根据BeanDefinition的定义进行加载/创建

BeanDefinition合并 (RootBeanDefinition)
  
    
  
在AbstractBeanFactory#getMergedLocalBeanDefinition中执行核心逻辑
加载dependes-On beans
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13


String[] dependsOn = mbd.getDependsOn();
if (dependsOn != null) {
    // 遍历所有的依赖
    for (String dep : dependsOn) {
        // 检测循环依赖
        if (isDependent(beanName, dep)) { /* throw exception */ }
        // 注册依赖关系
        registerDependentBean(dep, beanName);
        // 递归getBean，加载依赖bean
        try { getBean(dep); }
        catch (NoSuchBeanDefinitionException ex) { /* throw exception */ }
    }
}

该过程中涉及两个中间态

dependentBeanMap
存储哪些bean依赖了我（哪些bean里注入了我）
如果 beanB -&gt; beanA, beanC -&gt; beanA，key为beanA，value为[beanB, beanC]


dependenciesForBeanMap
存储我依赖了哪些bean（我注入了哪些bean）
如果 beanA -&gt; beanB, beanA -&gt; beanC，key为beanA，value为[beanB, beanC]

加载singleton bean实例
  
    
  


1
2
3
4
5
6
7
8


if (mbd.isSingleton()) {
    sharedInstance = getSingleton(beanName, () -&gt; {
        // singletonFactory - ObjectFactory
        try { return createBean(beanName, mbd, args); }
        catch (BeansException ex) {    destroySingleton(beanName);    throw ex; }
    });
    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
}

其中核心为createBean与getObjectForBeanInstance

createBean
根据BeanDefinition的内容，创建/初始化 bean instance
#getObjectBeanInstance
主要处理FactoryBean

createBean被包装在lambda(singletonFactory)，重写ObjectFactory#getObject()，作为[getSingleton](#DefaultSingletonBeanRegistry getSingleton(String, ObjectFactory) &ldquo;wikilink&rdquo;)的参数
DefaultSingletonBeanRegistry#getSingleton(String, ObjectFactory)
  
    
  


createSingletonBean

同样的，会先在缓存中查找该singleton，如果不存在，创建的核心逻辑在于[createBean](#AbstractAutowireCapableBeanFactory createBean &ldquo;wikilink&rdquo;)
AbstractAutowireCapableBeanFactory#createBean
  
    
  


createBean


resolveBeanClass
这一步骤用于锁定bean class，在没有显示指定beanClass的情况下，使用className加载beanClass
验证method overrides
==在BeanDefinitionReader 中有提到过lookup-method及replace-method，该步骤是为了确认以上两种配置中的method是否存在==
执行InstantiationAwareBeanPostProcessor前处理器(postProcessBeforeInstantiation)
如果这个步骤中生成了&quot;代理&quot;bean instance，则会有一个短路操作，直接返回该bean instance而不再执行doCreate，其中的核心逻辑为调用this.applyBeanPostProcessorsBeforeInstantiation() ^fcb215



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


try {
    // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
    Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
    if (bean != null) {
          // 如果这里生成了代理的bean instance会直接返回
        return bean;
    }
} cache (Throwable ex) { // throw exception }

try {
  // 创建bean instance
  Object beanInstance = doCreateBean(beanName, mbdToUse, args);
  // ...
}


doCreateBean (AbstractAutowireCapableBeanFactory)
真正bean的创建及初始化过程在此处实现

doCreateBean
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86


protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {  
    BeanWrapper instanceWrapper = null;  
    if (mbd.isSingleton()) {  
        instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName);  
    }  
  
    if (instanceWrapper == null) {  
        instanceWrapper = this.createBeanInstance(beanName, mbd, args);  
    }  
  
    Object bean = instanceWrapper.getWrappedInstance();  
    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();  
    if (beanType != NullBean.class) {  
        mbd.resolvedTargetType = beanType;  
    }  
  
    synchronized(mbd.postProcessingLock) {  
        if (!mbd.postProcessed) {  
            try {  
                this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);  
            } catch (Throwable var17) {  
                throw new BeanCreationException(mbd.getResourceDescription(), beanName, &#34;Post-processing of merged bean definition failed&#34;, var17);  
            }  
  
            mbd.markAsPostProcessed();  
        }  
    }  
  
    boolean earlySingletonExposure = mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; this.isSingletonCurrentlyInCreation(beanName);  
    if (earlySingletonExposure) {  
        if (this.logger.isTraceEnabled()) {  
            this.logger.trace(&#34;Eagerly caching bean &#39;&#34; &#43; beanName &#43; &#34;&#39; to allow for resolving potential circular references&#34;);  
        }  
  
        this.addSingletonFactory(beanName, () -&gt; {  
            return this.getEarlyBeanReference(beanName, mbd, bean);  
        });  
    }  
  
    Object exposedObject = bean;  
  
    try {  
        this.populateBean(beanName, mbd, instanceWrapper);  
        exposedObject = this.initializeBean(beanName, exposedObject, mbd);  
    } catch (Throwable var18) {  
        if (var18 instanceof BeanCreationException bce) {  
            if (beanName.equals(bce.getBeanName())) {  
                throw bce;  
            }  
        }  
  
        throw new BeanCreationException(mbd.getResourceDescription(), beanName, var18.getMessage(), var18);  
    }  
  
    if (earlySingletonExposure) {  
        Object earlySingletonReference = this.getSingleton(beanName, false);  
        if (earlySingletonReference != null) {  
            if (exposedObject == bean) {  
                exposedObject = earlySingletonReference;  
            } else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; this.hasDependentBean(beanName)) {  
                String[] dependentBeans = this.getDependentBeans(beanName);  
                Set&lt;String&gt; actualDependentBeans = new LinkedHashSet(dependentBeans.length);  
                String[] var12 = dependentBeans;  
                int var13 = dependentBeans.length;  
  
                for(int var14 = 0; var14 &lt; var13; &#43;&#43;var14) {  
                    String dependentBean = var12[var14];  
                    if (!this.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {  
                        actualDependentBeans.add(dependentBean);  
                    }  
                }  
  
                if (!actualDependentBeans.isEmpty()) {  
                    throw new BeanCurrentlyInCreationException(beanName, &#34;Bean with name &#39;&#34; &#43; beanName &#43; &#34;&#39; has been injected into other beans [&#34; &#43; StringUtils.collectionToCommaDelimitedString(actualDependentBeans) &#43; &#34;] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using &#39;getBeanNamesForType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&#34;);  
                }  
            }  
        }  
    }  
  
    try {  
        this.registerDisposableBeanIfNecessary(beanName, bean, mbd);  
        return exposedObject;  
    } catch (BeanDefinitionValidationException var16) {  
        throw new BeanCreationException(mbd.getResourceDescription(), beanName, &#34;Invalid destruction signature&#34;, var16);  
    }  
}

可以将该流程细分为如下：

[创建Bean实体](#创建Bean实体 AbstractAutowireCapableBeanFactory createBeanInstance &ldquo;wikilink&rdquo;)
[BeanDefinition后处理](#BeanDefinition后处理 - AbstractAutowireCapableBeanFactory applyMergedBeanDefinitionPostProcessors &ldquo;wikilink&rdquo;)
提前暴露实体
[属性注入](#属性注入 - AbstractAutowireCapableBeanFactory populateBean &ldquo;wikilink&rdquo;)
[初始化](#初始化 - AbstractAutowireCapableBeanFactory initializeBean &ldquo;wikilink&rdquo;)
[注册Disposable](#注册Disposable - AbstractBeanFactory registerDisposableBeanIfNecessary &ldquo;wikilink&rdquo;)

创建Bean实体 - AbstractAutowireCapableBeanFactory#createBeanInstance
  
    
  


createBeanInstance_2


instanceSupplier
从上面的流程图可以看出，创建bean实体不一定会使用到构造函数，可以使用Supplier的方式
factory method
工厂模式
@Configuration &#43; @Bean的实现方式就是factory-bean &#43; factory-method
[对应的参数获取](#ConstructorResolver resolvePreparedArguments &ldquo;wikilink&rdquo;)
有参构造函数
AbstractAutowireCapableBeanFactory#autowireConstructor -&gt; [ConstructorResolver#autowireConstructor](#**ConstructorResolver autowireConstructor** &ldquo;wikilink&rdquo;)
无参构造函数
与有参构造创建过程一致，除了不需要参数的依赖注入，使用默认无参构造函数进行实例化

ConstructorResolver#resolvePreparedArguments
  
    
  
使用指定（类）bean的（静态）方法创建bean实体的逻辑在ConstructorResolver#instantiate(String, RootBeanDefinition, Object, Method, args)，而真正的逻辑在SimpleInstantiationStrategy#instantiate(RootBeanDefinition, String, BeanFactory, Object, Method, Object&hellip;)，其核心的执行逻辑非常简单，有了方法factoryMethod(factoryBean)及入参args，便可以调用该方法创建bean实体


1


Object result = factoryMethod.invoke(factoryBean, args);

factoryBean可以通过beanFactory.getBean获取到（正是当前在讲的逻辑），factoryMethod可以通过反射获取到，而入参args就从ConstructorResolver#resolvePreparedArguments中获取，即是Spring中依赖注入的核心实现
该函数的作用是将BeanDefinition中定义的入参转换为需要的参数(==将BeanDefinitionReader中封装的对象转换==)


resolvePreparedArguments

More in blogs
ConstructorResolver#autowireConstructor
  
    
  
同样的，调用ConstructorResolver#resolvePreparedArguments进行参数的解析和转换(参数的依赖注入)，然后调用 [ConstructorResolver#instantiate](#ConstructorResolver instantiate &ldquo;wikilink&rdquo;) 来创建Bean实例
ConstructorResolver#instantiate
  
    
  
内部并没有统一利用反射技术直接使用构造函数创建，而是通过InstantiationStrategy.instantiate进行创建


Instantiate


没有设置override-method时，直接使用构造函数创建
设置了override-method时，使用cglib技术构造代理类，并代理override方法

Spring默认的实例化策略为CglibSubclassingInstantiationStrategy
BeanDefinition后处理 - AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors
  
    
  
在属性注入之前提供一次机会来对BeanDefinition进行处理，内部执行所有注册MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition方法

[!hint] MergedBeanDefinitionPostProcessor
MergedBeanDefinitionPostProcessor 是一个特定类型的 BeanPostProcessor。MergedBeanDefinitionPostProcessor 的 postProcessMergedBeanDefinition 方法允许在实例化bean之后但在设置bean属性之前，对bean的定义（BeanDefinition）进行后处理。这个阶段是用于修改或增强bean定义的，例如，可以解析注解并相应地修改 BeanDefinition 的属性。

对于MergedBeanDefinitionPostProcessor的实现类AutowiredAnnotationBeanPostProcessor，其内部方法AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata 实现了两个注解类的解析 @Value 及 @Autowired ，找到注解修饰的Filed或者Method并缓存，具体逻辑在[属性注入](#属性注入 - AbstractAutowireCapableBeanFactory populateBean &ldquo;wikilink&rdquo;) ^autowiredAnnotationBeanPostProcessor1
提前暴露实体
  
    
  
通过将AbstractAutowireCapableBeanFactory#getEarlyBeanReference封装为ObjectFactory，调用DefaultSingletonBeanRegistry#addSingletonFactory，将该ObjectFactory缓存在DefaultSingletonBeanRegistry.singletonFactories中，在getBean逻辑中的getSingleton会执行ObjectFactory将singleton提前暴露
==此处即为何时添加ObjectFactory进入singletonFactories中，解决循环依赖==

此时暴露的singleton-bean仅完成了bean的实例化，属性注入、初始化等逻辑均暂未执行

属性注入 - AbstractAutowireCapableBeanFactory#populateBean
  
    
  
在[创建Bean实体](#创建Bean实体 - AbstractAutowireCapableBeanFactory createBeanInstance &ldquo;wikilink&rdquo;)中介绍了factory method方式及有参构造函数方式的参数注入逻辑，除此之外还有一种注入便是属性注入


populateBean

流程中出现了两次InstantiationAwareBeanPostProcessor，在第一次出现中调用的postProcessorAfterInstantiation也与前面的InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation相同，拥有短路操作：如果该步骤生成了&quot;代理&quot;bean instance，直接返回该bean instance而不再执行后续的doCreate；如果有任意一个InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation方法返回false，则会跳出属性注入的逻辑，官方对此的解释如下

Give any InstantiationAwareBeanPostProcessors the opportunity to modify the state of the bean before properties are set. This can be used, for example, to support styles of field injection.

autowireByName及autowireByType方法作为&quot;候补&quot;补充BeanDefinition的propertyValues
PropertyValue中记录了需要注入的属性信息及需要注入的属性值，那BeanDefinition的propertyValues都来自哪里？xml中的bean配置、自定义的BeanDefinition等
通过注解修饰的属性(方法)通过InstantiationAwareBeanPostProcessor#postProcessProperties进行注入 -&gt; ==AutowiredAnnotationBeanPostProcessor#postProcessProperties &amp; CommonAnnotationBeanPostProcessor#postProcessProperties==
最后，通过AbstractAutowireCapableBeanFactory#applyPropertyValues 将PropertyValue中记录的需要注入的属性，已经依赖的类型（String、RuntimeBeanReference、等），根据不同的类型解析依赖的bean并设置到对应的属性上（==此过程与DefaultListableBeanFactory#doResolveDependency相似==）
初始化 - AbstractAutowireCapableBeanFactory#initializeBean
  
    
  
以上，完成了bean实例的创建和属性注入，之后还有一些初始化的方法，比如各种Aware的setXxx是如何调用的、@PostConstruct是怎么调用的？


initializeBean

注册Disposable - AbstractBeanFactory#registerDisposableBeanIfNecessary
  
    
  
至此，终于完成了bean实例的创建、属性注入以及之后的初始化，此后便可以开始使用了
在使用Spring的过程中经常还会碰到设置销毁逻辑的情况，如数据库连接池、线程池等等，在Spring销毁bean的时候还需要做一些处理，类似于C&#43;&#43;中的析构
在bean的创建逻辑中，最后一个步骤则是注册bean的销毁逻辑（DisposableBean）
销毁逻辑的注册有几个条件

非prototype（singleton或者注册的scope）
非NullBean
指定了destroy-method（如xml中指定或者BeanDefinition中直接设置）或者存在**@PreDestroy** 注解的方法（CommonAnnotationBeanPostProcessor.requiresDestruction）



1


if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd))

满足以上条件的bean会被封装为DisposableBeanAdapter，并注册在DefaultSingletonBeanRegistry.disposableBeans中
加载prototype bean实例
  
    
  


1
2
3
4
5
6
7
8
9


else if (mbd.isPrototype()) {
    Object prototypeInstance = null;
    try {
        beforePrototypeCreation(beanName);
        prototypeInstance = createBean(beanName, mbd, args);
    }
    finally { afterPrototypeCreation(beanName);    }
    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
}

prototype bean的创建与singleton bean类似，只是不会缓存创建完成的bean
加载其他scope bean实例
  
    
  
scope，即作用域，或者可以理解为生命周期
上文介绍了singleton-bean及prototype-bean的创建过程，严格意义上讲以上两种都是一种特殊的scope-bean，分别对应ConfigurableBeanFactory#SCOPE_SINGLETON及ConfigurableBeanFactory#SCOPE_PROTOTYPE，前者作用域为整个IOC容器，也可理解为单例，后者作用域为所注入的bean，每次注入(每次触发getBean)都会重新生成
Spring中还提供很多其他的scope，如WebApplicationContext#SCOPE_REQUEST或WebApplicationContext#SCOPE_SESSION，前者作用域为一次web request，后者作用域为一个web session周期
自定义scope的bean实例创建过程与singleton bean的创建过程十分相似，需要实现Scope的get方法(org.springframework.beans.factory.config.Scope#get)


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


else {
    String scopeName = mbd.getScope();
    final Scope scope = this.scopes.get(scopeName);
    if (scope == null) { /* throw exception */ }
    try {
        Object scopedInstance = scope.get(beanName, () -&gt; {
            beforePrototypeCreation(beanName);
            // createBean被封装在Scope#get函数的lambda参数ObjectFactory中
            try { return createBean(beanName, mbd, args); }
            finally { afterPrototypeCreation(beanName); }
        });
        bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
    } catch (IllegalStateException ex) { /* throw exception */}
}

Scope接口除了get方法之外，还有一个remove方法，前者用于定义bean的初始化逻辑，后者用于定义bean的销毁逻辑


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


public interface Scope {
  /**
   * Return the object with the given name from the underlying scope
   */
  Object get(String name, ObjectFactory&lt;?&gt; objectFactory);
  
   /**
   * Remove the object with the given name from the underlying scope.
   */
  Object remove(String name);
}

WebApplicationContext#SCOPE_SESSION对应的Scope实现见org.springframework.web.context.request.SessionScope
WebApplicationContext#SCOPE_REQUEST对应的Scope实现见org.springframework.web.context.request.RequestScope
以上两种Scope实现都较为简单，前者将初始化的bean存储在request attribute中，后者将初始化的bean存储在http session中
尝试类型转换
  
    
  
以上，完成了bean的创建、属性的注入、dispose逻辑的注册，但获得的bean类型与实际需要的类型可能依然不相符，在最终交付bean之前（getBean）还需要进行一次类型转换，使用PropertyEditor进行类型转换，将bean转换为真正需要的类型后，便完成了整个getBean的使命
Bean销毁过程
  
    
  
bean的创建过程始于DefaultListableBeanFactory#getBean，销毁过程则终于ConfigurableApplicationContext#close，跟踪下去，具体的逻辑在DefaultSingletonBeanRegistry#destroySingletons

DefaultSingletonBeanRegistry.disposableBeans
需要注册销毁逻辑的bean会被封装为DisposableBeanAdapter并缓存在此处
DefaultSingletonBeanRegistry.dependentBeanMap
对于存在依赖注入关系的bean，会将bean的依赖关系缓存在此处（dependentBeanMap: 哪些bean依赖了我; dependenciesForBeanMap: 我依赖了哪些bean）



destory

从上图中可以看出，bean的销毁顺序与创建顺序正好相反，如果有 beanA &ndash;dependsOn&ndash;&gt; beanB &ndash;&gt; beanC ，创建（getBean）时一定是beanC -&gt; beanB -&gt; beanA，销毁时一定是 beanA -&gt; beanB -&gt; beanC，以此避免因为依赖关系造成的一些异常情况
循环依赖
  
    
  
earlySingletonObject是用来解决循环依赖的问题，具体时机是在实例化完后属性注入之前，会提前将当前的bean实体暴露出来，以防止在属性注入过程中所注入的bean又依赖当前的bean造成的类似&quot;死锁&quot;的状态
但是存在以下情况，Spring依旧会陷入循环依赖死锁：

显式设置dependsOn的循环依赖



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


@DependsOn(&#34;beanB&#34;)
@Component
public class BeanA {}

@DependsOn(&#34;beanC&#34;)
@Component
public class BeanB {}

@DependsOn(&#34;beanA&#34;)
@Component
public class BeanC {}


构造函数循环依赖



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17


@Component
public class BeanA {
    public BeanA(BeanB beanB) {
    }
}

@Component
public class BeanB {
    public BeanB(BeanC beanC) {
    }
}

@Component
public class BeanC {
    public BeanC(BeanA beanA) {
    }
}


factory-method循环依赖



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


@Bean
public BeanA beanA(BeanB beanB) {
    return new BeanA();
}

@Bean
public BeanB beanB(BeanC beanC) {
    return new BeanB();
}

@Bean
public BeanC beanC(BeanA beanA) {
    return new BeanC();
}


上述三种依赖混合

只要一个循环依赖中的所有bean，其依赖关系都需要在创建bean实例之前进行解决，此循环依赖则一定无解
要打破无解的循环依赖，在构成循环依赖的一个环中，只需要保证其中至少一个Bean的依赖在该Bean创建且暴露earlySingleton之后处理即可，即在属性注入阶段进行属性依赖的处理


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16


@Component
public class BeanA {
    @Autowired
    private BeanB beanB;
}

@Component
public class BeanB {
    public BeanB(BeanC beanC) {
    }
}

@Bean
public BeanC beanC(BeanA beanA) {
    return new BeanC();
}

以&quot;bean创建且暴露earlySingleton&quot;为节点，在此之前处理依赖的有instance supplier parameter、factory method parameter、constructor parameter、等，在此之后处理的依赖有 class property、setter parameter等
ApplicationContext
  
    
  
BeanFactory实现了IoC的基础能力，而ApplicationContext是BeanFactory的子类，除了继承IoC的基础能力外

支持国际化 (MessageSource)
支持资源访问 (ResourcePatternResolver)
事件机制 (ApplicationEventPublisher)
默认初始化所有Singleton
提供扩展能力



ApplicationContext

无论何种功能的ApplicationContext，在做完基本的初始化后均会调用AbstractApplicationContext#Refresh
AbstractApplicationContext#Refresh
  
    
  


refresh

准备上下文 - AbstractApplicationContext#prepareRefresh
  
    
  
该部分主要实现对上下文的准备工作，其主要涉及到两个接口AbstractApplicationContext#initPropertySources及ConfigurablePropertyResolver#validateRequiredProperties，前者由子类实现，用于初始化PropertySource；后者用于对必要属性进行验证


1
2
3
4
5
6
7


public class MyClasspathXmlApplicationContext extends ClassPathXmlApplicationContext {
    @Override
    protected void initPropertySources() {
        super.initPropertySources();
        getEnvironment().setRequiredProperties(&#34;runtimeEnv&#34;);
    }
}

重写initPropertySources方法，并添加runtimeEnv为必须的环境变量属性，如此在系统启动的时候便会进行检测，对于不存在任何一个必要环境变量的情况均会抛出异常终止启动
加载BeanFactory - AbstractApplicationContext#obtainFreshBeanFactory
  
    
  
该函数内部实现比较简单，重点在refreshBeanFactory，该函数同样由子类实现
对于AbstractRefreshableApplicationContext，refreshBeanFactory基本步骤为

创建BeanFactory (DefaultListableBeanFactory)
设置BeanFactory
加载BeanDefinition

在第3步中，AbstractXmlApplicationContext的实现则是对xml配置文件的解析及加载；AnnotationConfigWebApplicationContext的实现则是对class文件的扫描并加载，以及其他基于AbstractRefreshableApplicationContext的ApplicationContext实现
对于GenericApplicationContext，BeanFactory的创建及BeanDefinition的加载在refresh调用之前早已完成，refreshBeanFactory的实现则是对BeanFactory加载状态的简单校验
AbstractRefreshableApplicationContext &amp; GenericApplicationContext
  
    
  
AbstractRefreshableApplicationContext
  
    
  
对于继承自 AbstractRefreshableApplicationContext 的上下文，例如 ClassPathXmlApplicationContext 或 AnnotationConfigApplicationContext，它们通过覆盖 refreshBeanFactory() 方法来实现具体的 BeanDefinition 加载逻辑。这些上下文类型专门用于从外部资源（如 XML 文件、Java 配置类等）加载配置信息，并将这些配置信息解析为一组 BeanDefinition，然后注册到内部的 BeanFactory 中。这个过程通常发生在上下文的 refresh() 方法调用过程中（我们正在讨论的），这个方法不仅负责加载和注册 BeanDefinition，还包括初始化单例bean、处理别名定义、注册BeanPostProcessor等一系列容器启动时的活动。

[!QUOTE] refresh()关键步骤 ^configurerRelated

创建 BeanFactory：AbstractRefreshableApplicationContext 首先会创建一个新的 BeanFactory 实例，这通常是一个 DefaultListableBeanFactory 实例。这个 BeanFactory 实现了 BeanDefinitionRegistry 接口，使得它能够注册 BeanDefinition。
==加载 BeanDefinition：接着，上下文会调用特定的方法（例如，对于基于 XML 的配置，会使用 XmlBeanDefinitionReader；对于基于注解的配置，会使用 AnnotatedBeanDefinitionReader 和 ClassPathBeanDefinitionScanner）来加载 BeanDefinition。这些 Reader 和 Scanner 实现了 BeanDefinitionRegistry 接口的 registerBeanDefinition 方法来实际完成注册工作。==
刷新 BeanFactory：加载完所有 BeanDefinition 后，AbstractRefreshableApplicationContext 会对 BeanFactory 进行刷新，这涉及到预实例化单例、注册 BeanPostProcessor、初始化剩余的非懒加载单例等一系列操作。
发布事件：在整个容器刷新过程中，还会发布各种应用事件，如 ContextRefreshedEvent，允许应用中的其他组件对这些事件作出响应。

通过上述步骤，AbstractRefreshableApplicationContext 完成了 BeanDefinition 的加载、注册以及整个 Spring 容器的初始化和刷新工作。在这个过程中，BeanDefinitionRegistry 接口扮演了 BeanDefinition 注册的关键角色
GenericApplicationContext
  
    
  

GenericApplicationContext 直接实现了 BeanDefinitionRegistry 接口，使得它可以在运行时动态注册 BeanDefinition。与 AbstractRefreshableApplicationContext 的子类不同，GenericApplicationContext 并不专门依赖于外部资源来加载 BeanDefinition。相反，它提供了一套程序化的接口，允许开发者直接在代码中通过调用 registerBeanDefinition(String beanName, BeanDefinition beanDefinition) 方法来注册 BeanDefinition。这种方式使得 GenericApplicationContext 非常灵活，适用于那些需要在运行时动态调整 Spring 配置的场景。
关系和区别
  
    
  

加载方式的区别：AbstractRefreshableApplicationContext 的子类通常通过解析配置资源（XML、注解等）来加载 BeanDefinition，而 GenericApplicationContext 允许以编程方式直接注册 BeanDefinition。
使用场景的区别：AbstractRefreshableApplicationContext 的子类适合于静态配置资源的场景，其中配置信息在应用启动时已经确定。GenericApplicationContext 更适合于动态配置的场景，比如基于条件的 BeanDefinition 注册或运行时的配置调整。
刷新容器的能力：虽然两者都可以通过 refresh() 方法来刷新应用上下文，但 AbstractRefreshableApplicationContext 的子类通常在设计时就考虑了完整的容器刷新流程（包括重新加载配置资源），而 GenericApplicationContext 刷新主要是为了应用新注册的 BeanDefinition。==前者会重置BeanFactory而后者不会==

填充部分扩展 - AbstractApplicationContext#prepareBeanFactory
  
    
  
该函数执行以下逻辑

设置BeanFactory的ClassLoader
注册默认BeanExpressionResolver，用于依赖注入时SpEL的支持
注册默认PropertyEditor，用于依赖注入时对参数的解析转换
注册几个特殊Aware的处理逻辑
注册AspectJ相关的几个处理器，用于AOP的支持
注册几个特殊的BeanDefinition

==2-3 的核心逻辑在于解析依赖的值，DefaultListableBenFactory#doResolveDependency==
注册几个特殊Aware的处理逻辑
  
    
  
在Bean实例化、注入依赖之后会对Bean进行[最后的初始化](#初始化 - AbstractAutowireCapableBeanFactory initializeBean &ldquo;wikilink&rdquo;)，调用相应的setter方法分别针对BeanNameAware、BeanClassLoaderAware、BeanFactoryAware进行处理
在该函数中，会注册几个特殊的BeanPostProcessor


1


beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));

其实现了postProcessBeforeInitialization方法，内部调用ApplicationContextAwareProcessor#invokeAwareInterfaces针对另外的几类Aware进行了处理
除此之外，Spring会将上述几类Aware设置为ignoreDependencyInterface，这意味着以上几类Bean的注入只能通过Aware的方式而不能通过其他属性依赖注入的方式（属性注入、函数参数注入等）
注册特殊的Bean
  
    
  
在使用Spring时，是否有过直接注入BeanFactory亦或是ResourceLoader，这些bean正是在这里被Spring注册进去的，除以上外Spring还注入了

BeanFactory
ResourceLoader
ApplicationEventPublisher
ApplicationContext
Environment
systemProperties - Environment#.getSystemProperties:Map&lt;String, Object&gt;
systemEnvironment - Environment#.getSystemEnvironment:Map&lt;String, Object&gt;
AbstractApplicationContext#refresh#postProcessBeanFactory()
  
    
  


对于不同的实现类，注册相应的BeanPostProcessor，例如ServletWebServerApplicationContext
激活BeanFactoryPostProcessor - AbstractApplicationContext#invokeBeanFactoryPostProcessors
  
    
  
其内部实现在PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors
BeanFactoryPostProcessor的定义非常简单，其postProcessBeanFactory方法允许在bean实例化前对BeanFactory做一些额外的设置


1
2
3
4
5
6
7
8
9


public interface BeanFactoryPostProcessor {
    /**
     * Modify the application context&#39;s internal bean factory after its standard
     * initialization. All bean definitions will have been loaded, but no beans
     * will have been instantiated yet. This allows for overriding or adding
     * properties even to eager-initializing beans.
     */
    void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;
}

核心逻辑如下


invokeBeanFactoryPostProcessors

其中涉及两种类型，BeanDefinitionRegistryPostProcessor及BeanFactoryPostProcessor，前者为后者的子类，BeanDefinitionRegistryPostProcessors提供了额外的接口postProcessBeanDefinitionRegistry，用于更加方便地动态地注册额外的BeanDefinition (registryProcessor.postProcessBeanDefinitionRegistry(registry))，如读取配置文件（json、properties、yml）并解析（或者任何其他的形式），并通过该接口注册相应的BeanDefinition，基于Spring Boot Starter的很多框架均使用该方式进行bean的注册
以上流程图可以看出，优先执行BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry，再执行BeanFactoryPostProcessor#postProcessBeanFactory，各自内部优先执行PriorityOrdered实现，再执行Ordered实现，最后执行无任何排序的实现
注册BeanPostProcessor - AbstractApplicationContext#registerBeanPostProcessors
  
    
  
其内部实现在PostProcessorRegistrationDelegate#registerBeanPostProcessors
b
BeanPostProcessor
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23


public interface BeanPostProcessor {
    /**
     * Apply this BeanPostProcessor to the given new bean instance before any bean
     * initialization callbacks (like InitializingBean&#39;s afterPropertiesSet
     * or a custom init-method). 
     * The returned bean instance may be a wrapper around the original.
     */
    @Nullable
    default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }

    /**
     * Apply this BeanPostProcessor to the given new bean instance after any bean
     * initialization callbacks (like InitializingBean&#39;s afterPropertiesSet
     * or a custom init-method).
     * The returned bean instance may be a wrapper around the original.
     */
    @Nullable
    default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }
}


postProcessBeforeInitialization方法在调用bean的init-method之前执行
postProcessAfterInitialization方法在调用bean的init-method之后执行
任何一个方法可对现有bean实例做进一步的修改
任何一个方法可返回新的bean实例，用来替代现有的bean实例

第四点即是AOP生成当前Bean代理的方法
InstantiationAwareBeanPostProcessor
  
    
  
该接口继承自BeanPostProcessor，其同样有两个方法，一个在创建bean实例之前调用([createBean](#AbstractAutowireCapableBeanFactory createBean &ldquo;wikilink&rdquo;))，一个在创建bean实例之后、属性注入之前调用([属性注入](#属性注入 - AbstractAutowireCapableBeanFactory populateBean &ldquo;wikilink&rdquo;))


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15


public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor {  
    @Nullable  
    default Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException {  
        return null;  
    }  
  
    default boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {  
        return true;  
    }  
  
    @Nullable  
    default PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException {  
        return pvs;  
    }  
}

AbstractApplicationContext#registerBeanPostProcessors，其内部逻辑与BeanFactoryPostProcessor的注册逻辑类似：

找到所有BeanPostProcessor并实例化
按照实现的Ordered接口分别放入priorityOrderedPostProcessors、orderedPostProcessors、nonOrderedPostProcessors并各自排序
如果实现了MergedBeanDefinitionPostProcessor则放入internalPostProcessors并排序
按顺序依次注册priorityOrderedPostProcessors、orderedPostProcessors、nonOrderedPostProcessors
最后注册internalPostProcessors

MergedBeanDefinitionPostProcessor其有一个接口postProcessMergedBeanDefinition，在bean实例化完成后属性注入之前被调用，可以用来对当前的BeanDefinition做进一步的修改，如增加PropertyValue等，实现特殊的属性依赖注入，参考[BeanDefinition后处理](#BeanDefinition后处理 - AbstractAutowireCapableBeanFactory applyMergedBeanDefinitionPostProcessors &ldquo;wikilink&rdquo;)与[属性注入](#属性注入 - AbstractAutowireCapableBeanFactory populateBean &ldquo;wikilink&rdquo;)
初始化MessageSource - AbstractApplicationContext#initMessageSource
  
    
  
Spring的MessageSource提供了国际化能力，在开发者未注册MessageSource的情况下Spring会提供一个默认的DelegatingMessageSource
初始化ApplicationEventMulticaster - AbstractApplicationContext#initApplicationEventMulticaster
  
    
  
Spring提供了一套事件（ApplicationEvent）的发布&amp;订阅机制，开发者可自定义事件（继承ApplicationEvent），注册事件监听器来订阅消费事件（实现ApplicationListener 或使用@EventListener 注解），并使用ApplicationEventPublisher（直接依赖注入或者使用ApplicationEventPublisherAware）发送事件，使用示例可参考https://www.baeldung.com/spri&hellip;
其实ApplicationContext实现了ApplicationEventPublisher，跟踪其publishEvent方法会发现，最终调用了AbstractApplicationContext#applicationEventMulticaster.multicastEvent，开发者可以自行注册一个ApplicationEventMulticaster，如果没有Spring会提供一个默认的SimpleApplicationEventMulticaster
SimpleApplicationEventMulticaster#multicastEvent的逻辑比较简单，会根据事件的类型找到可以处理的所有ApplicationListener，依次调用它们的onApplicationEvent方法消费事件


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15


@Override
public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {
    ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
    Executor executor = getTaskExecutor();
    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {
        if (executor != null) {
      // 设置了executor，则异步执行
            executor.execute(() -&gt; invokeListener(listener, event));
        }
        else {
      // 否则同步执行
            invokeListener(listener, event);
        }
    }
}

默认情况下会同步、顺序的调用listeners的onApplicationEvent方法，只有设置了executor才会异步调用，不过这样的控制粒度比较粗，要么全部同步消费要么全部异步消费，比较细粒度的控制事件的消费有几种常用方法

使用@Async注解，独立控制某一listener异步消费（https://www.baeldung.com/spri&hellip;）
自行编码，将onApplicationEvent逻辑放在线程中执行
注册自定义的ApplicationEventMulticaster，内部实现自己的同步、异步Event处理逻辑

注册ApplicationListener - AbstractApplicationContext#registerListeners
  
    
  
这里的逻辑比较简单

在BeanFactory中找到ApplicationListener类型的bean并实例化
调用ApplicationEventMulticaster#addApplicationListenerBean方法将ApplicationListeners注册进去

初始化所有非Lazy Bean - AbstractApplicationContext#finishBeanFactoryInitialization
  
    
  
对于Singleton Bean而言，实例化发生在首次getBean，但你是否有疑惑，我们只是注册了众多Singleton Bean，但在Spring初始化完成后所有的Singleton Bean（Lazy Bean除外）均已经完成实例化
回到AbstractApplicationContext#finishBeanFactoryInitialization，该函数会实现几个逻辑

如果自定义了ConversionService(另一种注入类型转换的方式)类型bean且bean-name为conversionService，则将其注册到BeanFactory中
如果BeanFactory中不存在EmbeddedValueResolver（PropertyResourceConfigurer会注册一个PlaceholderResolvingStringValueResolver到BeanFactory中），则会注册一个默认的StringValueResolver用来处理 ${ ... }类型的值（Environment#resolvePlaceholders）
找到所有非Lazy的Singleton BeanDefinition进行实例化（getBean）

如果是FactoryBean，则在bean name前加上&rsquo;&amp;&rsquo;，并实例化该FactoryBean，随后实例化真实的bean
如果不是FactoryBean，则直接实例化该bean


执行SmartInitializingSingleton实现类的afterSingletonsInstantiated方法

Refresh的后续动作 - AbstractApplicationContext#finishRefresh
  
    
  
除了一些中间状态需要清理外，还有两件比较特殊的地方
LifecycleProcessor - AbstractApplicationContext#initLifecycleProcessor
  
    
  
Spring提供了LifecycleProcessor用于监听BeanFactory的refresh及close，在BeanFactory的各阶段会调用LifecycleProcessor的onFresh及onClose方法
开发者可以自行注册LifecycleProcessor类型的bean，bean-name必须为&quot;lifecycleProcessor&quot;，否则Spring会提供一个默认的DefaultLifecycleProcessor
之后则会触发LifecycleProcessor的onFresh方法

除此之外，还可以监听ContextRefreshedEvent及ContextClosedEvent消息

refresh事件
  
    
  
在BeanFactory初始化完成后，则会发出ContextRefreshedEvent事件
BeanFactory的销毁 - AbstractApplicationContext#registerShutdownHook
  
    
  
该函数用来注册BeanFactory的销毁逻辑


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13


public void registerShutdownHook() {  
    if (this.shutdownHook == null) {  
        this.shutdownHook = new Thread(&#34;SpringContextShutdownHook&#34;) {  
            public void run() {  
                synchronized(AbstractApplicationContext.this.startupShutdownMonitor) {  
                    AbstractApplicationContext.this.doClose();  
                }  
            }  
        };  
        Runtime.getRuntime().addShutdownHook(this.shutdownHook);  
    }  
  
}

其直接使用了java的addShutdownHook函数，在jvm进程正常退出的时候触发
AbstractApplicationContext#doClose函数定义了BeanFactory具体的销毁过程

发出ContextClosedEvent事件
触发LifecycleProcessor的onClose方法
销毁bean，细节参考Bean销毁过程
由子类实现的AbstractApplicationContext#closeBeanFactory及AbstractApplicationContext#onClose方法

ASIDE
  
    
  

BeanDefinition的加载在[AbstractApplicationContext#obtainFreshBeanFactory](#加载BeanFactory - AbstractApplicationContext obtainFreshBeanFactory &ldquo;wikilink&rdquo;)中实现
TODO

#{ ... }类型值的解析由StandardBeanExpressionResolve实现
${ ... }类型值的解析由PlaceholderResolvingStringValueResolver实现
Spring提供了众多默认的PropertyEditor，若需要自定义PropertyEditor可以通过注册CustomEditorConfigurer实现
Spring提供了众多Aware，若需要自定义Aware可以通过BeanPostProcessor实现
BeanFactoryPostProcessor用于在实例化bean之前对BeanFactory做额外的动作
如，PropertyResourceConfigurer用来将PlaceholderResolvingStringValueResolver注册到BeanFactory的embeddedValueResolvers中


[BeanDefinitionRegistryPostProcessor](#激活BeanFactoryPostProcessor - AbstractApplicationContext invokeBeanFactoryPostProcessors &ldquo;wikilink&rdquo;)用于在实例化bean之前（动态）注册额外的BeanDefinition ^fa1ce8
BeanPostProcessor用于在调用bean的init-method前后，对实例化完成的bean做一些额外的干预
如，CommonAnnotationBeanPostProcessor用来处理@PostConstructor，AbstractAdvisingBeanPostProcessor用来实现AOP

ApplicationContext具体实现类 - AnnotationConfigApplicationContext
  
    
  


1
2
3
4
5


public AnnotationConfigApplicationContext(Class&lt;?&gt;... componentClasses) { 
    this(); //1. 首先会调用自己的无参构造 
    register(componentClasses); //2. 然后注册我们传入的配置类 
    refresh(); //3. 最后进行刷新操作（关键） 
}

无参构造
  
    
  


1
2
3
4
5
6
7
8


public AnnotationConfigApplicationContext() {
        StartupStep createAnnotatedBeanDefReader = this.getApplicationStartup().start(&#34;spring.context.annotated-bean-reader.create&#34;);
      //创建AnnotatedBeanDefinitionReader对象，用于后续处理 @Bean 注解
        this.reader = new AnnotatedBeanDefinitionReader(this);
        createAnnotatedBeanDefReader.end();
      //创建ClassPathBeanDefinitionScanner对象，用于扫描类路径上的Bean
        this.scanner = new ClassPathBeanDefinitionScanner(this);
}

AnnotatedBeanDefinitionReader
  
    
  


1
2
3
4
5
6
7
8


public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
        Assert.notNull(registry, &#34;BeanDefinitionRegistry must not be null&#34;);
        Assert.notNull(environment, &#34;Environment must not be null&#34;);
        this.registry = registry;
        this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);
      //这里注册了注解处理配置相关的后置处理器
        AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
}

这里会将ConfigurationClassPostProcessor后置处理器加入到BeanFactory中，它继承自BeanFactoryPostProcessor，也就是说一会会在BeanFactory初始化完成之后进行后置处理，同时这里也会注册一个AutowiredAnnotationBeanPostProcessor后置处理器到BeanFactory，它继承自BeanPostProcessor，用于处理后续生成的Bean对象，其实看名字就知道，这玩意就是为了处理@Autowire、@Value这种注解，用于自动注入
注册传入的配置类 - register
  
    
  


1
2
3
4
5
6
7
8
9


@Override
public void register(Class&lt;?&gt;... componentClasses) {
        Assert.notEmpty(componentClasses, &#34;At least one component class must be specified&#34;);
        StartupStep registerComponentClass = this.getApplicationStartup().start(&#34;spring.context.component-classes.register&#34;)
                .tag(&#34;classes&#34;, () -&gt; Arrays.toString(componentClasses));
      //使用我们上面创建的Reader注册配置类
        this.reader.register(componentClasses);
        registerComponentClass.end();
}

[Refresh](#AbstractApplicationContext Refresh &ldquo;wikilink&rdquo;)
  
    
  
==TODO==
  
    
  

☒ Spring AOP
☐ 注解运行逻辑

@Component与@Bean的区别
JavaSSM#^473168
☐ @Bean 在处理属性注入时？


☒ AnnotationConfigApplicationContext - 与 配置类的关系 - 具体例子
☐ BeanDefinitionReader和BeanDefinitionRegistry
☐ 完善调用链图
配置类的注册 - ConfigurationClassPostProcessor
  
    
  


ConfigurationClassPostProcessor继承自BeanDefinitionRegistryPostProcessor -&gt; BeanFactoryPostProcessor，这个后置处理器是Spring中提供的，这是专门用于处理配置类的后置处理器，其中ImportBeanDefinitionRegistrar，还有ImportSelector都是靠它来处理
ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry
  
    
  
内部调用 processConfigBeanDefinitions(BeanDefinitionRegistry) 方法


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50


public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
    // 将Spring认为可能是配置类的候选类加入candidates，例如@Configuration、@Component
    // @ComponentScan、@Import，以及通过实现ImportSelector或ImportBeanDefinitionRegistrar间接引入的配置
    List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
    // 直接取出所有已注册Bean的名称
    String[] candidateNames = registry.getBeanDefinitionNames();
    for (String beanName : candidateNames) {
       // 依次拿到对应的Bean定义，然后进行判断
       BeanDefinition beanDef = registry.getBeanDefinition(beanName);
       if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) {
          ...
       }
       // 检查一个Bean定义是否符合作为配置类的条件，即使它没有直接使用@Configuration注解
       else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
          configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
       }
    }
    // 如果一个打了 @Configuration 的类都没发现，直接返回
    if (configCandidates.isEmpty()) {
       return;
    }
    // 对所有的配置类依据 @Order 进行排序
    configCandidates.sort((bd1, bd2) -&gt; {
       int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
       int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
       return Integer.compare(i1, i2);
    });
    ...
    // 这里使用do-while语句依次解析所有的配置类
    ConfigurationClassParser parser = new ConfigurationClassParser(
          this.metadataReaderFactory, this.problemReporter, this.environment,
          this.resourceLoader, this.componentScanBeanNameGenerator, registry);
    Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
    Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
    do {
       StartupStep processConfig = this.applicationStartup.start(&#34;spring.context.config-classes.parse&#34;);
       //这里就会通过Parser解析配置类中大部分内容，包括我们之前遇到的@Import注解
             parser.parse(candidates);
             parser.validate();
       //解析完成后读取到所有的配置类
       Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
             configClasses.removeAll(alreadyParsed);
       ... 
       //将上面读取的配置类加载为Bean
       this.reader.loadBeanDefinitions(configClasses);
       ...
    }
    while (!candidates.isEmpty());
    ...
}

ConfigurationClassParser#parse(candidates)
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25


public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) {
    for (BeanDefinitionHolder holder : configCandidates) {
        BeanDefinition bd = holder.getBeanDefinition();
        try {
            if (bd instanceof AnnotatedBeanDefinition annotatedBeanDef) {
                parse(annotatedBeanDef, holder.getBeanName());
            }
            else if (bd instanceof AbstractBeanDefinition abstractBeanDef &amp;&amp; abstractBeanDef.hasBeanClass()) {
                parse(abstractBeanDef.getBeanClass(), holder.getBeanName());
            }
            else {
                parse(bd.getBeanClassName(), holder.getBeanName());
            }
        }
        catch (BeanDefinitionStoreException ex) {
            throw ex;
        }
        catch (Throwable ex) {
            throw new BeanDefinitionStoreException(
                    &#34;Failed to parse configuration class [&#34; &#43; bd.getBeanClassName() &#43; &#34;]&#34;, ex);
        }
    }

    this.deferredImportSelectorHandler.process();
}

内部遍历candidates中的每一个BeanDefinitionHolder，调用parse的多态方法，最终调用ConfigurationClassParser#processConfigurationClass，最后调用deferredImportSelectorHandler.process()处理DeferredImportSelector相关的Bean注册 ^processConfigurationClass
首先判断条件注释，即处理@Conditional相关注解
然后将不同来源的配置类源信息通过asSourceClass进行封装，交给最核心的调用[doProcessConfigurationClass](#ConfigurationClassParser doProcessConfigurationClass &ldquo;wikilink&rdquo;)

将配置类ConfigurationClass实例化为SourceClass。这样做的目的是为了让后续的处理逻辑能够通过SourceClass访问到配置类中定义的所有相关信息（比如注解信息，Meta-info），并进行相应的处理。例如，通过SourceClass可以读取配置类上的@ComponentScan注解，并执行组件扫描；读取@Import注解，并处理导入的配置类或组件；读取@Bean方法，并注册对应的Bean定义等。

ConfigurationClassParser#doProcessConfigurationClass
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98


@Nullable
protected final SourceClass doProcessConfigurationClass(
        ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter)
        throws IOException {

    if (configClass.getMetadata().isAnnotated(Component.class.getName())) {
        // Recursively process any member (nested) classes first
        processMemberClasses(configClass, sourceClass, filter);
    }

    // Process any @PropertySource annotations
    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
            sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class,
            PropertySources.class, true)) {
        if (this.propertySourceRegistry != null) {
            this.propertySourceRegistry.processPropertySource(propertySource);
        }
        else {
            logger.info(&#34;Ignoring @PropertySource annotation on [&#34; &#43; sourceClass.getMetadata().getClassName() &#43;
                    &#34;]. Reason: Environment must implement ConfigurableEnvironment&#34;);
        }
    }

    // Search for locally declared @ComponentScan annotations first.
    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
            sourceClass.getMetadata(), ComponentScan.class, ComponentScans.class,
            MergedAnnotation::isDirectlyPresent);

    // Fall back to searching for @ComponentScan meta-annotations (which indirectly
    // includes locally declared composed annotations).
    if (componentScans.isEmpty()) {
        componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(),
                ComponentScan.class, ComponentScans.class, MergedAnnotation::isMetaPresent);
    }

    if (!componentScans.isEmpty()) {
        List&lt;Condition&gt; registerBeanConditions = collectRegisterBeanConditions(configClass);
        if (!registerBeanConditions.isEmpty()) {
            throw new ApplicationContextException(
                    &#34;Component scan could not be used with conditions in REGISTER_BEAN phase: &#34; &#43; registerBeanConditions);
        }
        for (AnnotationAttributes componentScan : componentScans) {
            // The config class is annotated with @ComponentScan -&gt; perform the scan immediately
            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
                    this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
            // Check the set of scanned definitions for any further config classes and parse recursively if needed
            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                if (bdCand == null) {
                    bdCand = holder.getBeanDefinition();
                }
                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
                    parse(bdCand.getBeanClassName(), holder.getBeanName());
                }
            }
        }
    }

    // Process any @Import annotations
    processImports(configClass, sourceClass, getImports(sourceClass), filter, true);

    // Process any @ImportResource annotations
    AnnotationAttributes importResource =
            AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
    if (importResource != null) {
        String[] resources = importResource.getStringArray(&#34;locations&#34;);
        Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&#34;reader&#34;);
        for (String resource : resources) {
            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
            configClass.addImportedResource(resolvedResource, readerClass);
        }
    }

    // Process individual @Bean methods
    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
    for (MethodMetadata methodMetadata : beanMethods) {
        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
    }

    // Process default methods on interfaces
    processInterfaces(configClass, sourceClass);

    // Process superclass, if any
    if (sourceClass.getMetadata().hasSuperClass()) {
        String superclass = sourceClass.getMetadata().getSuperClassName();
        if (superclass != null &amp;&amp; !superclass.startsWith(&#34;java&#34;)) {
            boolean superclassKnown = this.knownSuperclasses.containsKey(superclass);
            this.knownSuperclasses.add(superclass, configClass);
            if (!superclassKnown) {
                // Superclass found, return its annotation metadata and recurse
                return sourceClass.getSuperClass();
            }
        }
    }

    // No superclass -&gt; processing is complete
    return null;
}

该函数依次解决如下问题：

处理@Component注解
处理@PropertySource和@PropertySources注解
处理@ComponentScan和@ComponentScans
处理@Import注解
处理@ImportResource注解
处理@Bean注解的方法
处理接口上的默认方法和超类

其中的核心是处理@Import注解，通过调用 [ConfigurationClassParser#processImports](#ConfigurationClassParser processImports &ldquo;wikilink&rdquo;)
ConfigurationClassParser#processImports
  
    
  
注意其第三个入参Collection&lt;SourceClass&gt; importCandidates，它是通过调用getImports(sourceClass)方法，从给定的sourceClass中提取所有@Import注解指定的类，如果sourceClass是普通的配置类，直接通过isEmpty()返回


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63


private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
        Collection&lt;SourceClass&gt; importCandidates, Predicate&lt;String&gt; filter, boolean checkForCircularImports) {

    if (importCandidates.isEmpty()) {
        return;
    }

    if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) {
        this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
    }
    else {
        this.importStack.push(configClass);
        try {
            for (SourceClass candidate : importCandidates) {
                if (candidate.isAssignable(ImportSelector.class)) {
                    // Candidate class is an ImportSelector -&gt; delegate to it to determine imports
                    Class&lt;?&gt; candidateClass = candidate.loadClass();
                    ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class,
                            this.environment, this.resourceLoader, this.registry);
                    Predicate&lt;String&gt; selectorFilter = selector.getExclusionFilter();
                    if (selectorFilter != null) {
                        filter = filter.or(selectorFilter);
                    }
                    if (selector instanceof DeferredImportSelector deferredImportSelector) {
                        this.deferredImportSelectorHandler.handle(configClass, deferredImportSelector);
                    }
                    else {
                        String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                        Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames, filter);
                        processImports(configClass, currentSourceClass, importSourceClasses, filter, false);
                    }
                }
                else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
                    // Candidate class is an ImportBeanDefinitionRegistrar -&gt;
                    // delegate to it to register additional bean definitions
                    Class&lt;?&gt; candidateClass = candidate.loadClass();
                    ImportBeanDefinitionRegistrar registrar =
                            ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class,
                                    this.environment, this.resourceLoader, this.registry);
                    configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
                }
                else {
                    // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;
                    // process it as an @Configuration class
                    this.importStack.registerImport(
                            currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
                    processConfigurationClass(candidate.asConfigClass(configClass), filter);
                }
            }
        }
        catch (BeanDefinitionStoreException ex) {
            throw ex;
        }
        catch (Throwable ex) {
            throw new BeanDefinitionStoreException(
                    &#34;Failed to process import candidates for configuration class [&#34; &#43;
                    configClass.getMetadata().getClassName() &#43; &#34;]: &#34; &#43; ex.getMessage(), ex);
        }
        finally {
            this.importStack.pop();
        }
    }
}

代码遍历每一个@Import注解指定的候选类，根据不同类型进行处理

ImportSelector实现
ImportSelector
DeferredImportSelector
ImportBeanDefinitionRegistar实现
普通的配置类

针对ImportSelector
  
    
  
通过selector.selectImports()与asSourceClasses()方法将需要导入的类重新封装为SourceClass，递归调用processImports
针对DeferredImportSelector
  
    
  
通过调用ConfigurationClassParser的内部类DeferredImportSelectorHandler#handle()方法，将其封装为DeferredImportSelectorHolder ，加入待处理的List - deferredImportSelectors
在ConfigurationClassParser#parse[处理完所有候选配置类后](#ConfigurationClassParser parse(candidates) &ldquo;wikilink&rdquo;)，调用DeferredImportSelectorHandler#process()方法，该方法将加入deferredImportSelectors中的所有DeferredImportSelectorHolder执行内部类的DeferredImportSelectorGroupingHandler#register方法，得到包装好的、已经分组完毕的DeferredImportSelectorGrouping，然后调用DeferredImportSelectorGroupingHandler#processGroupImports()，处理组内所有的延迟导入 (DeferredImportSelector)
DeferredImportSelectorGroupingHandler#register
  
    
  


1
2
3
4
5
6
7
8
9


void register(DeferredImportSelectorHolder deferredImport) {
            Class&lt;? extends Group&gt; group = deferredImport.getImportSelector().getImportGroup();
            DeferredImportSelectorGrouping grouping = this.groupings.computeIfAbsent(
                    (group != null ? group : deferredImport),
                    key -&gt; new DeferredImportSelectorGrouping(createGroup(group)));
            grouping.add(deferredImport);
            this.configurationClasses.put(deferredImport.getConfigurationClass().getMetadata(),
                    deferredImport.getConfigurationClass());
        }


首先尝试获取DeferredImportSelector指定的导入组 (ImportGroup)，如果没有指定特定的导入组，则使用DeferredImportSelector本身作为组的Key
尝试从一个名为groupings的映射中获取或创建一个与导入组对应的DeferredImportSelectorGrouping对象。如果映射中尚未存在与当前组对应的分组，那么将创建一个新的分组，并将其加入到映射中

注意，此处的Group逻辑是将DeferredImportSelector.Group这个内部接口包装到ConfigurationClassParser.DeferredImportSelectorGourping这个内部类中，其内部维护了一个DeferredImportSelector.Group对象和List&lt;DeferredImportSelectorHolder&gt;对象


调用DeferredImportSelectGrouping#add(DeferredImportSelectorHolder)，将DeferredImportSelectorHolder加入内部类维护的Grouping中 (静态类)
最后，代码将当前DeferredImportSelectorHolder对应的配置类(ConfigurationClass)及其元数据添加到一个名为configurationClasses的映射中。这确保了后续能够快速访问到与特定DeferredImportSelector相关联的配置类

DeferredImportSelectorGroupingHandler#processGroupImports
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21


void processGroupImports() {
    for (DeferredImportSelectorGrouping grouping : this.groupings.values()) {
        Predicate&lt;String&gt; filter = grouping.getCandidateFilter();
        grouping.getImports().forEach(entry -&gt; {
            ConfigurationClass configurationClass = this.configurationClasses.get(entry.getMetadata());
            try {
                processImports(configurationClass, asSourceClass(configurationClass, filter),
                        Collections.singleton(asSourceClass(entry.getImportClassName(), filter)),
                        filter, false);
            }
            catch (BeanDefinitionStoreException ex) {
                throw ex;
            }
            catch (Throwable ex) {
                throw new BeanDefinitionStoreException(
                        &#34;Failed to process import candidates for configuration class [&#34; &#43;
                                configurationClass.getMetadata().getClassName() &#43; &#34;]&#34;, ex);
            }
        });
    }
}


遍历保存在Groups - DeferredImportSelectorGroupingHandler中的 DeferredImportSelectorGroup对象，调用 DeferredImportSelectorGroup#getImports()方法
DeferredImportSelectorGroup#getImports()方法调用DeferredImportSelectorGroup中维护的真实的Group - DeferredImportSelector.Group#process方法，然后返回含有meta-info的Entry
使用内部维护的Map(在register中put)，根据Entry.meta-info得到对应的ConfigurationClass ，调用ConfigurationClassParser#processImports，和[前面](#ConfigurationClassParser processImports &ldquo;wikilink&rdquo;)一样递归调用进行处理

所以根据以上分析，DeferredImportSelector最终的处理逻辑在于DeferredImportSelector.Group#process() ^db8805
针对ImportBeanDefinitionRegistar
  
    
  


1
2
3
4
5
6
7
8


public interface ImportBeanDefinitionRegistrar {  
    default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator) {  
        this.registerBeanDefinitions(importingClassMetadata, registry);  
    }  
  
    default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {  
    }  
}

调用ConfigurationClass#addImportBeanDefinitionRegistrar方法，将对应的实例加入configClass对应的Collection类中，后续在[loadBeanDefinitions](#ConfigurationClassBeanDefinitionReader loadBeanDefinitions &ldquo;wikilink&rdquo;)中调用其registerBeanDefinitions，注册相应的BeanDefinition
针对普通配置类
  
    
  
不使用特殊机制，直接递归调用processConfigurationClass
ConfigurationClassParser#getConfigurationClasses
  
    
  
返回从前面得到的所有待配置的配置类
ConfigurationClassBeanDefinitionReader#loadBeanDefinitions
  
    
  
^98f726


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33


public void loadBeanDefinitions(Set&lt;ConfigurationClass&gt; configurationModel) {
        TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator();
        for (ConfigurationClass configClass : configurationModel) {
            loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
        }
    }

/**
 * Read a particular {@link ConfigurationClass}, registering bean definitions
 * for the class itself and all of its {@link Bean} methods.
 */
private void loadBeanDefinitionsForConfigurationClass(
        ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {

    if (trackedConditionEvaluator.shouldSkip(configClass)) {
        String beanName = configClass.getBeanName();
        if (StringUtils.hasLength(beanName) &amp;&amp; this.registry.containsBeanDefinition(beanName)) {
            this.registry.removeBeanDefinition(beanName);
        }
        this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());
        return;
    }

    if (configClass.isImported()) {
        registerBeanDefinitionForImportedConfigurationClass(configClass);
    }
    for (BeanMethod beanMethod : configClass.getBeanMethods()) {
        loadBeanDefinitionsForBeanMethod(beanMethod);
    }

    loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
    loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
}

通过遍历每一个配置类，调用loadBeanDefinitionsForConfigurationClass方法 ^f6a27a

registerBeanDefinitionForImportedConfigurationClass(configClass)
注册配置类自身
loadBeanDefinitionsForBeanMethod(beanMethod)
注册@Bean注解标识的方法
loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
注册@ImportResource引入的XML配置文件中读取的bean定义
loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
注册configClass中经过解析后保存的所有ImportBeanDefinitionRegistrar，注册对应的BeanDefinition

AOP
  
    
  
AOP的实现类是AnnotationAwareAspectJAutoProxyCreator，其是BeanPostProcessor的实现类，具体来说，是InstantiationAwareBeanPostProcessor的实现类，在实例化Bean过程中，通过调用BeanPostProcessor中的实例化前处理器进行短路，得到相应的代理Bean
@EnableAspectJAutoProxy
  
    
  


1
2
3
4
5
6
7
8


@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import({AspectJAutoProxyRegistrar.class})
public @interface EnableAspectJAutoProxy {
    boolean proxyTargetClass() default false;
    boolean exposeProxy() default false;
}

这个注解使用@Import导入了AspectJAutoProxyRegistrar，其是ImportBeanDefinitionRegistrar的实现类，会在处理配置类相应@Import机制的时候将AnnotationAwareAspectJAutoProxyCreator实现类注册到容器中，即注册到BeanDefinition中，实现相应的实例化前处理器功能 (InstantiationAwareBeanPostProcessor)">
  <meta itemprop="datePublished" content="2024-05-13T11:26:20+08:00">
  <meta itemprop="dateModified" content="2024-05-13T11:26:20+08:00">
  <meta itemprop="wordCount" content="26674">
  <meta itemprop="keywords" content="Java,Spring"><meta property="og:url" content="http://localhost:1313/posts/6e2a775/">
  <meta property="og:site_name" content="Dionysun&#39;s Blog">
  <meta property="og:title" content="Spring 主要源码分析">
  <meta property="og:description" content="Bean的生命周期为：BeanFactory初始化 - Bean注册 - 实例化 - 属性注入 - 初始化 - 后处理
Bean的注册扫描：Spring通过配置（XML配置或Java配置）或自动扫描（@ComponentScan）来发现应用中定义的Bean。对于自动扫描，Spring会在指定的包路径下查找标注了@Component、@Service、@Repository、@Controller等注解的类 解析：一旦Bean被发现，Spring将解析Bean的定义信息，包括Bean的作用域（如单例、原型）、生命周期回调（如@PostConstruct、@PreDestroy注解方法）、依赖注入的需求（通过@Autowired、@Resource等注解标记）等 —— BeanDefinition 注册：Spring将Bean的定义信息注册到BeanDefinitionRegistry中。这是一个重要步骤，因为注册后的Bean定义将被用于后续的Bean实例化和依赖注入过程。此时，Bean还没有被实例化。 BeanDefinitionBeanDefinitionSpring在初始化过程中，先收集所有bean的元数据信息并注册，bean的元数据描述为接口BeanDefinition，该接口定义了你能想到的一切有关bean的属性信息
BeanDefinition衍生出一系列实现类
AbstractBeanDefinition: 如同其他Spring类，大部分BeanDefinition接口的逻辑都由该抽象类实现 GenericBeanDefinition: 是一站式、用户可见的bean definition；可见的bean definition意味着可以在该bean definition上定义post-processor来对bean进行操作 RootBeanDefinition: 当bean definition存在父子关系的时候，RootBeanDefinition用来承载父元数据的角色（也可独立存在），同时它也作为一个可合并的bean definition使用，在Spring初始化阶段，所有的bean definition均会被（向父级）合并为RootBeanDefinition，子bean definition（GenericBeanDefinition/ChildBeanDefinition）中的定义会覆盖其父bean definition（由parentName指定）的定义 AnnotatedBeanDefinition: 用来定义注解Bean Definition BeanDefinitionHolder只是简单捆绑了BeanDefinition、bean-name、bean-alias，用于注册BeanDefinition及别名alias ^BeanDefinitionHolder
BeanRegistryBean的注册逻辑分为两步，一为BeanDefinition的注册，二为别名的注册
BeanDefinition注册的定义在BeanDefinitionRegistry#registerBeanDefinition，其实现使用一个Map&lt;String, BeanDefinition&gt; 来保存bean-name和BeanDefinition的关系 别名的注册定义在AliasRegistry#registerAlias，其实现同样使用一个Map&lt;String, String&gt; 来保存别名alias-name和bean-name（或另一个别名alias-name）的关系 注意Bean的注册时机，通常应该在应用上下文的刷新过程之前进行(onRefresh())。一旦上下文被刷新，对Bean定义的任何修改可能不会被识别，或者可能会导致不一致的状态
Bean的实例化BigMapBeanFactory几个核心接口：
AliasRegistry bean别名注册和管理 BeanDefinitionRegistry bean元数据注册和管理 SingletonBeanRegistry 单例bean注册和管理 BeanFactory bean工厂，提供各种bean的获取及判断方法 通过上述的类依赖图，对于Bean的实例化，核心实现是在DefaultListableBeanFactory
DefaultListableBeanFactory - AbstractBeanFactorybean的实例化过程发生在getBean调用阶段（对于singleton则发生在首次调用阶段），getBean的实现方法众多，我们追根溯源，找到最通用的方法AbstractBeanFactory#doGetBean
doGetBean1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // org.springframework.beans.factory.support.AbstractBeanFactory protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException { // 1. 获取真正的beanName final String beanName = transformedBeanName(name); Object bean; // 2. 尝试获取(提前曝光的)singleton bean实例（为了解决循环依赖） Object sharedInstance = getSingleton(beanName); // 3. 如果存在 if (sharedInstance != null &amp;&amp; args == null) { ... } // 4. 如果不存在 else { ... } // 5. 尝试类型转换 if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) { ... } return (T) bean; } doGetBeanBean Name的转换在使用bean-name获取bean的时候，除了可以使用原始bean-name之外，还可以使用alias别名等，bean-name的转换则是将传入的’bean-name’一层层转为最原始的bean-name
函数canonicalName的作用则是利用别名注册aliasMap，将别名alias转为原始bean-name 函数transformedBeanName比较特殊，其是将FactoryBean的bean-name前缀 ‘&amp;’ 去除 尝试获取单例拿到原始的bean-name之后，便可以实例化bean或者直接获取已经实例化的singleton-bean
在获取singleton-bean的时候一般存在三种情况：1. 还未实例化(或者不是单例)；2. 已经实例化；3. 正在实例化；
对于 “1. 还未实例化” ，返回null即可，后续进行实例化动作 对于 “2. 已经实例化”，直接返回实例化的singleton-bean 对于 “3. 正在实例化”，会存在循环依赖问题 Spring中对于singleton-bean，有一个sharedInstance的概念，在调用getSingleton函数时，返回的不一定是完全实例化的singleton-bean，有可能是一个中间状态（创建完成，但未进行属性依赖注入及其他后处理逻辑），这种中间状态会通过getSingleton函数提前曝光出来，目的是为了解决循环依赖
因此，Spring通过提供三层缓存来解决循环依赖问题，并且可以通过这种机制实现诸多的PostProcessor增强Bean，例如AOP
singletonObjects 缓存已经实例化完成的singleton-bean earlySingletonObjects 缓存正在实例化的、提前曝光的singleton-bean，用于处理循环依赖
singletonFactories 缓存用于生成earlySingletonObject的 ObjectFactory
ObjectFactory，定义了一个用于创建、生成对象实例的工厂方法
1 2 3 4 @FunctionalInterface public interface ObjectFactory&lt;T&gt; { T getObject() throws BeansException; } 因此getSingleton的逻辑如下： NOTE: 在提前暴露实体中，将相应的ObjectFactory放入了singletonFactories
FactoryBean的处理(sharedInstance存在的逻辑)==sharedInstance不一定是我们所需要的bean实例==
例如，我们在定义Bean的时候可以通过实现FactoryBean接口来定制bean实例化的逻辑(实现FactoryBean)，通过注册FactoryBean类型的Bean，实例化后的原始实例类型同样为FactoryBean，但我们需要的是通过FactoryBean#getObject方法得到的实例，这需要针对FactoryBean做一些处理，即AbstractBeanFactory#getObjectForBeanInstance
Get the object for the given bean instance, either the bean instance itself or its created object in case of a FactoryBean. Now we have the bean instance, which may be a normal bean or a FactoryBean. If it’s a FactoryBean, we use it to create a bean instance.
该函数要实现的逻辑比较简单，如果sharedInstance是 FactoryBean，则使用getObject方法创建真正的实例
getObjectForBeanInstance是一个通用函数，并不只针对通过getSingleton得到的sharedInstance，任何通过缓存或者创建得到的 rawInstance，都需要经过getObjectForBeanInstance处理，拿到真正需要的 beanInstance
1 2 3 4 5 6 7 8 /** * @param beanInstance sharedInstance / rawInstance，可能为FactoryBean * @param name 传入的未做转换的 bean name * @param beanName 对name做过转换后的原始 canonical bean name * @param mbd 合并后的RootBeanDefinition，下文会介绍 */ protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, RootBeanDefinition mbd) getObjectBeanInstancegetObjectForBeanInstance在这个判断逻辑中，如果入参name以’&amp;‘开头则直接返回，这里兼容了一种情况，如果需要获取/注入FactoryBean而不是getObject生成的实例，则需要在bean-name/alias-name前加入&#39;&amp;&#39;
对于singleton，FactoryBean#getObject的结果会被缓存到factoryBeanObjectCache，对于缓存中不存在或者不是singleton的情况，会通过FactoryBean#getObject生成 ^factorybeangetobject
FactoryBeanRegistrySupport#getObjectFromFactoryBean1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) { if (factory.isSingleton() &amp;&amp; this.containsSingleton(beanName)) { synchronized(this.getSingletonMutex()) { Object object = this.factoryBeanObjectCache.get(beanName); if (object == null) { object = this.doGetObjectFromFactoryBean(factory, beanName); Object alreadyThere = this.factoryBeanObjectCache.get(beanName); if (alreadyThere != null) { object = alreadyThere; } else { if (shouldPostProcess) { if (this.isSingletonCurrentlyInCreation(beanName)) { return object; } this.beforeSingletonCreation(beanName); try { object = this.postProcessObjectFromFactoryBean(object, beanName); } catch (Throwable var14) { throw new BeanCreationException(beanName, &#34;Post-processing of FactoryBean&#39;s singleton object failed&#34;, var14); } finally { this.afterSingletonCreation(beanName); } } if (this.containsSingleton(beanName)) { this.factoryBeanObjectCache.put(beanName, object); } } } return object; } } else { Object object = this.doGetObjectFromFactoryBean(factory, beanName); if (shouldPostProcess) { try { object = this.postProcessObjectFromFactoryBean(object, beanName); } catch (Throwable var17) { throw new BeanCreationException(beanName, &#34;Post-processing of FactoryBean&#39;s object failed&#34;, var17); } } return object; } } 对于Singleton:
首先从缓存中尝试获取，如获取失败，调用[doGetObjectFromFactoryBean](#FactoryBeanRegistrySupport doGetObjectFromFactoryBean “wikilink”)，其中内核是调用FactoryBean#getObject()方法 对于需要后处理的Bean，首先判断是否处于正在创建状态(isSingletonCurrentlyInCreation)，并且通过this.beforeSingletonCreate() this.afterSingletonCreation()将实际的BeanPostProcessor过程保护 对于BeanPostProcessor，调用this.postProcessObjectFromFactoryBean，其具体实现在[AbstractAutowireCapableBeanFactory#applyBeanPostProcessorAfterInitialization](#AbstractAutowireCapableBeanFactory applyBeanPostProcessorAfterInitialization “wikilink”) FactoryBeanRegistrySupport#doGetObjectFromFactoryBeanFactoryBeanRegistrySupport_doGetObjectFromFactoryBeanAbstractAutowireCapableBeanFactory#applyBeanPostProcessorAfterInitializationpostProcessAfterInitialization函数可以对现有bean instance做进一步的处理，甚至可以返回新的bean instance，这就为bean的增强提供了一个非常方便的扩展方式
加载Bean实例 (sharedInstance不存在的逻辑)createBeanInstanceBean的加载/创建分为三大部分
将BeanDefinition合并为RootBeanDefinition，类似类继承，子BeanDefinition属性会覆盖父BeanDefinition 依次加载所依赖的bean，对于有依赖的情况，优先递归加载依赖的bean 按照不同的bean类型，根据BeanDefinition的定义进行加载/创建 BeanDefinition合并 (RootBeanDefinition)在AbstractBeanFactory#getMergedLocalBeanDefinition中执行核心逻辑
加载dependes-On beans1 2 3 4 5 6 7 8 9 10 11 12 13 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) { // 遍历所有的依赖 for (String dep : dependsOn) { // 检测循环依赖 if (isDependent(beanName, dep)) { /* throw exception */ } // 注册依赖关系 registerDependentBean(dep, beanName); // 递归getBean，加载依赖bean try { getBean(dep); } catch (NoSuchBeanDefinitionException ex) { /* throw exception */ } } } 该过程中涉及两个中间态
dependentBeanMap 存储哪些bean依赖了我（哪些bean里注入了我） 如果 beanB -&gt; beanA, beanC -&gt; beanA，key为beanA，value为[beanB, beanC] dependenciesForBeanMap 存储我依赖了哪些bean（我注入了哪些bean） 如果 beanA -&gt; beanB, beanA -&gt; beanC，key为beanA，value为[beanB, beanC] 加载singleton bean实例1 2 3 4 5 6 7 8 if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, () -&gt; { // singletonFactory - ObjectFactory try { return createBean(beanName, mbd, args); } catch (BeansException ex) { destroySingleton(beanName); throw ex; } }); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } 其中核心为createBean与getObjectForBeanInstance
createBean 根据BeanDefinition的内容，创建/初始化 bean instance #getObjectBeanInstance 主要处理FactoryBean createBean被包装在lambda(singletonFactory)，重写ObjectFactory#getObject()，作为[getSingleton](#DefaultSingletonBeanRegistry getSingleton(String, ObjectFactory) “wikilink”)的参数
DefaultSingletonBeanRegistry#getSingleton(String, ObjectFactory)createSingletonBean同样的，会先在缓存中查找该singleton，如果不存在，创建的核心逻辑在于[createBean](#AbstractAutowireCapableBeanFactory createBean “wikilink”)
AbstractAutowireCapableBeanFactory#createBeancreateBeanresolveBeanClass 这一步骤用于锁定bean class，在没有显示指定beanClass的情况下，使用className加载beanClass 验证method overrides ==在BeanDefinitionReader 中有提到过lookup-method及replace-method，该步骤是为了确认以上两种配置中的method是否存在== 执行InstantiationAwareBeanPostProcessor前处理器(postProcessBeforeInstantiation) 如果这个步骤中生成了&#34;代理&#34;bean instance，则会有一个短路操作，直接返回该bean instance而不再执行doCreate，其中的核心逻辑为调用this.applyBeanPostProcessorsBeforeInstantiation() ^fcb215 1 2 3 4 5 6 7 8 9 10 11 12 13 14 try { // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) { // 如果这里生成了代理的bean instance会直接返回 return bean; } } cache (Throwable ex) { // throw exception } try { // 创建bean instance Object beanInstance = doCreateBean(beanName, mbdToUse, args); // ... } doCreateBean (AbstractAutowireCapableBeanFactory) 真正bean的创建及初始化过程在此处实现 doCreateBean1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName); } if (instanceWrapper == null) { instanceWrapper = this.createBeanInstance(beanName, mbd, args); } Object bean = instanceWrapper.getWrappedInstance(); Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) { mbd.resolvedTargetType = beanType; } synchronized(mbd.postProcessingLock) { if (!mbd.postProcessed) { try { this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); } catch (Throwable var17) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &#34;Post-processing of merged bean definition failed&#34;, var17); } mbd.markAsPostProcessed(); } } boolean earlySingletonExposure = mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; this.isSingletonCurrentlyInCreation(beanName); if (earlySingletonExposure) { if (this.logger.isTraceEnabled()) { this.logger.trace(&#34;Eagerly caching bean &#39;&#34; &#43; beanName &#43; &#34;&#39; to allow for resolving potential circular references&#34;); } this.addSingletonFactory(beanName, () -&gt; { return this.getEarlyBeanReference(beanName, mbd, bean); }); } Object exposedObject = bean; try { this.populateBean(beanName, mbd, instanceWrapper); exposedObject = this.initializeBean(beanName, exposedObject, mbd); } catch (Throwable var18) { if (var18 instanceof BeanCreationException bce) { if (beanName.equals(bce.getBeanName())) { throw bce; } } throw new BeanCreationException(mbd.getResourceDescription(), beanName, var18.getMessage(), var18); } if (earlySingletonExposure) { Object earlySingletonReference = this.getSingleton(beanName, false); if (earlySingletonReference != null) { if (exposedObject == bean) { exposedObject = earlySingletonReference; } else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; this.hasDependentBean(beanName)) { String[] dependentBeans = this.getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet(dependentBeans.length); String[] var12 = dependentBeans; int var13 = dependentBeans.length; for(int var14 = 0; var14 &lt; var13; &#43;&#43;var14) { String dependentBean = var12[var14]; if (!this.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, &#34;Bean with name &#39;&#34; &#43; beanName &#43; &#34;&#39; has been injected into other beans [&#34; &#43; StringUtils.collectionToCommaDelimitedString(actualDependentBeans) &#43; &#34;] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using &#39;getBeanNamesForType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&#34;); } } } } try { this.registerDisposableBeanIfNecessary(beanName, bean, mbd); return exposedObject; } catch (BeanDefinitionValidationException var16) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &#34;Invalid destruction signature&#34;, var16); } } 可以将该流程细分为如下：
[创建Bean实体](#创建Bean实体 AbstractAutowireCapableBeanFactory createBeanInstance “wikilink”) [BeanDefinition后处理](#BeanDefinition后处理 - AbstractAutowireCapableBeanFactory applyMergedBeanDefinitionPostProcessors “wikilink”) 提前暴露实体 [属性注入](#属性注入 - AbstractAutowireCapableBeanFactory populateBean “wikilink”) [初始化](#初始化 - AbstractAutowireCapableBeanFactory initializeBean “wikilink”) [注册Disposable](#注册Disposable - AbstractBeanFactory registerDisposableBeanIfNecessary “wikilink”) 创建Bean实体 - AbstractAutowireCapableBeanFactory#createBeanInstancecreateBeanInstance_2instanceSupplier 从上面的流程图可以看出，创建bean实体不一定会使用到构造函数，可以使用Supplier的方式 factory method 工厂模式 @Configuration &#43; @Bean的实现方式就是factory-bean &#43; factory-method [对应的参数获取](#ConstructorResolver resolvePreparedArguments “wikilink”) 有参构造函数 AbstractAutowireCapableBeanFactory#autowireConstructor -&gt; [ConstructorResolver#autowireConstructor](#**ConstructorResolver autowireConstructor** “wikilink”) 无参构造函数 与有参构造创建过程一致，除了不需要参数的依赖注入，使用默认无参构造函数进行实例化 ConstructorResolver#resolvePreparedArguments使用指定（类）bean的（静态）方法创建bean实体的逻辑在ConstructorResolver#instantiate(String, RootBeanDefinition, Object, Method, args)，而真正的逻辑在SimpleInstantiationStrategy#instantiate(RootBeanDefinition, String, BeanFactory, Object, Method, Object…)，其核心的执行逻辑非常简单，有了方法factoryMethod(factoryBean)及入参args，便可以调用该方法创建bean实体
1 Object result = factoryMethod.invoke(factoryBean, args); factoryBean可以通过beanFactory.getBean获取到（正是当前在讲的逻辑），factoryMethod可以通过反射获取到，而入参args就从ConstructorResolver#resolvePreparedArguments中获取，即是Spring中依赖注入的核心实现
该函数的作用是将BeanDefinition中定义的入参转换为需要的参数(==将BeanDefinitionReader中封装的对象转换==)
resolvePreparedArgumentsMore in blogs
ConstructorResolver#autowireConstructor同样的，调用ConstructorResolver#resolvePreparedArguments进行参数的解析和转换(参数的依赖注入)，然后调用 [ConstructorResolver#instantiate](#ConstructorResolver instantiate “wikilink”) 来创建Bean实例
ConstructorResolver#instantiate内部并没有统一利用反射技术直接使用构造函数创建，而是通过InstantiationStrategy.instantiate进行创建
Instantiate没有设置override-method时，直接使用构造函数创建 设置了override-method时，使用cglib技术构造代理类，并代理override方法 Spring默认的实例化策略为CglibSubclassingInstantiationStrategy
BeanDefinition后处理 - AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors在属性注入之前提供一次机会来对BeanDefinition进行处理，内部执行所有注册MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition方法
[!hint] MergedBeanDefinitionPostProcessor MergedBeanDefinitionPostProcessor 是一个特定类型的 BeanPostProcessor。MergedBeanDefinitionPostProcessor 的 postProcessMergedBeanDefinition 方法允许在实例化bean之后但在设置bean属性之前，对bean的定义（BeanDefinition）进行后处理。这个阶段是用于修改或增强bean定义的，例如，可以解析注解并相应地修改 BeanDefinition 的属性。
对于MergedBeanDefinitionPostProcessor的实现类AutowiredAnnotationBeanPostProcessor，其内部方法AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata 实现了两个注解类的解析 @Value 及 @Autowired ，找到注解修饰的Filed或者Method并缓存，具体逻辑在[属性注入](#属性注入 - AbstractAutowireCapableBeanFactory populateBean “wikilink”) ^autowiredAnnotationBeanPostProcessor1
提前暴露实体通过将AbstractAutowireCapableBeanFactory#getEarlyBeanReference封装为ObjectFactory，调用DefaultSingletonBeanRegistry#addSingletonFactory，将该ObjectFactory缓存在DefaultSingletonBeanRegistry.singletonFactories中，在getBean逻辑中的getSingleton会执行ObjectFactory将singleton提前暴露 ==此处即为何时添加ObjectFactory进入singletonFactories中，解决循环依赖==
此时暴露的singleton-bean仅完成了bean的实例化，属性注入、初始化等逻辑均暂未执行
属性注入 - AbstractAutowireCapableBeanFactory#populateBean在[创建Bean实体](#创建Bean实体 - AbstractAutowireCapableBeanFactory createBeanInstance “wikilink”)中介绍了factory method方式及有参构造函数方式的参数注入逻辑，除此之外还有一种注入便是属性注入
populateBean流程中出现了两次InstantiationAwareBeanPostProcessor，在第一次出现中调用的postProcessorAfterInstantiation也与前面的InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation相同，拥有短路操作：如果该步骤生成了&#34;代理&#34;bean instance，直接返回该bean instance而不再执行后续的doCreate；如果有任意一个InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation方法返回false，则会跳出属性注入的逻辑，官方对此的解释如下
Give any InstantiationAwareBeanPostProcessors the opportunity to modify the state of the bean before properties are set. This can be used, for example, to support styles of field injection.
autowireByName及autowireByType方法作为&#34;候补&#34;补充BeanDefinition的propertyValues
PropertyValue中记录了需要注入的属性信息及需要注入的属性值，那BeanDefinition的propertyValues都来自哪里？xml中的bean配置、自定义的BeanDefinition等
通过注解修饰的属性(方法)通过InstantiationAwareBeanPostProcessor#postProcessProperties进行注入 -&gt; ==AutowiredAnnotationBeanPostProcessor#postProcessProperties &amp; CommonAnnotationBeanPostProcessor#postProcessProperties==
最后，通过AbstractAutowireCapableBeanFactory#applyPropertyValues 将PropertyValue中记录的需要注入的属性，已经依赖的类型（String、RuntimeBeanReference、等），根据不同的类型解析依赖的bean并设置到对应的属性上（==此过程与DefaultListableBeanFactory#doResolveDependency相似==）
初始化 - AbstractAutowireCapableBeanFactory#initializeBean以上，完成了bean实例的创建和属性注入，之后还有一些初始化的方法，比如各种Aware的setXxx是如何调用的、@PostConstruct是怎么调用的？
initializeBean注册Disposable - AbstractBeanFactory#registerDisposableBeanIfNecessary至此，终于完成了bean实例的创建、属性注入以及之后的初始化，此后便可以开始使用了
在使用Spring的过程中经常还会碰到设置销毁逻辑的情况，如数据库连接池、线程池等等，在Spring销毁bean的时候还需要做一些处理，类似于C&#43;&#43;中的析构
在bean的创建逻辑中，最后一个步骤则是注册bean的销毁逻辑（DisposableBean）
销毁逻辑的注册有几个条件
非prototype（singleton或者注册的scope） 非NullBean 指定了destroy-method（如xml中指定或者BeanDefinition中直接设置）或者存在**@PreDestroy** 注解的方法（CommonAnnotationBeanPostProcessor.requiresDestruction） 1 if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) 满足以上条件的bean会被封装为DisposableBeanAdapter，并注册在DefaultSingletonBeanRegistry.disposableBeans中
加载prototype bean实例1 2 3 4 5 6 7 8 9 else if (mbd.isPrototype()) { Object prototypeInstance = null; try { beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } prototype bean的创建与singleton bean类似，只是不会缓存创建完成的bean
加载其他scope bean实例scope，即作用域，或者可以理解为生命周期
上文介绍了singleton-bean及prototype-bean的创建过程，严格意义上讲以上两种都是一种特殊的scope-bean，分别对应ConfigurableBeanFactory#SCOPE_SINGLETON及ConfigurableBeanFactory#SCOPE_PROTOTYPE，前者作用域为整个IOC容器，也可理解为单例，后者作用域为所注入的bean，每次注入(每次触发getBean)都会重新生成
Spring中还提供很多其他的scope，如WebApplicationContext#SCOPE_REQUEST或WebApplicationContext#SCOPE_SESSION，前者作用域为一次web request，后者作用域为一个web session周期
自定义scope的bean实例创建过程与singleton bean的创建过程十分相似，需要实现Scope的get方法(org.springframework.beans.factory.config.Scope#get)
1 2 3 4 5 6 7 8 9 10 11 12 13 14 else { String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) { /* throw exception */ } try { Object scopedInstance = scope.get(beanName, () -&gt; { beforePrototypeCreation(beanName); // createBean被封装在Scope#get函数的lambda参数ObjectFactory中 try { return createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } }); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); } catch (IllegalStateException ex) { /* throw exception */} } Scope接口除了get方法之外，还有一个remove方法，前者用于定义bean的初始化逻辑，后者用于定义bean的销毁逻辑
1 2 3 4 5 6 7 8 9 10 11 public interface Scope { /** * Return the object with the given name from the underlying scope */ Object get(String name, ObjectFactory&lt;?&gt; objectFactory); /** * Remove the object with the given name from the underlying scope. */ Object remove(String name); } WebApplicationContext#SCOPE_SESSION对应的Scope实现见org.springframework.web.context.request.SessionScope
WebApplicationContext#SCOPE_REQUEST对应的Scope实现见org.springframework.web.context.request.RequestScope
以上两种Scope实现都较为简单，前者将初始化的bean存储在request attribute中，后者将初始化的bean存储在http session中
尝试类型转换以上，完成了bean的创建、属性的注入、dispose逻辑的注册，但获得的bean类型与实际需要的类型可能依然不相符，在最终交付bean之前（getBean）还需要进行一次类型转换，使用PropertyEditor进行类型转换，将bean转换为真正需要的类型后，便完成了整个getBean的使命
Bean销毁过程bean的创建过程始于DefaultListableBeanFactory#getBean，销毁过程则终于ConfigurableApplicationContext#close，跟踪下去，具体的逻辑在DefaultSingletonBeanRegistry#destroySingletons
DefaultSingletonBeanRegistry.disposableBeans 需要注册销毁逻辑的bean会被封装为DisposableBeanAdapter并缓存在此处 DefaultSingletonBeanRegistry.dependentBeanMap 对于存在依赖注入关系的bean，会将bean的依赖关系缓存在此处（dependentBeanMap: 哪些bean依赖了我; dependenciesForBeanMap: 我依赖了哪些bean） destory从上图中可以看出，bean的销毁顺序与创建顺序正好相反，如果有 beanA –dependsOn–&gt; beanB –&gt; beanC ，创建（getBean）时一定是beanC -&gt; beanB -&gt; beanA，销毁时一定是 beanA -&gt; beanB -&gt; beanC，以此避免因为依赖关系造成的一些异常情况
循环依赖earlySingletonObject是用来解决循环依赖的问题，具体时机是在实例化完后属性注入之前，会提前将当前的bean实体暴露出来，以防止在属性注入过程中所注入的bean又依赖当前的bean造成的类似&#34;死锁&#34;的状态
但是存在以下情况，Spring依旧会陷入循环依赖死锁：
显式设置dependsOn的循环依赖 1 2 3 4 5 6 7 8 9 10 11 @DependsOn(&#34;beanB&#34;) @Component public class BeanA {} @DependsOn(&#34;beanC&#34;) @Component public class BeanB {} @DependsOn(&#34;beanA&#34;) @Component public class BeanC {} 构造函数循环依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Component public class BeanA { public BeanA(BeanB beanB) { } } @Component public class BeanB { public BeanB(BeanC beanC) { } } @Component public class BeanC { public BeanC(BeanA beanA) { } } factory-method循环依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Bean public BeanA beanA(BeanB beanB) { return new BeanA(); } @Bean public BeanB beanB(BeanC beanC) { return new BeanB(); } @Bean public BeanC beanC(BeanA beanA) { return new BeanC(); } 上述三种依赖混合 只要一个循环依赖中的所有bean，其依赖关系都需要在创建bean实例之前进行解决，此循环依赖则一定无解
要打破无解的循环依赖，在构成循环依赖的一个环中，只需要保证其中至少一个Bean的依赖在该Bean创建且暴露earlySingleton之后处理即可，即在属性注入阶段进行属性依赖的处理
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Component public class BeanA { @Autowired private BeanB beanB; } @Component public class BeanB { public BeanB(BeanC beanC) { } } @Bean public BeanC beanC(BeanA beanA) { return new BeanC(); } 以&#34;bean创建且暴露earlySingleton&#34;为节点，在此之前处理依赖的有instance supplier parameter、factory method parameter、constructor parameter、等，在此之后处理的依赖有 class property、setter parameter等
ApplicationContextBeanFactory实现了IoC的基础能力，而ApplicationContext是BeanFactory的子类，除了继承IoC的基础能力外
支持国际化 (MessageSource) 支持资源访问 (ResourcePatternResolver) 事件机制 (ApplicationEventPublisher) 默认初始化所有Singleton 提供扩展能力 ApplicationContext无论何种功能的ApplicationContext，在做完基本的初始化后均会调用AbstractApplicationContext#Refresh
AbstractApplicationContext#Refreshrefresh准备上下文 - AbstractApplicationContext#prepareRefresh该部分主要实现对上下文的准备工作，其主要涉及到两个接口AbstractApplicationContext#initPropertySources及ConfigurablePropertyResolver#validateRequiredProperties，前者由子类实现，用于初始化PropertySource；后者用于对必要属性进行验证
1 2 3 4 5 6 7 public class MyClasspathXmlApplicationContext extends ClassPathXmlApplicationContext { @Override protected void initPropertySources() { super.initPropertySources(); getEnvironment().setRequiredProperties(&#34;runtimeEnv&#34;); } } 重写initPropertySources方法，并添加runtimeEnv为必须的环境变量属性，如此在系统启动的时候便会进行检测，对于不存在任何一个必要环境变量的情况均会抛出异常终止启动
加载BeanFactory - AbstractApplicationContext#obtainFreshBeanFactory该函数内部实现比较简单，重点在refreshBeanFactory，该函数同样由子类实现
对于AbstractRefreshableApplicationContext，refreshBeanFactory基本步骤为
创建BeanFactory (DefaultListableBeanFactory) 设置BeanFactory 加载BeanDefinition 在第3步中，AbstractXmlApplicationContext的实现则是对xml配置文件的解析及加载；AnnotationConfigWebApplicationContext的实现则是对class文件的扫描并加载，以及其他基于AbstractRefreshableApplicationContext的ApplicationContext实现
对于GenericApplicationContext，BeanFactory的创建及BeanDefinition的加载在refresh调用之前早已完成，refreshBeanFactory的实现则是对BeanFactory加载状态的简单校验
AbstractRefreshableApplicationContext &amp; GenericApplicationContextAbstractRefreshableApplicationContext对于继承自 AbstractRefreshableApplicationContext 的上下文，例如 ClassPathXmlApplicationContext 或 AnnotationConfigApplicationContext，它们通过覆盖 refreshBeanFactory() 方法来实现具体的 BeanDefinition 加载逻辑。这些上下文类型专门用于从外部资源（如 XML 文件、Java 配置类等）加载配置信息，并将这些配置信息解析为一组 BeanDefinition，然后注册到内部的 BeanFactory 中。这个过程通常发生在上下文的 refresh() 方法调用过程中（我们正在讨论的），这个方法不仅负责加载和注册 BeanDefinition，还包括初始化单例bean、处理别名定义、注册BeanPostProcessor等一系列容器启动时的活动。
[!QUOTE] refresh()关键步骤 ^configurerRelated
创建 BeanFactory：AbstractRefreshableApplicationContext 首先会创建一个新的 BeanFactory 实例，这通常是一个 DefaultListableBeanFactory 实例。这个 BeanFactory 实现了 BeanDefinitionRegistry 接口，使得它能够注册 BeanDefinition。 ==加载 BeanDefinition：接着，上下文会调用特定的方法（例如，对于基于 XML 的配置，会使用 XmlBeanDefinitionReader；对于基于注解的配置，会使用 AnnotatedBeanDefinitionReader 和 ClassPathBeanDefinitionScanner）来加载 BeanDefinition。这些 Reader 和 Scanner 实现了 BeanDefinitionRegistry 接口的 registerBeanDefinition 方法来实际完成注册工作。== 刷新 BeanFactory：加载完所有 BeanDefinition 后，AbstractRefreshableApplicationContext 会对 BeanFactory 进行刷新，这涉及到预实例化单例、注册 BeanPostProcessor、初始化剩余的非懒加载单例等一系列操作。 发布事件：在整个容器刷新过程中，还会发布各种应用事件，如 ContextRefreshedEvent，允许应用中的其他组件对这些事件作出响应。 通过上述步骤，AbstractRefreshableApplicationContext 完成了 BeanDefinition 的加载、注册以及整个 Spring 容器的初始化和刷新工作。在这个过程中，BeanDefinitionRegistry 接口扮演了 BeanDefinition 注册的关键角色
GenericApplicationContextGenericApplicationContext 直接实现了 BeanDefinitionRegistry 接口，使得它可以在运行时动态注册 BeanDefinition。与 AbstractRefreshableApplicationContext 的子类不同，GenericApplicationContext 并不专门依赖于外部资源来加载 BeanDefinition。相反，它提供了一套程序化的接口，允许开发者直接在代码中通过调用 registerBeanDefinition(String beanName, BeanDefinition beanDefinition) 方法来注册 BeanDefinition。这种方式使得 GenericApplicationContext 非常灵活，适用于那些需要在运行时动态调整 Spring 配置的场景。
关系和区别加载方式的区别：AbstractRefreshableApplicationContext 的子类通常通过解析配置资源（XML、注解等）来加载 BeanDefinition，而 GenericApplicationContext 允许以编程方式直接注册 BeanDefinition。 使用场景的区别：AbstractRefreshableApplicationContext 的子类适合于静态配置资源的场景，其中配置信息在应用启动时已经确定。GenericApplicationContext 更适合于动态配置的场景，比如基于条件的 BeanDefinition 注册或运行时的配置调整。 刷新容器的能力：虽然两者都可以通过 refresh() 方法来刷新应用上下文，但 AbstractRefreshableApplicationContext 的子类通常在设计时就考虑了完整的容器刷新流程（包括重新加载配置资源），而 GenericApplicationContext 刷新主要是为了应用新注册的 BeanDefinition。==前者会重置BeanFactory而后者不会== 填充部分扩展 - AbstractApplicationContext#prepareBeanFactory该函数执行以下逻辑
设置BeanFactory的ClassLoader 注册默认BeanExpressionResolver，用于依赖注入时SpEL的支持 注册默认PropertyEditor，用于依赖注入时对参数的解析转换 注册几个特殊Aware的处理逻辑 注册AspectJ相关的几个处理器，用于AOP的支持 注册几个特殊的BeanDefinition ==2-3 的核心逻辑在于解析依赖的值，DefaultListableBenFactory#doResolveDependency==
注册几个特殊Aware的处理逻辑在Bean实例化、注入依赖之后会对Bean进行[最后的初始化](#初始化 - AbstractAutowireCapableBeanFactory initializeBean “wikilink”)，调用相应的setter方法分别针对BeanNameAware、BeanClassLoaderAware、BeanFactoryAware进行处理
在该函数中，会注册几个特殊的BeanPostProcessor
1 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); 其实现了postProcessBeforeInitialization方法，内部调用ApplicationContextAwareProcessor#invokeAwareInterfaces针对另外的几类Aware进行了处理
除此之外，Spring会将上述几类Aware设置为ignoreDependencyInterface，这意味着以上几类Bean的注入只能通过Aware的方式而不能通过其他属性依赖注入的方式（属性注入、函数参数注入等）
注册特殊的Bean在使用Spring时，是否有过直接注入BeanFactory亦或是ResourceLoader，这些bean正是在这里被Spring注册进去的，除以上外Spring还注入了
BeanFactory ResourceLoader ApplicationEventPublisher ApplicationContext Environment systemProperties - Environment#.getSystemProperties:Map&lt;String, Object&gt; systemEnvironment - Environment#.getSystemEnvironment:Map&lt;String, Object&gt; AbstractApplicationContext#refresh#postProcessBeanFactory()对于不同的实现类，注册相应的BeanPostProcessor，例如ServletWebServerApplicationContext
激活BeanFactoryPostProcessor - AbstractApplicationContext#invokeBeanFactoryPostProcessors其内部实现在PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors
BeanFactoryPostProcessor的定义非常简单，其postProcessBeanFactory方法允许在bean实例化前对BeanFactory做一些额外的设置
1 2 3 4 5 6 7 8 9 public interface BeanFactoryPostProcessor { /** * Modify the application context&#39;s internal bean factory after its standard * initialization. All bean definitions will have been loaded, but no beans * will have been instantiated yet. This allows for overriding or adding * properties even to eager-initializing beans. */ void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException; } 核心逻辑如下
invokeBeanFactoryPostProcessors其中涉及两种类型，BeanDefinitionRegistryPostProcessor及BeanFactoryPostProcessor，前者为后者的子类，BeanDefinitionRegistryPostProcessors提供了额外的接口postProcessBeanDefinitionRegistry，用于更加方便地动态地注册额外的BeanDefinition (registryProcessor.postProcessBeanDefinitionRegistry(registry))，如读取配置文件（json、properties、yml）并解析（或者任何其他的形式），并通过该接口注册相应的BeanDefinition，基于Spring Boot Starter的很多框架均使用该方式进行bean的注册
以上流程图可以看出，优先执行BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry，再执行BeanFactoryPostProcessor#postProcessBeanFactory，各自内部优先执行PriorityOrdered实现，再执行Ordered实现，最后执行无任何排序的实现
注册BeanPostProcessor - AbstractApplicationContext#registerBeanPostProcessors其内部实现在PostProcessorRegistrationDelegate#registerBeanPostProcessors b
BeanPostProcessor1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public interface BeanPostProcessor { /** * Apply this BeanPostProcessor to the given new bean instance before any bean * initialization callbacks (like InitializingBean&#39;s afterPropertiesSet * or a custom init-method). * The returned bean instance may be a wrapper around the original. */ @Nullable default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { return bean; } /** * Apply this BeanPostProcessor to the given new bean instance after any bean * initialization callbacks (like InitializingBean&#39;s afterPropertiesSet * or a custom init-method). * The returned bean instance may be a wrapper around the original. */ @Nullable default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { return bean; } } postProcessBeforeInitialization方法在调用bean的init-method之前执行 postProcessAfterInitialization方法在调用bean的init-method之后执行 任何一个方法可对现有bean实例做进一步的修改 任何一个方法可返回新的bean实例，用来替代现有的bean实例 第四点即是AOP生成当前Bean代理的方法
InstantiationAwareBeanPostProcessor该接口继承自BeanPostProcessor，其同样有两个方法，一个在创建bean实例之前调用([createBean](#AbstractAutowireCapableBeanFactory createBean “wikilink”))，一个在创建bean实例之后、属性注入之前调用([属性注入](#属性注入 - AbstractAutowireCapableBeanFactory populateBean “wikilink”))
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor { @Nullable default Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException { return null; } default boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException { return true; } @Nullable default PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException { return pvs; } } AbstractApplicationContext#registerBeanPostProcessors，其内部逻辑与BeanFactoryPostProcessor的注册逻辑类似：
找到所有BeanPostProcessor并实例化 按照实现的Ordered接口分别放入priorityOrderedPostProcessors、orderedPostProcessors、nonOrderedPostProcessors并各自排序 如果实现了MergedBeanDefinitionPostProcessor则放入internalPostProcessors并排序 按顺序依次注册priorityOrderedPostProcessors、orderedPostProcessors、nonOrderedPostProcessors 最后注册internalPostProcessors MergedBeanDefinitionPostProcessor其有一个接口postProcessMergedBeanDefinition，在bean实例化完成后属性注入之前被调用，可以用来对当前的BeanDefinition做进一步的修改，如增加PropertyValue等，实现特殊的属性依赖注入，参考[BeanDefinition后处理](#BeanDefinition后处理 - AbstractAutowireCapableBeanFactory applyMergedBeanDefinitionPostProcessors “wikilink”)与[属性注入](#属性注入 - AbstractAutowireCapableBeanFactory populateBean “wikilink”)
初始化MessageSource - AbstractApplicationContext#initMessageSourceSpring的MessageSource提供了国际化能力，在开发者未注册MessageSource的情况下Spring会提供一个默认的DelegatingMessageSource
初始化ApplicationEventMulticaster - AbstractApplicationContext#initApplicationEventMulticasterSpring提供了一套事件（ApplicationEvent）的发布&amp;订阅机制，开发者可自定义事件（继承ApplicationEvent），注册事件监听器来订阅消费事件（实现ApplicationListener 或使用@EventListener 注解），并使用ApplicationEventPublisher（直接依赖注入或者使用ApplicationEventPublisherAware）发送事件，使用示例可参考https://www.baeldung.com/spri…
其实ApplicationContext实现了ApplicationEventPublisher，跟踪其publishEvent方法会发现，最终调用了AbstractApplicationContext#applicationEventMulticaster.multicastEvent，开发者可以自行注册一个ApplicationEventMulticaster，如果没有Spring会提供一个默认的SimpleApplicationEventMulticaster
SimpleApplicationEventMulticaster#multicastEvent的逻辑比较简单，会根据事件的类型找到可以处理的所有ApplicationListener，依次调用它们的onApplicationEvent方法消费事件
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Override public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) { ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event)); Executor executor = getTaskExecutor(); for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) { if (executor != null) { // 设置了executor，则异步执行 executor.execute(() -&gt; invokeListener(listener, event)); } else { // 否则同步执行 invokeListener(listener, event); } } } 默认情况下会同步、顺序的调用listeners的onApplicationEvent方法，只有设置了executor才会异步调用，不过这样的控制粒度比较粗，要么全部同步消费要么全部异步消费，比较细粒度的控制事件的消费有几种常用方法
使用@Async注解，独立控制某一listener异步消费（https://www.baeldung.com/spri…） 自行编码，将onApplicationEvent逻辑放在线程中执行 注册自定义的ApplicationEventMulticaster，内部实现自己的同步、异步Event处理逻辑 注册ApplicationListener - AbstractApplicationContext#registerListeners这里的逻辑比较简单
在BeanFactory中找到ApplicationListener类型的bean并实例化 调用ApplicationEventMulticaster#addApplicationListenerBean方法将ApplicationListeners注册进去 初始化所有非Lazy Bean - AbstractApplicationContext#finishBeanFactoryInitialization对于Singleton Bean而言，实例化发生在首次getBean，但你是否有疑惑，我们只是注册了众多Singleton Bean，但在Spring初始化完成后所有的Singleton Bean（Lazy Bean除外）均已经完成实例化
回到AbstractApplicationContext#finishBeanFactoryInitialization，该函数会实现几个逻辑
如果自定义了ConversionService(另一种注入类型转换的方式)类型bean且bean-name为conversionService，则将其注册到BeanFactory中 如果BeanFactory中不存在EmbeddedValueResolver（PropertyResourceConfigurer会注册一个PlaceholderResolvingStringValueResolver到BeanFactory中），则会注册一个默认的StringValueResolver用来处理 ${ ... }类型的值（Environment#resolvePlaceholders） 找到所有非Lazy的Singleton BeanDefinition进行实例化（getBean） 如果是FactoryBean，则在bean name前加上’&amp;’，并实例化该FactoryBean，随后实例化真实的bean 如果不是FactoryBean，则直接实例化该bean 执行SmartInitializingSingleton实现类的afterSingletonsInstantiated方法 Refresh的后续动作 - AbstractApplicationContext#finishRefresh除了一些中间状态需要清理外，还有两件比较特殊的地方
LifecycleProcessor - AbstractApplicationContext#initLifecycleProcessorSpring提供了LifecycleProcessor用于监听BeanFactory的refresh及close，在BeanFactory的各阶段会调用LifecycleProcessor的onFresh及onClose方法
开发者可以自行注册LifecycleProcessor类型的bean，bean-name必须为&#34;lifecycleProcessor&#34;，否则Spring会提供一个默认的DefaultLifecycleProcessor
之后则会触发LifecycleProcessor的onFresh方法
除此之外，还可以监听ContextRefreshedEvent及ContextClosedEvent消息
refresh事件在BeanFactory初始化完成后，则会发出ContextRefreshedEvent事件
BeanFactory的销毁 - AbstractApplicationContext#registerShutdownHook该函数用来注册BeanFactory的销毁逻辑
1 2 3 4 5 6 7 8 9 10 11 12 13 public void registerShutdownHook() { if (this.shutdownHook == null) { this.shutdownHook = new Thread(&#34;SpringContextShutdownHook&#34;) { public void run() { synchronized(AbstractApplicationContext.this.startupShutdownMonitor) { AbstractApplicationContext.this.doClose(); } } }; Runtime.getRuntime().addShutdownHook(this.shutdownHook); } } 其直接使用了java的addShutdownHook函数，在jvm进程正常退出的时候触发
AbstractApplicationContext#doClose函数定义了BeanFactory具体的销毁过程
发出ContextClosedEvent事件 触发LifecycleProcessor的onClose方法 销毁bean，细节参考Bean销毁过程 由子类实现的AbstractApplicationContext#closeBeanFactory及AbstractApplicationContext#onClose方法 ASIDEBeanDefinition的加载在[AbstractApplicationContext#obtainFreshBeanFactory](#加载BeanFactory - AbstractApplicationContext obtainFreshBeanFactory “wikilink”)中实现 TODO #{ ... }类型值的解析由StandardBeanExpressionResolve实现 ${ ... }类型值的解析由PlaceholderResolvingStringValueResolver实现 Spring提供了众多默认的PropertyEditor，若需要自定义PropertyEditor可以通过注册CustomEditorConfigurer实现 Spring提供了众多Aware，若需要自定义Aware可以通过BeanPostProcessor实现 BeanFactoryPostProcessor用于在实例化bean之前对BeanFactory做额外的动作 如，PropertyResourceConfigurer用来将PlaceholderResolvingStringValueResolver注册到BeanFactory的embeddedValueResolvers中 [BeanDefinitionRegistryPostProcessor](#激活BeanFactoryPostProcessor - AbstractApplicationContext invokeBeanFactoryPostProcessors “wikilink”)用于在实例化bean之前（动态）注册额外的BeanDefinition ^fa1ce8 BeanPostProcessor用于在调用bean的init-method前后，对实例化完成的bean做一些额外的干预 如，CommonAnnotationBeanPostProcessor用来处理@PostConstructor，AbstractAdvisingBeanPostProcessor用来实现AOP ApplicationContext具体实现类 - AnnotationConfigApplicationContext1 2 3 4 5 public AnnotationConfigApplicationContext(Class&lt;?&gt;... componentClasses) { this(); //1. 首先会调用自己的无参构造 register(componentClasses); //2. 然后注册我们传入的配置类 refresh(); //3. 最后进行刷新操作（关键） } 无参构造1 2 3 4 5 6 7 8 public AnnotationConfigApplicationContext() { StartupStep createAnnotatedBeanDefReader = this.getApplicationStartup().start(&#34;spring.context.annotated-bean-reader.create&#34;); //创建AnnotatedBeanDefinitionReader对象，用于后续处理 @Bean 注解 this.reader = new AnnotatedBeanDefinitionReader(this); createAnnotatedBeanDefReader.end(); //创建ClassPathBeanDefinitionScanner对象，用于扫描类路径上的Bean this.scanner = new ClassPathBeanDefinitionScanner(this); } AnnotatedBeanDefinitionReader1 2 3 4 5 6 7 8 public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) { Assert.notNull(registry, &#34;BeanDefinitionRegistry must not be null&#34;); Assert.notNull(environment, &#34;Environment must not be null&#34;); this.registry = registry; this.conditionEvaluator = new ConditionEvaluator(registry, environment, null); //这里注册了注解处理配置相关的后置处理器 AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); } 这里会将ConfigurationClassPostProcessor后置处理器加入到BeanFactory中，它继承自BeanFactoryPostProcessor，也就是说一会会在BeanFactory初始化完成之后进行后置处理，同时这里也会注册一个AutowiredAnnotationBeanPostProcessor后置处理器到BeanFactory，它继承自BeanPostProcessor，用于处理后续生成的Bean对象，其实看名字就知道，这玩意就是为了处理@Autowire、@Value这种注解，用于自动注入
注册传入的配置类 - register1 2 3 4 5 6 7 8 9 @Override public void register(Class&lt;?&gt;... componentClasses) { Assert.notEmpty(componentClasses, &#34;At least one component class must be specified&#34;); StartupStep registerComponentClass = this.getApplicationStartup().start(&#34;spring.context.component-classes.register&#34;) .tag(&#34;classes&#34;, () -&gt; Arrays.toString(componentClasses)); //使用我们上面创建的Reader注册配置类 this.reader.register(componentClasses); registerComponentClass.end(); } [Refresh](#AbstractApplicationContext Refresh “wikilink”)==TODO==☒ Spring AOP ☐ 注解运行逻辑 @Component与@Bean的区别 JavaSSM#^473168 ☐ @Bean 在处理属性注入时？ ☒ AnnotationConfigApplicationContext - 与 配置类的关系 - 具体例子 ☐ BeanDefinitionReader和BeanDefinitionRegistry ☐ 完善调用链图 配置类的注册 - ConfigurationClassPostProcessorConfigurationClassPostProcessor继承自BeanDefinitionRegistryPostProcessor -&gt; BeanFactoryPostProcessor，这个后置处理器是Spring中提供的，这是专门用于处理配置类的后置处理器，其中ImportBeanDefinitionRegistrar，还有ImportSelector都是靠它来处理
ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry内部调用 processConfigBeanDefinitions(BeanDefinitionRegistry) 方法
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) { // 将Spring认为可能是配置类的候选类加入candidates，例如@Configuration、@Component // @ComponentScan、@Import，以及通过实现ImportSelector或ImportBeanDefinitionRegistrar间接引入的配置 List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;(); // 直接取出所有已注册Bean的名称 String[] candidateNames = registry.getBeanDefinitionNames(); for (String beanName : candidateNames) { // 依次拿到对应的Bean定义，然后进行判断 BeanDefinition beanDef = registry.getBeanDefinition(beanName); if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) { ... } // 检查一个Bean定义是否符合作为配置类的条件，即使它没有直接使用@Configuration注解 else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) { configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); } } // 如果一个打了 @Configuration 的类都没发现，直接返回 if (configCandidates.isEmpty()) { return; } // 对所有的配置类依据 @Order 进行排序 configCandidates.sort((bd1, bd2) -&gt; { int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition()); int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition()); return Integer.compare(i1, i2); }); ... // 这里使用do-while语句依次解析所有的配置类 ConfigurationClassParser parser = new ConfigurationClassParser( this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry); Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates); Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size()); do { StartupStep processConfig = this.applicationStartup.start(&#34;spring.context.config-classes.parse&#34;); //这里就会通过Parser解析配置类中大部分内容，包括我们之前遇到的@Import注解 parser.parse(candidates); parser.validate(); //解析完成后读取到所有的配置类 Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses()); configClasses.removeAll(alreadyParsed); ... //将上面读取的配置类加载为Bean this.reader.loadBeanDefinitions(configClasses); ... } while (!candidates.isEmpty()); ... } ConfigurationClassParser#parse(candidates)1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) { for (BeanDefinitionHolder holder : configCandidates) { BeanDefinition bd = holder.getBeanDefinition(); try { if (bd instanceof AnnotatedBeanDefinition annotatedBeanDef) { parse(annotatedBeanDef, holder.getBeanName()); } else if (bd instanceof AbstractBeanDefinition abstractBeanDef &amp;&amp; abstractBeanDef.hasBeanClass()) { parse(abstractBeanDef.getBeanClass(), holder.getBeanName()); } else { parse(bd.getBeanClassName(), holder.getBeanName()); } } catch (BeanDefinitionStoreException ex) { throw ex; } catch (Throwable ex) { throw new BeanDefinitionStoreException( &#34;Failed to parse configuration class [&#34; &#43; bd.getBeanClassName() &#43; &#34;]&#34;, ex); } } this.deferredImportSelectorHandler.process(); } 内部遍历candidates中的每一个BeanDefinitionHolder，调用parse的多态方法，最终调用ConfigurationClassParser#processConfigurationClass，最后调用deferredImportSelectorHandler.process()处理DeferredImportSelector相关的Bean注册 ^processConfigurationClass
首先判断条件注释，即处理@Conditional相关注解
然后将不同来源的配置类源信息通过asSourceClass进行封装，交给最核心的调用[doProcessConfigurationClass](#ConfigurationClassParser doProcessConfigurationClass “wikilink”)
将配置类ConfigurationClass实例化为SourceClass。这样做的目的是为了让后续的处理逻辑能够通过SourceClass访问到配置类中定义的所有相关信息（比如注解信息，Meta-info），并进行相应的处理。例如，通过SourceClass可以读取配置类上的@ComponentScan注解，并执行组件扫描；读取@Import注解，并处理导入的配置类或组件；读取@Bean方法，并注册对应的Bean定义等。
ConfigurationClassParser#doProcessConfigurationClass1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 @Nullable protected final SourceClass doProcessConfigurationClass( ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter) throws IOException { if (configClass.getMetadata().isAnnotated(Component.class.getName())) { // Recursively process any member (nested) classes first processMemberClasses(configClass, sourceClass, filter); } // Process any @PropertySource annotations for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class, PropertySources.class, true)) { if (this.propertySourceRegistry != null) { this.propertySourceRegistry.processPropertySource(propertySource); } else { logger.info(&#34;Ignoring @PropertySource annotation on [&#34; &#43; sourceClass.getMetadata().getClassName() &#43; &#34;]. Reason: Environment must implement ConfigurableEnvironment&#34;); } } // Search for locally declared @ComponentScan annotations first. Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), ComponentScan.class, ComponentScans.class, MergedAnnotation::isDirectlyPresent); // Fall back to searching for @ComponentScan meta-annotations (which indirectly // includes locally declared composed annotations). if (componentScans.isEmpty()) { componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScan.class, ComponentScans.class, MergedAnnotation::isMetaPresent); } if (!componentScans.isEmpty()) { List&lt;Condition&gt; registerBeanConditions = collectRegisterBeanConditions(configClass); if (!registerBeanConditions.isEmpty()) { throw new ApplicationContextException( &#34;Component scan could not be used with conditions in REGISTER_BEAN phase: &#34; &#43; registerBeanConditions); } for (AnnotationAttributes componentScan : componentScans) { // The config class is annotated with @ComponentScan -&gt; perform the scan immediately Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); // Check the set of scanned definitions for any further config classes and parse recursively if needed for (BeanDefinitionHolder holder : scannedBeanDefinitions) { BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition(); if (bdCand == null) { bdCand = holder.getBeanDefinition(); } if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) { parse(bdCand.getBeanClassName(), holder.getBeanName()); } } } } // Process any @Import annotations processImports(configClass, sourceClass, getImports(sourceClass), filter, true); // Process any @ImportResource annotations AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class); if (importResource != null) { String[] resources = importResource.getStringArray(&#34;locations&#34;); Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&#34;reader&#34;); for (String resource : resources) { String resolvedResource = this.environment.resolveRequiredPlaceholders(resource); configClass.addImportedResource(resolvedResource, readerClass); } } // Process individual @Bean methods Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass); for (MethodMetadata methodMetadata : beanMethods) { configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass)); } // Process default methods on interfaces processInterfaces(configClass, sourceClass); // Process superclass, if any if (sourceClass.getMetadata().hasSuperClass()) { String superclass = sourceClass.getMetadata().getSuperClassName(); if (superclass != null &amp;&amp; !superclass.startsWith(&#34;java&#34;)) { boolean superclassKnown = this.knownSuperclasses.containsKey(superclass); this.knownSuperclasses.add(superclass, configClass); if (!superclassKnown) { // Superclass found, return its annotation metadata and recurse return sourceClass.getSuperClass(); } } } // No superclass -&gt; processing is complete return null; } 该函数依次解决如下问题：
处理@Component注解 处理@PropertySource和@PropertySources注解 处理@ComponentScan和@ComponentScans 处理@Import注解 处理@ImportResource注解 处理@Bean注解的方法 处理接口上的默认方法和超类 其中的核心是处理@Import注解，通过调用 [ConfigurationClassParser#processImports](#ConfigurationClassParser processImports “wikilink”)
ConfigurationClassParser#processImports注意其第三个入参Collection&lt;SourceClass&gt; importCandidates，它是通过调用getImports(sourceClass)方法，从给定的sourceClass中提取所有@Import注解指定的类，如果sourceClass是普通的配置类，直接通过isEmpty()返回
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection&lt;SourceClass&gt; importCandidates, Predicate&lt;String&gt; filter, boolean checkForCircularImports) { if (importCandidates.isEmpty()) { return; } if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) { this.problemReporter.error(new CircularImportProblem(configClass, this.importStack)); } else { this.importStack.push(configClass); try { for (SourceClass candidate : importCandidates) { if (candidate.isAssignable(ImportSelector.class)) { // Candidate class is an ImportSelector -&gt; delegate to it to determine imports Class&lt;?&gt; candidateClass = candidate.loadClass(); ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry); Predicate&lt;String&gt; selectorFilter = selector.getExclusionFilter(); if (selectorFilter != null) { filter = filter.or(selectorFilter); } if (selector instanceof DeferredImportSelector deferredImportSelector) { this.deferredImportSelectorHandler.handle(configClass, deferredImportSelector); } else { String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata()); Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames, filter); processImports(configClass, currentSourceClass, importSourceClasses, filter, false); } } else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) { // Candidate class is an ImportBeanDefinitionRegistrar -&gt; // delegate to it to register additional bean definitions Class&lt;?&gt; candidateClass = candidate.loadClass(); ImportBeanDefinitionRegistrar registrar = ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, this.environment, this.resourceLoader, this.registry); configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata()); } else { // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt; // process it as an @Configuration class this.importStack.registerImport( currentSourceClass.getMetadata(), candidate.getMetadata().getClassName()); processConfigurationClass(candidate.asConfigClass(configClass), filter); } } } catch (BeanDefinitionStoreException ex) { throw ex; } catch (Throwable ex) { throw new BeanDefinitionStoreException( &#34;Failed to process import candidates for configuration class [&#34; &#43; configClass.getMetadata().getClassName() &#43; &#34;]: &#34; &#43; ex.getMessage(), ex); } finally { this.importStack.pop(); } } } 代码遍历每一个@Import注解指定的候选类，根据不同类型进行处理
ImportSelector实现 ImportSelector DeferredImportSelector ImportBeanDefinitionRegistar实现 普通的配置类 针对ImportSelector通过selector.selectImports()与asSourceClasses()方法将需要导入的类重新封装为SourceClass，递归调用processImports
针对DeferredImportSelector通过调用ConfigurationClassParser的内部类DeferredImportSelectorHandler#handle()方法，将其封装为DeferredImportSelectorHolder ，加入待处理的List - deferredImportSelectors
在ConfigurationClassParser#parse[处理完所有候选配置类后](#ConfigurationClassParser parse(candidates) “wikilink”)，调用DeferredImportSelectorHandler#process()方法，该方法将加入deferredImportSelectors中的所有DeferredImportSelectorHolder执行内部类的DeferredImportSelectorGroupingHandler#register方法，得到包装好的、已经分组完毕的DeferredImportSelectorGrouping，然后调用DeferredImportSelectorGroupingHandler#processGroupImports()，处理组内所有的延迟导入 (DeferredImportSelector)
DeferredImportSelectorGroupingHandler#register1 2 3 4 5 6 7 8 9 void register(DeferredImportSelectorHolder deferredImport) { Class&lt;? extends Group&gt; group = deferredImport.getImportSelector().getImportGroup(); DeferredImportSelectorGrouping grouping = this.groupings.computeIfAbsent( (group != null ? group : deferredImport), key -&gt; new DeferredImportSelectorGrouping(createGroup(group))); grouping.add(deferredImport); this.configurationClasses.put(deferredImport.getConfigurationClass().getMetadata(), deferredImport.getConfigurationClass()); } 首先尝试获取DeferredImportSelector指定的导入组 (ImportGroup)，如果没有指定特定的导入组，则使用DeferredImportSelector本身作为组的Key 尝试从一个名为groupings的映射中获取或创建一个与导入组对应的DeferredImportSelectorGrouping对象。如果映射中尚未存在与当前组对应的分组，那么将创建一个新的分组，并将其加入到映射中 注意，此处的Group逻辑是将DeferredImportSelector.Group这个内部接口包装到ConfigurationClassParser.DeferredImportSelectorGourping这个内部类中，其内部维护了一个DeferredImportSelector.Group对象和List&lt;DeferredImportSelectorHolder&gt;对象 调用DeferredImportSelectGrouping#add(DeferredImportSelectorHolder)，将DeferredImportSelectorHolder加入内部类维护的Grouping中 (静态类) 最后，代码将当前DeferredImportSelectorHolder对应的配置类(ConfigurationClass)及其元数据添加到一个名为configurationClasses的映射中。这确保了后续能够快速访问到与特定DeferredImportSelector相关联的配置类 DeferredImportSelectorGroupingHandler#processGroupImports1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void processGroupImports() { for (DeferredImportSelectorGrouping grouping : this.groupings.values()) { Predicate&lt;String&gt; filter = grouping.getCandidateFilter(); grouping.getImports().forEach(entry -&gt; { ConfigurationClass configurationClass = this.configurationClasses.get(entry.getMetadata()); try { processImports(configurationClass, asSourceClass(configurationClass, filter), Collections.singleton(asSourceClass(entry.getImportClassName(), filter)), filter, false); } catch (BeanDefinitionStoreException ex) { throw ex; } catch (Throwable ex) { throw new BeanDefinitionStoreException( &#34;Failed to process import candidates for configuration class [&#34; &#43; configurationClass.getMetadata().getClassName() &#43; &#34;]&#34;, ex); } }); } } 遍历保存在Groups - DeferredImportSelectorGroupingHandler中的 DeferredImportSelectorGroup对象，调用 DeferredImportSelectorGroup#getImports()方法 DeferredImportSelectorGroup#getImports()方法调用DeferredImportSelectorGroup中维护的真实的Group - DeferredImportSelector.Group#process方法，然后返回含有meta-info的Entry 使用内部维护的Map(在register中put)，根据Entry.meta-info得到对应的ConfigurationClass ，调用ConfigurationClassParser#processImports，和[前面](#ConfigurationClassParser processImports “wikilink”)一样递归调用进行处理 所以根据以上分析，DeferredImportSelector最终的处理逻辑在于DeferredImportSelector.Group#process() ^db8805
针对ImportBeanDefinitionRegistar1 2 3 4 5 6 7 8 public interface ImportBeanDefinitionRegistrar { default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator) { this.registerBeanDefinitions(importingClassMetadata, registry); } default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { } } 调用ConfigurationClass#addImportBeanDefinitionRegistrar方法，将对应的实例加入configClass对应的Collection类中，后续在[loadBeanDefinitions](#ConfigurationClassBeanDefinitionReader loadBeanDefinitions “wikilink”)中调用其registerBeanDefinitions，注册相应的BeanDefinition
针对普通配置类不使用特殊机制，直接递归调用processConfigurationClass
ConfigurationClassParser#getConfigurationClasses返回从前面得到的所有待配置的配置类
ConfigurationClassBeanDefinitionReader#loadBeanDefinitions^98f726
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public void loadBeanDefinitions(Set&lt;ConfigurationClass&gt; configurationModel) { TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator(); for (ConfigurationClass configClass : configurationModel) { loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator); } } /** * Read a particular {@link ConfigurationClass}, registering bean definitions * for the class itself and all of its {@link Bean} methods. */ private void loadBeanDefinitionsForConfigurationClass( ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) { if (trackedConditionEvaluator.shouldSkip(configClass)) { String beanName = configClass.getBeanName(); if (StringUtils.hasLength(beanName) &amp;&amp; this.registry.containsBeanDefinition(beanName)) { this.registry.removeBeanDefinition(beanName); } this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName()); return; } if (configClass.isImported()) { registerBeanDefinitionForImportedConfigurationClass(configClass); } for (BeanMethod beanMethod : configClass.getBeanMethods()) { loadBeanDefinitionsForBeanMethod(beanMethod); } loadBeanDefinitionsFromImportedResources(configClass.getImportedResources()); loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars()); } 通过遍历每一个配置类，调用loadBeanDefinitionsForConfigurationClass方法 ^f6a27a
registerBeanDefinitionForImportedConfigurationClass(configClass) 注册配置类自身 loadBeanDefinitionsForBeanMethod(beanMethod) 注册@Bean注解标识的方法 loadBeanDefinitionsFromImportedResources(configClass.getImportedResources()); 注册@ImportResource引入的XML配置文件中读取的bean定义 loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars()); 注册configClass中经过解析后保存的所有ImportBeanDefinitionRegistrar，注册对应的BeanDefinition AOPAOP的实现类是AnnotationAwareAspectJAutoProxyCreator，其是BeanPostProcessor的实现类，具体来说，是InstantiationAwareBeanPostProcessor的实现类，在实例化Bean过程中，通过调用BeanPostProcessor中的实例化前处理器进行短路，得到相应的代理Bean
@EnableAspectJAutoProxy1 2 3 4 5 6 7 8 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Import({AspectJAutoProxyRegistrar.class}) public @interface EnableAspectJAutoProxy { boolean proxyTargetClass() default false; boolean exposeProxy() default false; } 这个注解使用@Import导入了AspectJAutoProxyRegistrar，其是ImportBeanDefinitionRegistrar的实现类，会在处理配置类相应@Import机制的时候将AnnotationAwareAspectJAutoProxyCreator实现类注册到容器中，即注册到BeanDefinition中，实现相应的实例化前处理器功能 (InstantiationAwareBeanPostProcessor)">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-13T11:26:20+08:00">
    <meta property="article:modified_time" content="2024-05-13T11:26:20+08:00">
    <meta property="article:tag" content="Java">
    <meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary"><meta name="twitter:title" content="Spring 主要源码分析">
<meta name="twitter:description" content="Bean的生命周期为：BeanFactory初始化 - Bean注册 - 实例化 - 属性注入 - 初始化 - 后处理
Bean的注册
  
    
  

扫描：Spring通过配置（XML配置或Java配置）或自动扫描（@ComponentScan）来发现应用中定义的Bean。对于自动扫描，Spring会在指定的包路径下查找标注了@Component、@Service、@Repository、@Controller等注解的类
解析：一旦Bean被发现，Spring将解析Bean的定义信息，包括Bean的作用域（如单例、原型）、生命周期回调（如@PostConstruct、@PreDestroy注解方法）、依赖注入的需求（通过@Autowired、@Resource等注解标记）等 &mdash;&mdash; BeanDefinition
注册：Spring将Bean的定义信息注册到BeanDefinitionRegistry中。这是一个重要步骤，因为注册后的Bean定义将被用于后续的Bean实例化和依赖注入过程。此时，Bean还没有被实例化。

BeanDefinition
  
    
  


BeanDefinition

Spring在初始化过程中，先收集所有bean的元数据信息并注册，bean的元数据描述为接口BeanDefinition，该接口定义了你能想到的一切有关bean的属性信息
BeanDefinition衍生出一系列实现类

AbstractBeanDefinition: 如同其他Spring类，大部分BeanDefinition接口的逻辑都由该抽象类实现
GenericBeanDefinition: 是一站式、用户可见的bean definition；可见的bean definition意味着可以在该bean definition上定义post-processor来对bean进行操作
RootBeanDefinition: 当bean definition存在父子关系的时候，RootBeanDefinition用来承载父元数据的角色（也可独立存在），同时它也作为一个可合并的bean definition使用，在Spring初始化阶段，所有的bean definition均会被（向父级）合并为RootBeanDefinition，子bean definition（GenericBeanDefinition/ChildBeanDefinition）中的定义会覆盖其父bean definition（由parentName指定）的定义
AnnotatedBeanDefinition: 用来定义注解Bean Definition

BeanDefinitionHolder只是简单捆绑了BeanDefinition、bean-name、bean-alias，用于注册BeanDefinition及别名alias ^BeanDefinitionHolder
BeanRegistry
  
    
  
Bean的注册逻辑分为两步，一为BeanDefinition的注册，二为别名的注册

BeanDefinition注册的定义在BeanDefinitionRegistry#registerBeanDefinition，其实现使用一个Map&lt;String, BeanDefinition&gt; 来保存bean-name和BeanDefinition的关系


别名的注册定义在AliasRegistry#registerAlias，其实现同样使用一个Map&lt;String, String&gt; 来保存别名alias-name和bean-name（或另一个别名alias-name）的关系

注意Bean的注册时机，通常应该在应用上下文的刷新过程之前进行(onRefresh())。一旦上下文被刷新，对Bean定义的任何修改可能不会被识别，或者可能会导致不一致的状态
Bean的实例化
  
    
  


BigMap

BeanFactory
  
    
  

几个核心接口：

AliasRegistry
bean别名注册和管理
BeanDefinitionRegistry
bean元数据注册和管理
SingletonBeanRegistry
单例bean注册和管理
BeanFactory
bean工厂，提供各种bean的获取及判断方法

通过上述的类依赖图，对于Bean的实例化，核心实现是在DefaultListableBeanFactory
DefaultListableBeanFactory - AbstractBeanFactory
  
    
  
bean的实例化过程发生在getBean调用阶段（对于singleton则发生在首次调用阶段），getBean的实现方法众多，我们追根溯源，找到最通用的方法AbstractBeanFactory#doGetBean
doGetBean
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22


// org.springframework.beans.factory.support.AbstractBeanFactory
protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,
        @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {

    // 1. 获取真正的beanName
    final String beanName = transformedBeanName(name);
    Object bean;

    // 2. 尝试获取(提前曝光的)singleton bean实例（为了解决循环依赖）
    Object sharedInstance = getSingleton(beanName);
    
    // 3. 如果存在
    if (sharedInstance != null &amp;&amp; args == null) { ... }
    
    // 4. 如果不存在
    else { ... }
    
    // 5. 尝试类型转换
    if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) { ... }
    
    return (T) bean;
}



doGetBean

Bean Name的转换
  
    
  
在使用bean-name获取bean的时候，除了可以使用原始bean-name之外，还可以使用alias别名等，bean-name的转换则是将传入的&rsquo;bean-name&rsquo;一层层转为最原始的bean-name

函数canonicalName的作用则是利用别名注册aliasMap，将别名alias转为原始bean-name
函数transformedBeanName比较特殊，其是将FactoryBean的bean-name前缀 &lsquo;&amp;&rsquo; 去除


尝试获取单例
  
    
  
拿到原始的bean-name之后，便可以实例化bean或者直接获取已经实例化的singleton-bean
在获取singleton-bean的时候一般存在三种情况：1. 还未实例化(或者不是单例)；2. 已经实例化；3. 正在实例化；

对于 &ldquo;1. 还未实例化&rdquo; ，返回null即可，后续进行实例化动作
对于 &ldquo;2. 已经实例化&rdquo;，直接返回实例化的singleton-bean
对于 &ldquo;3. 正在实例化&rdquo;，会存在循环依赖问题

Spring中对于singleton-bean，有一个sharedInstance的概念，在调用getSingleton函数时，返回的不一定是完全实例化的singleton-bean，有可能是一个中间状态（创建完成，但未进行属性依赖注入及其他后处理逻辑），这种中间状态会通过getSingleton函数提前曝光出来，目的是为了解决循环依赖
因此，Spring通过提供三层缓存来解决循环依赖问题，并且可以通过这种机制实现诸多的PostProcessor增强Bean，例如AOP

singletonObjects
缓存已经实例化完成的singleton-bean



earlySingletonObjects
缓存正在实例化的、提前曝光的singleton-bean，用于处理循环依赖


singletonFactories
缓存用于生成earlySingletonObject的 ObjectFactory



ObjectFactory，定义了一个用于创建、生成对象实例的工厂方法



1
2
3
4


@FunctionalInterface
public interface ObjectFactory&lt;T&gt; {
    T getObject() throws BeansException;
}

因此getSingleton的逻辑如下：

NOTE: 在提前暴露实体中，将相应的ObjectFactory放入了singletonFactories
FactoryBean的处理(sharedInstance存在的逻辑)
  
    
  
==sharedInstance不一定是我们所需要的bean实例==
例如，我们在定义Bean的时候可以通过实现FactoryBean接口来定制bean实例化的逻辑(实现FactoryBean)，通过注册FactoryBean类型的Bean，实例化后的原始实例类型同样为FactoryBean，但我们需要的是通过FactoryBean#getObject方法得到的实例，这需要针对FactoryBean做一些处理，即AbstractBeanFactory#getObjectForBeanInstance

Get the object for the given bean instance, either the bean instance itself or its created object in case of a FactoryBean.
Now we have the bean instance, which may be a normal bean or a FactoryBean. If it&rsquo;s a FactoryBean, we use it to create a bean instance.

该函数要实现的逻辑比较简单，如果sharedInstance是 FactoryBean，则使用getObject方法创建真正的实例

getObjectForBeanInstance是一个通用函数，并不只针对通过getSingleton得到的sharedInstance，任何通过缓存或者创建得到的 rawInstance，都需要经过getObjectForBeanInstance处理，拿到真正需要的 beanInstance



1
2
3
4
5
6
7
8


/**
 * @param beanInstance  sharedInstance / rawInstance，可能为FactoryBean
 * @param name            传入的未做转换的 bean name
 * @param beanName        对name做过转换后的原始 canonical bean name
 * @param mbd            合并后的RootBeanDefinition，下文会介绍
 */
protected Object getObjectForBeanInstance(
    Object beanInstance, String name, String beanName, RootBeanDefinition mbd)

getObjectBeanInstance
  
    
  


getObjectForBeanInstance

在这个判断逻辑中，如果入参name以&rsquo;&amp;&lsquo;开头则直接返回，这里兼容了一种情况，如果需要获取/注入FactoryBean而不是getObject生成的实例，则需要在bean-name/alias-name前加入&#39;&amp;&#39;
对于singleton，FactoryBean#getObject的结果会被缓存到factoryBeanObjectCache，对于缓存中不存在或者不是singleton的情况，会通过FactoryBean#getObject生成 ^factorybeangetobject
FactoryBeanRegistrySupport#getObjectFromFactoryBean
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47


protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) {  
    if (factory.isSingleton() &amp;&amp; this.containsSingleton(beanName)) {  
        synchronized(this.getSingletonMutex()) {  
            Object object = this.factoryBeanObjectCache.get(beanName);  
            if (object == null) {  
                object = this.doGetObjectFromFactoryBean(factory, beanName);  
                Object alreadyThere = this.factoryBeanObjectCache.get(beanName);  
                if (alreadyThere != null) {  
                    object = alreadyThere;  
                } else {  
                    if (shouldPostProcess) {  
                        if (this.isSingletonCurrentlyInCreation(beanName)) {  
                            return object;  
                        }  
  
                        this.beforeSingletonCreation(beanName);  
  
                        try {  
                            object = this.postProcessObjectFromFactoryBean(object, beanName);  
                        } catch (Throwable var14) {  
                            throw new BeanCreationException(beanName, &#34;Post-processing of FactoryBean&#39;s singleton object failed&#34;, var14);  
                        } finally {  
                            this.afterSingletonCreation(beanName);  
                        }  
                    }  
  
                    if (this.containsSingleton(beanName)) {  
                        this.factoryBeanObjectCache.put(beanName, object);  
                    }  
                }  
            }  
  
            return object;  
        }  
    } else {  
        Object object = this.doGetObjectFromFactoryBean(factory, beanName);  
        if (shouldPostProcess) {  
            try {  
                object = this.postProcessObjectFromFactoryBean(object, beanName);  
            } catch (Throwable var17) {  
                throw new BeanCreationException(beanName, &#34;Post-processing of FactoryBean&#39;s object failed&#34;, var17);  
            }  
        }  
  
        return object;  
    }  
}

对于Singleton:

首先从缓存中尝试获取，如获取失败，调用[doGetObjectFromFactoryBean](#FactoryBeanRegistrySupport doGetObjectFromFactoryBean &ldquo;wikilink&rdquo;)，其中内核是调用FactoryBean#getObject()方法
对于需要后处理的Bean，首先判断是否处于正在创建状态(isSingletonCurrentlyInCreation)，并且通过this.beforeSingletonCreate() this.afterSingletonCreation()将实际的BeanPostProcessor过程保护
对于BeanPostProcessor，调用this.postProcessObjectFromFactoryBean，其具体实现在[AbstractAutowireCapableBeanFactory#applyBeanPostProcessorAfterInitialization](#AbstractAutowireCapableBeanFactory applyBeanPostProcessorAfterInitialization &ldquo;wikilink&rdquo;)

FactoryBeanRegistrySupport#doGetObjectFromFactoryBean
  
    
  


FactoryBeanRegistrySupport_doGetObjectFromFactoryBean

AbstractAutowireCapableBeanFactory#applyBeanPostProcessorAfterInitialization
  
    
  
postProcessAfterInitialization函数可以对现有bean instance做进一步的处理，甚至可以返回新的bean instance，这就为bean的增强提供了一个非常方便的扩展方式
加载Bean实例 (sharedInstance不存在的逻辑)
  
    
  


createBeanInstance

Bean的加载/创建分为三大部分

将BeanDefinition合并为RootBeanDefinition，类似类继承，子BeanDefinition属性会覆盖父BeanDefinition
依次加载所依赖的bean，对于有依赖的情况，优先递归加载依赖的bean
按照不同的bean类型，根据BeanDefinition的定义进行加载/创建

BeanDefinition合并 (RootBeanDefinition)
  
    
  
在AbstractBeanFactory#getMergedLocalBeanDefinition中执行核心逻辑
加载dependes-On beans
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13


String[] dependsOn = mbd.getDependsOn();
if (dependsOn != null) {
    // 遍历所有的依赖
    for (String dep : dependsOn) {
        // 检测循环依赖
        if (isDependent(beanName, dep)) { /* throw exception */ }
        // 注册依赖关系
        registerDependentBean(dep, beanName);
        // 递归getBean，加载依赖bean
        try { getBean(dep); }
        catch (NoSuchBeanDefinitionException ex) { /* throw exception */ }
    }
}

该过程中涉及两个中间态

dependentBeanMap
存储哪些bean依赖了我（哪些bean里注入了我）
如果 beanB -&gt; beanA, beanC -&gt; beanA，key为beanA，value为[beanB, beanC]


dependenciesForBeanMap
存储我依赖了哪些bean（我注入了哪些bean）
如果 beanA -&gt; beanB, beanA -&gt; beanC，key为beanA，value为[beanB, beanC]

加载singleton bean实例
  
    
  


1
2
3
4
5
6
7
8


if (mbd.isSingleton()) {
    sharedInstance = getSingleton(beanName, () -&gt; {
        // singletonFactory - ObjectFactory
        try { return createBean(beanName, mbd, args); }
        catch (BeansException ex) {    destroySingleton(beanName);    throw ex; }
    });
    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
}

其中核心为createBean与getObjectForBeanInstance

createBean
根据BeanDefinition的内容，创建/初始化 bean instance
#getObjectBeanInstance
主要处理FactoryBean

createBean被包装在lambda(singletonFactory)，重写ObjectFactory#getObject()，作为[getSingleton](#DefaultSingletonBeanRegistry getSingleton(String, ObjectFactory) &ldquo;wikilink&rdquo;)的参数
DefaultSingletonBeanRegistry#getSingleton(String, ObjectFactory)
  
    
  


createSingletonBean

同样的，会先在缓存中查找该singleton，如果不存在，创建的核心逻辑在于[createBean](#AbstractAutowireCapableBeanFactory createBean &ldquo;wikilink&rdquo;)
AbstractAutowireCapableBeanFactory#createBean
  
    
  


createBean


resolveBeanClass
这一步骤用于锁定bean class，在没有显示指定beanClass的情况下，使用className加载beanClass
验证method overrides
==在BeanDefinitionReader 中有提到过lookup-method及replace-method，该步骤是为了确认以上两种配置中的method是否存在==
执行InstantiationAwareBeanPostProcessor前处理器(postProcessBeforeInstantiation)
如果这个步骤中生成了&quot;代理&quot;bean instance，则会有一个短路操作，直接返回该bean instance而不再执行doCreate，其中的核心逻辑为调用this.applyBeanPostProcessorsBeforeInstantiation() ^fcb215



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


try {
    // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
    Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
    if (bean != null) {
          // 如果这里生成了代理的bean instance会直接返回
        return bean;
    }
} cache (Throwable ex) { // throw exception }

try {
  // 创建bean instance
  Object beanInstance = doCreateBean(beanName, mbdToUse, args);
  // ...
}


doCreateBean (AbstractAutowireCapableBeanFactory)
真正bean的创建及初始化过程在此处实现

doCreateBean
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86


protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {  
    BeanWrapper instanceWrapper = null;  
    if (mbd.isSingleton()) {  
        instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName);  
    }  
  
    if (instanceWrapper == null) {  
        instanceWrapper = this.createBeanInstance(beanName, mbd, args);  
    }  
  
    Object bean = instanceWrapper.getWrappedInstance();  
    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();  
    if (beanType != NullBean.class) {  
        mbd.resolvedTargetType = beanType;  
    }  
  
    synchronized(mbd.postProcessingLock) {  
        if (!mbd.postProcessed) {  
            try {  
                this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);  
            } catch (Throwable var17) {  
                throw new BeanCreationException(mbd.getResourceDescription(), beanName, &#34;Post-processing of merged bean definition failed&#34;, var17);  
            }  
  
            mbd.markAsPostProcessed();  
        }  
    }  
  
    boolean earlySingletonExposure = mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; this.isSingletonCurrentlyInCreation(beanName);  
    if (earlySingletonExposure) {  
        if (this.logger.isTraceEnabled()) {  
            this.logger.trace(&#34;Eagerly caching bean &#39;&#34; &#43; beanName &#43; &#34;&#39; to allow for resolving potential circular references&#34;);  
        }  
  
        this.addSingletonFactory(beanName, () -&gt; {  
            return this.getEarlyBeanReference(beanName, mbd, bean);  
        });  
    }  
  
    Object exposedObject = bean;  
  
    try {  
        this.populateBean(beanName, mbd, instanceWrapper);  
        exposedObject = this.initializeBean(beanName, exposedObject, mbd);  
    } catch (Throwable var18) {  
        if (var18 instanceof BeanCreationException bce) {  
            if (beanName.equals(bce.getBeanName())) {  
                throw bce;  
            }  
        }  
  
        throw new BeanCreationException(mbd.getResourceDescription(), beanName, var18.getMessage(), var18);  
    }  
  
    if (earlySingletonExposure) {  
        Object earlySingletonReference = this.getSingleton(beanName, false);  
        if (earlySingletonReference != null) {  
            if (exposedObject == bean) {  
                exposedObject = earlySingletonReference;  
            } else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; this.hasDependentBean(beanName)) {  
                String[] dependentBeans = this.getDependentBeans(beanName);  
                Set&lt;String&gt; actualDependentBeans = new LinkedHashSet(dependentBeans.length);  
                String[] var12 = dependentBeans;  
                int var13 = dependentBeans.length;  
  
                for(int var14 = 0; var14 &lt; var13; &#43;&#43;var14) {  
                    String dependentBean = var12[var14];  
                    if (!this.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {  
                        actualDependentBeans.add(dependentBean);  
                    }  
                }  
  
                if (!actualDependentBeans.isEmpty()) {  
                    throw new BeanCurrentlyInCreationException(beanName, &#34;Bean with name &#39;&#34; &#43; beanName &#43; &#34;&#39; has been injected into other beans [&#34; &#43; StringUtils.collectionToCommaDelimitedString(actualDependentBeans) &#43; &#34;] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using &#39;getBeanNamesForType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&#34;);  
                }  
            }  
        }  
    }  
  
    try {  
        this.registerDisposableBeanIfNecessary(beanName, bean, mbd);  
        return exposedObject;  
    } catch (BeanDefinitionValidationException var16) {  
        throw new BeanCreationException(mbd.getResourceDescription(), beanName, &#34;Invalid destruction signature&#34;, var16);  
    }  
}

可以将该流程细分为如下：

[创建Bean实体](#创建Bean实体 AbstractAutowireCapableBeanFactory createBeanInstance &ldquo;wikilink&rdquo;)
[BeanDefinition后处理](#BeanDefinition后处理 - AbstractAutowireCapableBeanFactory applyMergedBeanDefinitionPostProcessors &ldquo;wikilink&rdquo;)
提前暴露实体
[属性注入](#属性注入 - AbstractAutowireCapableBeanFactory populateBean &ldquo;wikilink&rdquo;)
[初始化](#初始化 - AbstractAutowireCapableBeanFactory initializeBean &ldquo;wikilink&rdquo;)
[注册Disposable](#注册Disposable - AbstractBeanFactory registerDisposableBeanIfNecessary &ldquo;wikilink&rdquo;)

创建Bean实体 - AbstractAutowireCapableBeanFactory#createBeanInstance
  
    
  


createBeanInstance_2


instanceSupplier
从上面的流程图可以看出，创建bean实体不一定会使用到构造函数，可以使用Supplier的方式
factory method
工厂模式
@Configuration &#43; @Bean的实现方式就是factory-bean &#43; factory-method
[对应的参数获取](#ConstructorResolver resolvePreparedArguments &ldquo;wikilink&rdquo;)
有参构造函数
AbstractAutowireCapableBeanFactory#autowireConstructor -&gt; [ConstructorResolver#autowireConstructor](#**ConstructorResolver autowireConstructor** &ldquo;wikilink&rdquo;)
无参构造函数
与有参构造创建过程一致，除了不需要参数的依赖注入，使用默认无参构造函数进行实例化

ConstructorResolver#resolvePreparedArguments
  
    
  
使用指定（类）bean的（静态）方法创建bean实体的逻辑在ConstructorResolver#instantiate(String, RootBeanDefinition, Object, Method, args)，而真正的逻辑在SimpleInstantiationStrategy#instantiate(RootBeanDefinition, String, BeanFactory, Object, Method, Object&hellip;)，其核心的执行逻辑非常简单，有了方法factoryMethod(factoryBean)及入参args，便可以调用该方法创建bean实体


1


Object result = factoryMethod.invoke(factoryBean, args);

factoryBean可以通过beanFactory.getBean获取到（正是当前在讲的逻辑），factoryMethod可以通过反射获取到，而入参args就从ConstructorResolver#resolvePreparedArguments中获取，即是Spring中依赖注入的核心实现
该函数的作用是将BeanDefinition中定义的入参转换为需要的参数(==将BeanDefinitionReader中封装的对象转换==)


resolvePreparedArguments

More in blogs
ConstructorResolver#autowireConstructor
  
    
  
同样的，调用ConstructorResolver#resolvePreparedArguments进行参数的解析和转换(参数的依赖注入)，然后调用 [ConstructorResolver#instantiate](#ConstructorResolver instantiate &ldquo;wikilink&rdquo;) 来创建Bean实例
ConstructorResolver#instantiate
  
    
  
内部并没有统一利用反射技术直接使用构造函数创建，而是通过InstantiationStrategy.instantiate进行创建


Instantiate


没有设置override-method时，直接使用构造函数创建
设置了override-method时，使用cglib技术构造代理类，并代理override方法

Spring默认的实例化策略为CglibSubclassingInstantiationStrategy
BeanDefinition后处理 - AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors
  
    
  
在属性注入之前提供一次机会来对BeanDefinition进行处理，内部执行所有注册MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition方法

[!hint] MergedBeanDefinitionPostProcessor
MergedBeanDefinitionPostProcessor 是一个特定类型的 BeanPostProcessor。MergedBeanDefinitionPostProcessor 的 postProcessMergedBeanDefinition 方法允许在实例化bean之后但在设置bean属性之前，对bean的定义（BeanDefinition）进行后处理。这个阶段是用于修改或增强bean定义的，例如，可以解析注解并相应地修改 BeanDefinition 的属性。

对于MergedBeanDefinitionPostProcessor的实现类AutowiredAnnotationBeanPostProcessor，其内部方法AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata 实现了两个注解类的解析 @Value 及 @Autowired ，找到注解修饰的Filed或者Method并缓存，具体逻辑在[属性注入](#属性注入 - AbstractAutowireCapableBeanFactory populateBean &ldquo;wikilink&rdquo;) ^autowiredAnnotationBeanPostProcessor1
提前暴露实体
  
    
  
通过将AbstractAutowireCapableBeanFactory#getEarlyBeanReference封装为ObjectFactory，调用DefaultSingletonBeanRegistry#addSingletonFactory，将该ObjectFactory缓存在DefaultSingletonBeanRegistry.singletonFactories中，在getBean逻辑中的getSingleton会执行ObjectFactory将singleton提前暴露
==此处即为何时添加ObjectFactory进入singletonFactories中，解决循环依赖==

此时暴露的singleton-bean仅完成了bean的实例化，属性注入、初始化等逻辑均暂未执行

属性注入 - AbstractAutowireCapableBeanFactory#populateBean
  
    
  
在[创建Bean实体](#创建Bean实体 - AbstractAutowireCapableBeanFactory createBeanInstance &ldquo;wikilink&rdquo;)中介绍了factory method方式及有参构造函数方式的参数注入逻辑，除此之外还有一种注入便是属性注入


populateBean

流程中出现了两次InstantiationAwareBeanPostProcessor，在第一次出现中调用的postProcessorAfterInstantiation也与前面的InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation相同，拥有短路操作：如果该步骤生成了&quot;代理&quot;bean instance，直接返回该bean instance而不再执行后续的doCreate；如果有任意一个InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation方法返回false，则会跳出属性注入的逻辑，官方对此的解释如下

Give any InstantiationAwareBeanPostProcessors the opportunity to modify the state of the bean before properties are set. This can be used, for example, to support styles of field injection.

autowireByName及autowireByType方法作为&quot;候补&quot;补充BeanDefinition的propertyValues
PropertyValue中记录了需要注入的属性信息及需要注入的属性值，那BeanDefinition的propertyValues都来自哪里？xml中的bean配置、自定义的BeanDefinition等
通过注解修饰的属性(方法)通过InstantiationAwareBeanPostProcessor#postProcessProperties进行注入 -&gt; ==AutowiredAnnotationBeanPostProcessor#postProcessProperties &amp; CommonAnnotationBeanPostProcessor#postProcessProperties==
最后，通过AbstractAutowireCapableBeanFactory#applyPropertyValues 将PropertyValue中记录的需要注入的属性，已经依赖的类型（String、RuntimeBeanReference、等），根据不同的类型解析依赖的bean并设置到对应的属性上（==此过程与DefaultListableBeanFactory#doResolveDependency相似==）
初始化 - AbstractAutowireCapableBeanFactory#initializeBean
  
    
  
以上，完成了bean实例的创建和属性注入，之后还有一些初始化的方法，比如各种Aware的setXxx是如何调用的、@PostConstruct是怎么调用的？


initializeBean

注册Disposable - AbstractBeanFactory#registerDisposableBeanIfNecessary
  
    
  
至此，终于完成了bean实例的创建、属性注入以及之后的初始化，此后便可以开始使用了
在使用Spring的过程中经常还会碰到设置销毁逻辑的情况，如数据库连接池、线程池等等，在Spring销毁bean的时候还需要做一些处理，类似于C&#43;&#43;中的析构
在bean的创建逻辑中，最后一个步骤则是注册bean的销毁逻辑（DisposableBean）
销毁逻辑的注册有几个条件

非prototype（singleton或者注册的scope）
非NullBean
指定了destroy-method（如xml中指定或者BeanDefinition中直接设置）或者存在**@PreDestroy** 注解的方法（CommonAnnotationBeanPostProcessor.requiresDestruction）



1


if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd))

满足以上条件的bean会被封装为DisposableBeanAdapter，并注册在DefaultSingletonBeanRegistry.disposableBeans中
加载prototype bean实例
  
    
  


1
2
3
4
5
6
7
8
9


else if (mbd.isPrototype()) {
    Object prototypeInstance = null;
    try {
        beforePrototypeCreation(beanName);
        prototypeInstance = createBean(beanName, mbd, args);
    }
    finally { afterPrototypeCreation(beanName);    }
    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
}

prototype bean的创建与singleton bean类似，只是不会缓存创建完成的bean
加载其他scope bean实例
  
    
  
scope，即作用域，或者可以理解为生命周期
上文介绍了singleton-bean及prototype-bean的创建过程，严格意义上讲以上两种都是一种特殊的scope-bean，分别对应ConfigurableBeanFactory#SCOPE_SINGLETON及ConfigurableBeanFactory#SCOPE_PROTOTYPE，前者作用域为整个IOC容器，也可理解为单例，后者作用域为所注入的bean，每次注入(每次触发getBean)都会重新生成
Spring中还提供很多其他的scope，如WebApplicationContext#SCOPE_REQUEST或WebApplicationContext#SCOPE_SESSION，前者作用域为一次web request，后者作用域为一个web session周期
自定义scope的bean实例创建过程与singleton bean的创建过程十分相似，需要实现Scope的get方法(org.springframework.beans.factory.config.Scope#get)


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


else {
    String scopeName = mbd.getScope();
    final Scope scope = this.scopes.get(scopeName);
    if (scope == null) { /* throw exception */ }
    try {
        Object scopedInstance = scope.get(beanName, () -&gt; {
            beforePrototypeCreation(beanName);
            // createBean被封装在Scope#get函数的lambda参数ObjectFactory中
            try { return createBean(beanName, mbd, args); }
            finally { afterPrototypeCreation(beanName); }
        });
        bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
    } catch (IllegalStateException ex) { /* throw exception */}
}

Scope接口除了get方法之外，还有一个remove方法，前者用于定义bean的初始化逻辑，后者用于定义bean的销毁逻辑


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


public interface Scope {
  /**
   * Return the object with the given name from the underlying scope
   */
  Object get(String name, ObjectFactory&lt;?&gt; objectFactory);
  
   /**
   * Remove the object with the given name from the underlying scope.
   */
  Object remove(String name);
}

WebApplicationContext#SCOPE_SESSION对应的Scope实现见org.springframework.web.context.request.SessionScope
WebApplicationContext#SCOPE_REQUEST对应的Scope实现见org.springframework.web.context.request.RequestScope
以上两种Scope实现都较为简单，前者将初始化的bean存储在request attribute中，后者将初始化的bean存储在http session中
尝试类型转换
  
    
  
以上，完成了bean的创建、属性的注入、dispose逻辑的注册，但获得的bean类型与实际需要的类型可能依然不相符，在最终交付bean之前（getBean）还需要进行一次类型转换，使用PropertyEditor进行类型转换，将bean转换为真正需要的类型后，便完成了整个getBean的使命
Bean销毁过程
  
    
  
bean的创建过程始于DefaultListableBeanFactory#getBean，销毁过程则终于ConfigurableApplicationContext#close，跟踪下去，具体的逻辑在DefaultSingletonBeanRegistry#destroySingletons

DefaultSingletonBeanRegistry.disposableBeans
需要注册销毁逻辑的bean会被封装为DisposableBeanAdapter并缓存在此处
DefaultSingletonBeanRegistry.dependentBeanMap
对于存在依赖注入关系的bean，会将bean的依赖关系缓存在此处（dependentBeanMap: 哪些bean依赖了我; dependenciesForBeanMap: 我依赖了哪些bean）



destory

从上图中可以看出，bean的销毁顺序与创建顺序正好相反，如果有 beanA &ndash;dependsOn&ndash;&gt; beanB &ndash;&gt; beanC ，创建（getBean）时一定是beanC -&gt; beanB -&gt; beanA，销毁时一定是 beanA -&gt; beanB -&gt; beanC，以此避免因为依赖关系造成的一些异常情况
循环依赖
  
    
  
earlySingletonObject是用来解决循环依赖的问题，具体时机是在实例化完后属性注入之前，会提前将当前的bean实体暴露出来，以防止在属性注入过程中所注入的bean又依赖当前的bean造成的类似&quot;死锁&quot;的状态
但是存在以下情况，Spring依旧会陷入循环依赖死锁：

显式设置dependsOn的循环依赖



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


@DependsOn(&#34;beanB&#34;)
@Component
public class BeanA {}

@DependsOn(&#34;beanC&#34;)
@Component
public class BeanB {}

@DependsOn(&#34;beanA&#34;)
@Component
public class BeanC {}


构造函数循环依赖



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17


@Component
public class BeanA {
    public BeanA(BeanB beanB) {
    }
}

@Component
public class BeanB {
    public BeanB(BeanC beanC) {
    }
}

@Component
public class BeanC {
    public BeanC(BeanA beanA) {
    }
}


factory-method循环依赖



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14


@Bean
public BeanA beanA(BeanB beanB) {
    return new BeanA();
}

@Bean
public BeanB beanB(BeanC beanC) {
    return new BeanB();
}

@Bean
public BeanC beanC(BeanA beanA) {
    return new BeanC();
}


上述三种依赖混合

只要一个循环依赖中的所有bean，其依赖关系都需要在创建bean实例之前进行解决，此循环依赖则一定无解
要打破无解的循环依赖，在构成循环依赖的一个环中，只需要保证其中至少一个Bean的依赖在该Bean创建且暴露earlySingleton之后处理即可，即在属性注入阶段进行属性依赖的处理


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16


@Component
public class BeanA {
    @Autowired
    private BeanB beanB;
}

@Component
public class BeanB {
    public BeanB(BeanC beanC) {
    }
}

@Bean
public BeanC beanC(BeanA beanA) {
    return new BeanC();
}

以&quot;bean创建且暴露earlySingleton&quot;为节点，在此之前处理依赖的有instance supplier parameter、factory method parameter、constructor parameter、等，在此之后处理的依赖有 class property、setter parameter等
ApplicationContext
  
    
  
BeanFactory实现了IoC的基础能力，而ApplicationContext是BeanFactory的子类，除了继承IoC的基础能力外

支持国际化 (MessageSource)
支持资源访问 (ResourcePatternResolver)
事件机制 (ApplicationEventPublisher)
默认初始化所有Singleton
提供扩展能力



ApplicationContext

无论何种功能的ApplicationContext，在做完基本的初始化后均会调用AbstractApplicationContext#Refresh
AbstractApplicationContext#Refresh
  
    
  


refresh

准备上下文 - AbstractApplicationContext#prepareRefresh
  
    
  
该部分主要实现对上下文的准备工作，其主要涉及到两个接口AbstractApplicationContext#initPropertySources及ConfigurablePropertyResolver#validateRequiredProperties，前者由子类实现，用于初始化PropertySource；后者用于对必要属性进行验证


1
2
3
4
5
6
7


public class MyClasspathXmlApplicationContext extends ClassPathXmlApplicationContext {
    @Override
    protected void initPropertySources() {
        super.initPropertySources();
        getEnvironment().setRequiredProperties(&#34;runtimeEnv&#34;);
    }
}

重写initPropertySources方法，并添加runtimeEnv为必须的环境变量属性，如此在系统启动的时候便会进行检测，对于不存在任何一个必要环境变量的情况均会抛出异常终止启动
加载BeanFactory - AbstractApplicationContext#obtainFreshBeanFactory
  
    
  
该函数内部实现比较简单，重点在refreshBeanFactory，该函数同样由子类实现
对于AbstractRefreshableApplicationContext，refreshBeanFactory基本步骤为

创建BeanFactory (DefaultListableBeanFactory)
设置BeanFactory
加载BeanDefinition

在第3步中，AbstractXmlApplicationContext的实现则是对xml配置文件的解析及加载；AnnotationConfigWebApplicationContext的实现则是对class文件的扫描并加载，以及其他基于AbstractRefreshableApplicationContext的ApplicationContext实现
对于GenericApplicationContext，BeanFactory的创建及BeanDefinition的加载在refresh调用之前早已完成，refreshBeanFactory的实现则是对BeanFactory加载状态的简单校验
AbstractRefreshableApplicationContext &amp; GenericApplicationContext
  
    
  
AbstractRefreshableApplicationContext
  
    
  
对于继承自 AbstractRefreshableApplicationContext 的上下文，例如 ClassPathXmlApplicationContext 或 AnnotationConfigApplicationContext，它们通过覆盖 refreshBeanFactory() 方法来实现具体的 BeanDefinition 加载逻辑。这些上下文类型专门用于从外部资源（如 XML 文件、Java 配置类等）加载配置信息，并将这些配置信息解析为一组 BeanDefinition，然后注册到内部的 BeanFactory 中。这个过程通常发生在上下文的 refresh() 方法调用过程中（我们正在讨论的），这个方法不仅负责加载和注册 BeanDefinition，还包括初始化单例bean、处理别名定义、注册BeanPostProcessor等一系列容器启动时的活动。

[!QUOTE] refresh()关键步骤 ^configurerRelated

创建 BeanFactory：AbstractRefreshableApplicationContext 首先会创建一个新的 BeanFactory 实例，这通常是一个 DefaultListableBeanFactory 实例。这个 BeanFactory 实现了 BeanDefinitionRegistry 接口，使得它能够注册 BeanDefinition。
==加载 BeanDefinition：接着，上下文会调用特定的方法（例如，对于基于 XML 的配置，会使用 XmlBeanDefinitionReader；对于基于注解的配置，会使用 AnnotatedBeanDefinitionReader 和 ClassPathBeanDefinitionScanner）来加载 BeanDefinition。这些 Reader 和 Scanner 实现了 BeanDefinitionRegistry 接口的 registerBeanDefinition 方法来实际完成注册工作。==
刷新 BeanFactory：加载完所有 BeanDefinition 后，AbstractRefreshableApplicationContext 会对 BeanFactory 进行刷新，这涉及到预实例化单例、注册 BeanPostProcessor、初始化剩余的非懒加载单例等一系列操作。
发布事件：在整个容器刷新过程中，还会发布各种应用事件，如 ContextRefreshedEvent，允许应用中的其他组件对这些事件作出响应。

通过上述步骤，AbstractRefreshableApplicationContext 完成了 BeanDefinition 的加载、注册以及整个 Spring 容器的初始化和刷新工作。在这个过程中，BeanDefinitionRegistry 接口扮演了 BeanDefinition 注册的关键角色
GenericApplicationContext
  
    
  

GenericApplicationContext 直接实现了 BeanDefinitionRegistry 接口，使得它可以在运行时动态注册 BeanDefinition。与 AbstractRefreshableApplicationContext 的子类不同，GenericApplicationContext 并不专门依赖于外部资源来加载 BeanDefinition。相反，它提供了一套程序化的接口，允许开发者直接在代码中通过调用 registerBeanDefinition(String beanName, BeanDefinition beanDefinition) 方法来注册 BeanDefinition。这种方式使得 GenericApplicationContext 非常灵活，适用于那些需要在运行时动态调整 Spring 配置的场景。
关系和区别
  
    
  

加载方式的区别：AbstractRefreshableApplicationContext 的子类通常通过解析配置资源（XML、注解等）来加载 BeanDefinition，而 GenericApplicationContext 允许以编程方式直接注册 BeanDefinition。
使用场景的区别：AbstractRefreshableApplicationContext 的子类适合于静态配置资源的场景，其中配置信息在应用启动时已经确定。GenericApplicationContext 更适合于动态配置的场景，比如基于条件的 BeanDefinition 注册或运行时的配置调整。
刷新容器的能力：虽然两者都可以通过 refresh() 方法来刷新应用上下文，但 AbstractRefreshableApplicationContext 的子类通常在设计时就考虑了完整的容器刷新流程（包括重新加载配置资源），而 GenericApplicationContext 刷新主要是为了应用新注册的 BeanDefinition。==前者会重置BeanFactory而后者不会==

填充部分扩展 - AbstractApplicationContext#prepareBeanFactory
  
    
  
该函数执行以下逻辑

设置BeanFactory的ClassLoader
注册默认BeanExpressionResolver，用于依赖注入时SpEL的支持
注册默认PropertyEditor，用于依赖注入时对参数的解析转换
注册几个特殊Aware的处理逻辑
注册AspectJ相关的几个处理器，用于AOP的支持
注册几个特殊的BeanDefinition

==2-3 的核心逻辑在于解析依赖的值，DefaultListableBenFactory#doResolveDependency==
注册几个特殊Aware的处理逻辑
  
    
  
在Bean实例化、注入依赖之后会对Bean进行[最后的初始化](#初始化 - AbstractAutowireCapableBeanFactory initializeBean &ldquo;wikilink&rdquo;)，调用相应的setter方法分别针对BeanNameAware、BeanClassLoaderAware、BeanFactoryAware进行处理
在该函数中，会注册几个特殊的BeanPostProcessor


1


beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));

其实现了postProcessBeforeInitialization方法，内部调用ApplicationContextAwareProcessor#invokeAwareInterfaces针对另外的几类Aware进行了处理
除此之外，Spring会将上述几类Aware设置为ignoreDependencyInterface，这意味着以上几类Bean的注入只能通过Aware的方式而不能通过其他属性依赖注入的方式（属性注入、函数参数注入等）
注册特殊的Bean
  
    
  
在使用Spring时，是否有过直接注入BeanFactory亦或是ResourceLoader，这些bean正是在这里被Spring注册进去的，除以上外Spring还注入了

BeanFactory
ResourceLoader
ApplicationEventPublisher
ApplicationContext
Environment
systemProperties - Environment#.getSystemProperties:Map&lt;String, Object&gt;
systemEnvironment - Environment#.getSystemEnvironment:Map&lt;String, Object&gt;
AbstractApplicationContext#refresh#postProcessBeanFactory()
  
    
  


对于不同的实现类，注册相应的BeanPostProcessor，例如ServletWebServerApplicationContext
激活BeanFactoryPostProcessor - AbstractApplicationContext#invokeBeanFactoryPostProcessors
  
    
  
其内部实现在PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors
BeanFactoryPostProcessor的定义非常简单，其postProcessBeanFactory方法允许在bean实例化前对BeanFactory做一些额外的设置


1
2
3
4
5
6
7
8
9


public interface BeanFactoryPostProcessor {
    /**
     * Modify the application context&#39;s internal bean factory after its standard
     * initialization. All bean definitions will have been loaded, but no beans
     * will have been instantiated yet. This allows for overriding or adding
     * properties even to eager-initializing beans.
     */
    void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;
}

核心逻辑如下


invokeBeanFactoryPostProcessors

其中涉及两种类型，BeanDefinitionRegistryPostProcessor及BeanFactoryPostProcessor，前者为后者的子类，BeanDefinitionRegistryPostProcessors提供了额外的接口postProcessBeanDefinitionRegistry，用于更加方便地动态地注册额外的BeanDefinition (registryProcessor.postProcessBeanDefinitionRegistry(registry))，如读取配置文件（json、properties、yml）并解析（或者任何其他的形式），并通过该接口注册相应的BeanDefinition，基于Spring Boot Starter的很多框架均使用该方式进行bean的注册
以上流程图可以看出，优先执行BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry，再执行BeanFactoryPostProcessor#postProcessBeanFactory，各自内部优先执行PriorityOrdered实现，再执行Ordered实现，最后执行无任何排序的实现
注册BeanPostProcessor - AbstractApplicationContext#registerBeanPostProcessors
  
    
  
其内部实现在PostProcessorRegistrationDelegate#registerBeanPostProcessors
b
BeanPostProcessor
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23


public interface BeanPostProcessor {
    /**
     * Apply this BeanPostProcessor to the given new bean instance before any bean
     * initialization callbacks (like InitializingBean&#39;s afterPropertiesSet
     * or a custom init-method). 
     * The returned bean instance may be a wrapper around the original.
     */
    @Nullable
    default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }

    /**
     * Apply this BeanPostProcessor to the given new bean instance after any bean
     * initialization callbacks (like InitializingBean&#39;s afterPropertiesSet
     * or a custom init-method).
     * The returned bean instance may be a wrapper around the original.
     */
    @Nullable
    default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }
}


postProcessBeforeInitialization方法在调用bean的init-method之前执行
postProcessAfterInitialization方法在调用bean的init-method之后执行
任何一个方法可对现有bean实例做进一步的修改
任何一个方法可返回新的bean实例，用来替代现有的bean实例

第四点即是AOP生成当前Bean代理的方法
InstantiationAwareBeanPostProcessor
  
    
  
该接口继承自BeanPostProcessor，其同样有两个方法，一个在创建bean实例之前调用([createBean](#AbstractAutowireCapableBeanFactory createBean &ldquo;wikilink&rdquo;))，一个在创建bean实例之后、属性注入之前调用([属性注入](#属性注入 - AbstractAutowireCapableBeanFactory populateBean &ldquo;wikilink&rdquo;))


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15


public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor {  
    @Nullable  
    default Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException {  
        return null;  
    }  
  
    default boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {  
        return true;  
    }  
  
    @Nullable  
    default PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException {  
        return pvs;  
    }  
}

AbstractApplicationContext#registerBeanPostProcessors，其内部逻辑与BeanFactoryPostProcessor的注册逻辑类似：

找到所有BeanPostProcessor并实例化
按照实现的Ordered接口分别放入priorityOrderedPostProcessors、orderedPostProcessors、nonOrderedPostProcessors并各自排序
如果实现了MergedBeanDefinitionPostProcessor则放入internalPostProcessors并排序
按顺序依次注册priorityOrderedPostProcessors、orderedPostProcessors、nonOrderedPostProcessors
最后注册internalPostProcessors

MergedBeanDefinitionPostProcessor其有一个接口postProcessMergedBeanDefinition，在bean实例化完成后属性注入之前被调用，可以用来对当前的BeanDefinition做进一步的修改，如增加PropertyValue等，实现特殊的属性依赖注入，参考[BeanDefinition后处理](#BeanDefinition后处理 - AbstractAutowireCapableBeanFactory applyMergedBeanDefinitionPostProcessors &ldquo;wikilink&rdquo;)与[属性注入](#属性注入 - AbstractAutowireCapableBeanFactory populateBean &ldquo;wikilink&rdquo;)
初始化MessageSource - AbstractApplicationContext#initMessageSource
  
    
  
Spring的MessageSource提供了国际化能力，在开发者未注册MessageSource的情况下Spring会提供一个默认的DelegatingMessageSource
初始化ApplicationEventMulticaster - AbstractApplicationContext#initApplicationEventMulticaster
  
    
  
Spring提供了一套事件（ApplicationEvent）的发布&amp;订阅机制，开发者可自定义事件（继承ApplicationEvent），注册事件监听器来订阅消费事件（实现ApplicationListener 或使用@EventListener 注解），并使用ApplicationEventPublisher（直接依赖注入或者使用ApplicationEventPublisherAware）发送事件，使用示例可参考https://www.baeldung.com/spri&hellip;
其实ApplicationContext实现了ApplicationEventPublisher，跟踪其publishEvent方法会发现，最终调用了AbstractApplicationContext#applicationEventMulticaster.multicastEvent，开发者可以自行注册一个ApplicationEventMulticaster，如果没有Spring会提供一个默认的SimpleApplicationEventMulticaster
SimpleApplicationEventMulticaster#multicastEvent的逻辑比较简单，会根据事件的类型找到可以处理的所有ApplicationListener，依次调用它们的onApplicationEvent方法消费事件


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15


@Override
public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {
    ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
    Executor executor = getTaskExecutor();
    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {
        if (executor != null) {
      // 设置了executor，则异步执行
            executor.execute(() -&gt; invokeListener(listener, event));
        }
        else {
      // 否则同步执行
            invokeListener(listener, event);
        }
    }
}

默认情况下会同步、顺序的调用listeners的onApplicationEvent方法，只有设置了executor才会异步调用，不过这样的控制粒度比较粗，要么全部同步消费要么全部异步消费，比较细粒度的控制事件的消费有几种常用方法

使用@Async注解，独立控制某一listener异步消费（https://www.baeldung.com/spri&hellip;）
自行编码，将onApplicationEvent逻辑放在线程中执行
注册自定义的ApplicationEventMulticaster，内部实现自己的同步、异步Event处理逻辑

注册ApplicationListener - AbstractApplicationContext#registerListeners
  
    
  
这里的逻辑比较简单

在BeanFactory中找到ApplicationListener类型的bean并实例化
调用ApplicationEventMulticaster#addApplicationListenerBean方法将ApplicationListeners注册进去

初始化所有非Lazy Bean - AbstractApplicationContext#finishBeanFactoryInitialization
  
    
  
对于Singleton Bean而言，实例化发生在首次getBean，但你是否有疑惑，我们只是注册了众多Singleton Bean，但在Spring初始化完成后所有的Singleton Bean（Lazy Bean除外）均已经完成实例化
回到AbstractApplicationContext#finishBeanFactoryInitialization，该函数会实现几个逻辑

如果自定义了ConversionService(另一种注入类型转换的方式)类型bean且bean-name为conversionService，则将其注册到BeanFactory中
如果BeanFactory中不存在EmbeddedValueResolver（PropertyResourceConfigurer会注册一个PlaceholderResolvingStringValueResolver到BeanFactory中），则会注册一个默认的StringValueResolver用来处理 ${ ... }类型的值（Environment#resolvePlaceholders）
找到所有非Lazy的Singleton BeanDefinition进行实例化（getBean）

如果是FactoryBean，则在bean name前加上&rsquo;&amp;&rsquo;，并实例化该FactoryBean，随后实例化真实的bean
如果不是FactoryBean，则直接实例化该bean


执行SmartInitializingSingleton实现类的afterSingletonsInstantiated方法

Refresh的后续动作 - AbstractApplicationContext#finishRefresh
  
    
  
除了一些中间状态需要清理外，还有两件比较特殊的地方
LifecycleProcessor - AbstractApplicationContext#initLifecycleProcessor
  
    
  
Spring提供了LifecycleProcessor用于监听BeanFactory的refresh及close，在BeanFactory的各阶段会调用LifecycleProcessor的onFresh及onClose方法
开发者可以自行注册LifecycleProcessor类型的bean，bean-name必须为&quot;lifecycleProcessor&quot;，否则Spring会提供一个默认的DefaultLifecycleProcessor
之后则会触发LifecycleProcessor的onFresh方法

除此之外，还可以监听ContextRefreshedEvent及ContextClosedEvent消息

refresh事件
  
    
  
在BeanFactory初始化完成后，则会发出ContextRefreshedEvent事件
BeanFactory的销毁 - AbstractApplicationContext#registerShutdownHook
  
    
  
该函数用来注册BeanFactory的销毁逻辑


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13


public void registerShutdownHook() {  
    if (this.shutdownHook == null) {  
        this.shutdownHook = new Thread(&#34;SpringContextShutdownHook&#34;) {  
            public void run() {  
                synchronized(AbstractApplicationContext.this.startupShutdownMonitor) {  
                    AbstractApplicationContext.this.doClose();  
                }  
            }  
        };  
        Runtime.getRuntime().addShutdownHook(this.shutdownHook);  
    }  
  
}

其直接使用了java的addShutdownHook函数，在jvm进程正常退出的时候触发
AbstractApplicationContext#doClose函数定义了BeanFactory具体的销毁过程

发出ContextClosedEvent事件
触发LifecycleProcessor的onClose方法
销毁bean，细节参考Bean销毁过程
由子类实现的AbstractApplicationContext#closeBeanFactory及AbstractApplicationContext#onClose方法

ASIDE
  
    
  

BeanDefinition的加载在[AbstractApplicationContext#obtainFreshBeanFactory](#加载BeanFactory - AbstractApplicationContext obtainFreshBeanFactory &ldquo;wikilink&rdquo;)中实现
TODO

#{ ... }类型值的解析由StandardBeanExpressionResolve实现
${ ... }类型值的解析由PlaceholderResolvingStringValueResolver实现
Spring提供了众多默认的PropertyEditor，若需要自定义PropertyEditor可以通过注册CustomEditorConfigurer实现
Spring提供了众多Aware，若需要自定义Aware可以通过BeanPostProcessor实现
BeanFactoryPostProcessor用于在实例化bean之前对BeanFactory做额外的动作
如，PropertyResourceConfigurer用来将PlaceholderResolvingStringValueResolver注册到BeanFactory的embeddedValueResolvers中


[BeanDefinitionRegistryPostProcessor](#激活BeanFactoryPostProcessor - AbstractApplicationContext invokeBeanFactoryPostProcessors &ldquo;wikilink&rdquo;)用于在实例化bean之前（动态）注册额外的BeanDefinition ^fa1ce8
BeanPostProcessor用于在调用bean的init-method前后，对实例化完成的bean做一些额外的干预
如，CommonAnnotationBeanPostProcessor用来处理@PostConstructor，AbstractAdvisingBeanPostProcessor用来实现AOP

ApplicationContext具体实现类 - AnnotationConfigApplicationContext
  
    
  


1
2
3
4
5


public AnnotationConfigApplicationContext(Class&lt;?&gt;... componentClasses) { 
    this(); //1. 首先会调用自己的无参构造 
    register(componentClasses); //2. 然后注册我们传入的配置类 
    refresh(); //3. 最后进行刷新操作（关键） 
}

无参构造
  
    
  


1
2
3
4
5
6
7
8


public AnnotationConfigApplicationContext() {
        StartupStep createAnnotatedBeanDefReader = this.getApplicationStartup().start(&#34;spring.context.annotated-bean-reader.create&#34;);
      //创建AnnotatedBeanDefinitionReader对象，用于后续处理 @Bean 注解
        this.reader = new AnnotatedBeanDefinitionReader(this);
        createAnnotatedBeanDefReader.end();
      //创建ClassPathBeanDefinitionScanner对象，用于扫描类路径上的Bean
        this.scanner = new ClassPathBeanDefinitionScanner(this);
}

AnnotatedBeanDefinitionReader
  
    
  


1
2
3
4
5
6
7
8


public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
        Assert.notNull(registry, &#34;BeanDefinitionRegistry must not be null&#34;);
        Assert.notNull(environment, &#34;Environment must not be null&#34;);
        this.registry = registry;
        this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);
      //这里注册了注解处理配置相关的后置处理器
        AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
}

这里会将ConfigurationClassPostProcessor后置处理器加入到BeanFactory中，它继承自BeanFactoryPostProcessor，也就是说一会会在BeanFactory初始化完成之后进行后置处理，同时这里也会注册一个AutowiredAnnotationBeanPostProcessor后置处理器到BeanFactory，它继承自BeanPostProcessor，用于处理后续生成的Bean对象，其实看名字就知道，这玩意就是为了处理@Autowire、@Value这种注解，用于自动注入
注册传入的配置类 - register
  
    
  


1
2
3
4
5
6
7
8
9


@Override
public void register(Class&lt;?&gt;... componentClasses) {
        Assert.notEmpty(componentClasses, &#34;At least one component class must be specified&#34;);
        StartupStep registerComponentClass = this.getApplicationStartup().start(&#34;spring.context.component-classes.register&#34;)
                .tag(&#34;classes&#34;, () -&gt; Arrays.toString(componentClasses));
      //使用我们上面创建的Reader注册配置类
        this.reader.register(componentClasses);
        registerComponentClass.end();
}

[Refresh](#AbstractApplicationContext Refresh &ldquo;wikilink&rdquo;)
  
    
  
==TODO==
  
    
  

☒ Spring AOP
☐ 注解运行逻辑

@Component与@Bean的区别
JavaSSM#^473168
☐ @Bean 在处理属性注入时？


☒ AnnotationConfigApplicationContext - 与 配置类的关系 - 具体例子
☐ BeanDefinitionReader和BeanDefinitionRegistry
☐ 完善调用链图
配置类的注册 - ConfigurationClassPostProcessor
  
    
  


ConfigurationClassPostProcessor继承自BeanDefinitionRegistryPostProcessor -&gt; BeanFactoryPostProcessor，这个后置处理器是Spring中提供的，这是专门用于处理配置类的后置处理器，其中ImportBeanDefinitionRegistrar，还有ImportSelector都是靠它来处理
ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry
  
    
  
内部调用 processConfigBeanDefinitions(BeanDefinitionRegistry) 方法


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50


public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
    // 将Spring认为可能是配置类的候选类加入candidates，例如@Configuration、@Component
    // @ComponentScan、@Import，以及通过实现ImportSelector或ImportBeanDefinitionRegistrar间接引入的配置
    List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
    // 直接取出所有已注册Bean的名称
    String[] candidateNames = registry.getBeanDefinitionNames();
    for (String beanName : candidateNames) {
       // 依次拿到对应的Bean定义，然后进行判断
       BeanDefinition beanDef = registry.getBeanDefinition(beanName);
       if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) {
          ...
       }
       // 检查一个Bean定义是否符合作为配置类的条件，即使它没有直接使用@Configuration注解
       else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
          configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
       }
    }
    // 如果一个打了 @Configuration 的类都没发现，直接返回
    if (configCandidates.isEmpty()) {
       return;
    }
    // 对所有的配置类依据 @Order 进行排序
    configCandidates.sort((bd1, bd2) -&gt; {
       int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
       int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
       return Integer.compare(i1, i2);
    });
    ...
    // 这里使用do-while语句依次解析所有的配置类
    ConfigurationClassParser parser = new ConfigurationClassParser(
          this.metadataReaderFactory, this.problemReporter, this.environment,
          this.resourceLoader, this.componentScanBeanNameGenerator, registry);
    Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
    Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
    do {
       StartupStep processConfig = this.applicationStartup.start(&#34;spring.context.config-classes.parse&#34;);
       //这里就会通过Parser解析配置类中大部分内容，包括我们之前遇到的@Import注解
             parser.parse(candidates);
             parser.validate();
       //解析完成后读取到所有的配置类
       Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
             configClasses.removeAll(alreadyParsed);
       ... 
       //将上面读取的配置类加载为Bean
       this.reader.loadBeanDefinitions(configClasses);
       ...
    }
    while (!candidates.isEmpty());
    ...
}

ConfigurationClassParser#parse(candidates)
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25


public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) {
    for (BeanDefinitionHolder holder : configCandidates) {
        BeanDefinition bd = holder.getBeanDefinition();
        try {
            if (bd instanceof AnnotatedBeanDefinition annotatedBeanDef) {
                parse(annotatedBeanDef, holder.getBeanName());
            }
            else if (bd instanceof AbstractBeanDefinition abstractBeanDef &amp;&amp; abstractBeanDef.hasBeanClass()) {
                parse(abstractBeanDef.getBeanClass(), holder.getBeanName());
            }
            else {
                parse(bd.getBeanClassName(), holder.getBeanName());
            }
        }
        catch (BeanDefinitionStoreException ex) {
            throw ex;
        }
        catch (Throwable ex) {
            throw new BeanDefinitionStoreException(
                    &#34;Failed to parse configuration class [&#34; &#43; bd.getBeanClassName() &#43; &#34;]&#34;, ex);
        }
    }

    this.deferredImportSelectorHandler.process();
}

内部遍历candidates中的每一个BeanDefinitionHolder，调用parse的多态方法，最终调用ConfigurationClassParser#processConfigurationClass，最后调用deferredImportSelectorHandler.process()处理DeferredImportSelector相关的Bean注册 ^processConfigurationClass
首先判断条件注释，即处理@Conditional相关注解
然后将不同来源的配置类源信息通过asSourceClass进行封装，交给最核心的调用[doProcessConfigurationClass](#ConfigurationClassParser doProcessConfigurationClass &ldquo;wikilink&rdquo;)

将配置类ConfigurationClass实例化为SourceClass。这样做的目的是为了让后续的处理逻辑能够通过SourceClass访问到配置类中定义的所有相关信息（比如注解信息，Meta-info），并进行相应的处理。例如，通过SourceClass可以读取配置类上的@ComponentScan注解，并执行组件扫描；读取@Import注解，并处理导入的配置类或组件；读取@Bean方法，并注册对应的Bean定义等。

ConfigurationClassParser#doProcessConfigurationClass
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98


@Nullable
protected final SourceClass doProcessConfigurationClass(
        ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter)
        throws IOException {

    if (configClass.getMetadata().isAnnotated(Component.class.getName())) {
        // Recursively process any member (nested) classes first
        processMemberClasses(configClass, sourceClass, filter);
    }

    // Process any @PropertySource annotations
    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
            sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class,
            PropertySources.class, true)) {
        if (this.propertySourceRegistry != null) {
            this.propertySourceRegistry.processPropertySource(propertySource);
        }
        else {
            logger.info(&#34;Ignoring @PropertySource annotation on [&#34; &#43; sourceClass.getMetadata().getClassName() &#43;
                    &#34;]. Reason: Environment must implement ConfigurableEnvironment&#34;);
        }
    }

    // Search for locally declared @ComponentScan annotations first.
    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
            sourceClass.getMetadata(), ComponentScan.class, ComponentScans.class,
            MergedAnnotation::isDirectlyPresent);

    // Fall back to searching for @ComponentScan meta-annotations (which indirectly
    // includes locally declared composed annotations).
    if (componentScans.isEmpty()) {
        componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(),
                ComponentScan.class, ComponentScans.class, MergedAnnotation::isMetaPresent);
    }

    if (!componentScans.isEmpty()) {
        List&lt;Condition&gt; registerBeanConditions = collectRegisterBeanConditions(configClass);
        if (!registerBeanConditions.isEmpty()) {
            throw new ApplicationContextException(
                    &#34;Component scan could not be used with conditions in REGISTER_BEAN phase: &#34; &#43; registerBeanConditions);
        }
        for (AnnotationAttributes componentScan : componentScans) {
            // The config class is annotated with @ComponentScan -&gt; perform the scan immediately
            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
                    this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
            // Check the set of scanned definitions for any further config classes and parse recursively if needed
            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                if (bdCand == null) {
                    bdCand = holder.getBeanDefinition();
                }
                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
                    parse(bdCand.getBeanClassName(), holder.getBeanName());
                }
            }
        }
    }

    // Process any @Import annotations
    processImports(configClass, sourceClass, getImports(sourceClass), filter, true);

    // Process any @ImportResource annotations
    AnnotationAttributes importResource =
            AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
    if (importResource != null) {
        String[] resources = importResource.getStringArray(&#34;locations&#34;);
        Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&#34;reader&#34;);
        for (String resource : resources) {
            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
            configClass.addImportedResource(resolvedResource, readerClass);
        }
    }

    // Process individual @Bean methods
    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
    for (MethodMetadata methodMetadata : beanMethods) {
        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
    }

    // Process default methods on interfaces
    processInterfaces(configClass, sourceClass);

    // Process superclass, if any
    if (sourceClass.getMetadata().hasSuperClass()) {
        String superclass = sourceClass.getMetadata().getSuperClassName();
        if (superclass != null &amp;&amp; !superclass.startsWith(&#34;java&#34;)) {
            boolean superclassKnown = this.knownSuperclasses.containsKey(superclass);
            this.knownSuperclasses.add(superclass, configClass);
            if (!superclassKnown) {
                // Superclass found, return its annotation metadata and recurse
                return sourceClass.getSuperClass();
            }
        }
    }

    // No superclass -&gt; processing is complete
    return null;
}

该函数依次解决如下问题：

处理@Component注解
处理@PropertySource和@PropertySources注解
处理@ComponentScan和@ComponentScans
处理@Import注解
处理@ImportResource注解
处理@Bean注解的方法
处理接口上的默认方法和超类

其中的核心是处理@Import注解，通过调用 [ConfigurationClassParser#processImports](#ConfigurationClassParser processImports &ldquo;wikilink&rdquo;)
ConfigurationClassParser#processImports
  
    
  
注意其第三个入参Collection&lt;SourceClass&gt; importCandidates，它是通过调用getImports(sourceClass)方法，从给定的sourceClass中提取所有@Import注解指定的类，如果sourceClass是普通的配置类，直接通过isEmpty()返回


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63


private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
        Collection&lt;SourceClass&gt; importCandidates, Predicate&lt;String&gt; filter, boolean checkForCircularImports) {

    if (importCandidates.isEmpty()) {
        return;
    }

    if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) {
        this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
    }
    else {
        this.importStack.push(configClass);
        try {
            for (SourceClass candidate : importCandidates) {
                if (candidate.isAssignable(ImportSelector.class)) {
                    // Candidate class is an ImportSelector -&gt; delegate to it to determine imports
                    Class&lt;?&gt; candidateClass = candidate.loadClass();
                    ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class,
                            this.environment, this.resourceLoader, this.registry);
                    Predicate&lt;String&gt; selectorFilter = selector.getExclusionFilter();
                    if (selectorFilter != null) {
                        filter = filter.or(selectorFilter);
                    }
                    if (selector instanceof DeferredImportSelector deferredImportSelector) {
                        this.deferredImportSelectorHandler.handle(configClass, deferredImportSelector);
                    }
                    else {
                        String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                        Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames, filter);
                        processImports(configClass, currentSourceClass, importSourceClasses, filter, false);
                    }
                }
                else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
                    // Candidate class is an ImportBeanDefinitionRegistrar -&gt;
                    // delegate to it to register additional bean definitions
                    Class&lt;?&gt; candidateClass = candidate.loadClass();
                    ImportBeanDefinitionRegistrar registrar =
                            ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class,
                                    this.environment, this.resourceLoader, this.registry);
                    configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
                }
                else {
                    // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;
                    // process it as an @Configuration class
                    this.importStack.registerImport(
                            currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
                    processConfigurationClass(candidate.asConfigClass(configClass), filter);
                }
            }
        }
        catch (BeanDefinitionStoreException ex) {
            throw ex;
        }
        catch (Throwable ex) {
            throw new BeanDefinitionStoreException(
                    &#34;Failed to process import candidates for configuration class [&#34; &#43;
                    configClass.getMetadata().getClassName() &#43; &#34;]: &#34; &#43; ex.getMessage(), ex);
        }
        finally {
            this.importStack.pop();
        }
    }
}

代码遍历每一个@Import注解指定的候选类，根据不同类型进行处理

ImportSelector实现
ImportSelector
DeferredImportSelector
ImportBeanDefinitionRegistar实现
普通的配置类

针对ImportSelector
  
    
  
通过selector.selectImports()与asSourceClasses()方法将需要导入的类重新封装为SourceClass，递归调用processImports
针对DeferredImportSelector
  
    
  
通过调用ConfigurationClassParser的内部类DeferredImportSelectorHandler#handle()方法，将其封装为DeferredImportSelectorHolder ，加入待处理的List - deferredImportSelectors
在ConfigurationClassParser#parse[处理完所有候选配置类后](#ConfigurationClassParser parse(candidates) &ldquo;wikilink&rdquo;)，调用DeferredImportSelectorHandler#process()方法，该方法将加入deferredImportSelectors中的所有DeferredImportSelectorHolder执行内部类的DeferredImportSelectorGroupingHandler#register方法，得到包装好的、已经分组完毕的DeferredImportSelectorGrouping，然后调用DeferredImportSelectorGroupingHandler#processGroupImports()，处理组内所有的延迟导入 (DeferredImportSelector)
DeferredImportSelectorGroupingHandler#register
  
    
  


1
2
3
4
5
6
7
8
9


void register(DeferredImportSelectorHolder deferredImport) {
            Class&lt;? extends Group&gt; group = deferredImport.getImportSelector().getImportGroup();
            DeferredImportSelectorGrouping grouping = this.groupings.computeIfAbsent(
                    (group != null ? group : deferredImport),
                    key -&gt; new DeferredImportSelectorGrouping(createGroup(group)));
            grouping.add(deferredImport);
            this.configurationClasses.put(deferredImport.getConfigurationClass().getMetadata(),
                    deferredImport.getConfigurationClass());
        }


首先尝试获取DeferredImportSelector指定的导入组 (ImportGroup)，如果没有指定特定的导入组，则使用DeferredImportSelector本身作为组的Key
尝试从一个名为groupings的映射中获取或创建一个与导入组对应的DeferredImportSelectorGrouping对象。如果映射中尚未存在与当前组对应的分组，那么将创建一个新的分组，并将其加入到映射中

注意，此处的Group逻辑是将DeferredImportSelector.Group这个内部接口包装到ConfigurationClassParser.DeferredImportSelectorGourping这个内部类中，其内部维护了一个DeferredImportSelector.Group对象和List&lt;DeferredImportSelectorHolder&gt;对象


调用DeferredImportSelectGrouping#add(DeferredImportSelectorHolder)，将DeferredImportSelectorHolder加入内部类维护的Grouping中 (静态类)
最后，代码将当前DeferredImportSelectorHolder对应的配置类(ConfigurationClass)及其元数据添加到一个名为configurationClasses的映射中。这确保了后续能够快速访问到与特定DeferredImportSelector相关联的配置类

DeferredImportSelectorGroupingHandler#processGroupImports
  
    
  


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21


void processGroupImports() {
    for (DeferredImportSelectorGrouping grouping : this.groupings.values()) {
        Predicate&lt;String&gt; filter = grouping.getCandidateFilter();
        grouping.getImports().forEach(entry -&gt; {
            ConfigurationClass configurationClass = this.configurationClasses.get(entry.getMetadata());
            try {
                processImports(configurationClass, asSourceClass(configurationClass, filter),
                        Collections.singleton(asSourceClass(entry.getImportClassName(), filter)),
                        filter, false);
            }
            catch (BeanDefinitionStoreException ex) {
                throw ex;
            }
            catch (Throwable ex) {
                throw new BeanDefinitionStoreException(
                        &#34;Failed to process import candidates for configuration class [&#34; &#43;
                                configurationClass.getMetadata().getClassName() &#43; &#34;]&#34;, ex);
            }
        });
    }
}


遍历保存在Groups - DeferredImportSelectorGroupingHandler中的 DeferredImportSelectorGroup对象，调用 DeferredImportSelectorGroup#getImports()方法
DeferredImportSelectorGroup#getImports()方法调用DeferredImportSelectorGroup中维护的真实的Group - DeferredImportSelector.Group#process方法，然后返回含有meta-info的Entry
使用内部维护的Map(在register中put)，根据Entry.meta-info得到对应的ConfigurationClass ，调用ConfigurationClassParser#processImports，和[前面](#ConfigurationClassParser processImports &ldquo;wikilink&rdquo;)一样递归调用进行处理

所以根据以上分析，DeferredImportSelector最终的处理逻辑在于DeferredImportSelector.Group#process() ^db8805
针对ImportBeanDefinitionRegistar
  
    
  


1
2
3
4
5
6
7
8


public interface ImportBeanDefinitionRegistrar {  
    default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator) {  
        this.registerBeanDefinitions(importingClassMetadata, registry);  
    }  
  
    default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {  
    }  
}

调用ConfigurationClass#addImportBeanDefinitionRegistrar方法，将对应的实例加入configClass对应的Collection类中，后续在[loadBeanDefinitions](#ConfigurationClassBeanDefinitionReader loadBeanDefinitions &ldquo;wikilink&rdquo;)中调用其registerBeanDefinitions，注册相应的BeanDefinition
针对普通配置类
  
    
  
不使用特殊机制，直接递归调用processConfigurationClass
ConfigurationClassParser#getConfigurationClasses
  
    
  
返回从前面得到的所有待配置的配置类
ConfigurationClassBeanDefinitionReader#loadBeanDefinitions
  
    
  
^98f726


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33


public void loadBeanDefinitions(Set&lt;ConfigurationClass&gt; configurationModel) {
        TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator();
        for (ConfigurationClass configClass : configurationModel) {
            loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
        }
    }

/**
 * Read a particular {@link ConfigurationClass}, registering bean definitions
 * for the class itself and all of its {@link Bean} methods.
 */
private void loadBeanDefinitionsForConfigurationClass(
        ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {

    if (trackedConditionEvaluator.shouldSkip(configClass)) {
        String beanName = configClass.getBeanName();
        if (StringUtils.hasLength(beanName) &amp;&amp; this.registry.containsBeanDefinition(beanName)) {
            this.registry.removeBeanDefinition(beanName);
        }
        this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());
        return;
    }

    if (configClass.isImported()) {
        registerBeanDefinitionForImportedConfigurationClass(configClass);
    }
    for (BeanMethod beanMethod : configClass.getBeanMethods()) {
        loadBeanDefinitionsForBeanMethod(beanMethod);
    }

    loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
    loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
}

通过遍历每一个配置类，调用loadBeanDefinitionsForConfigurationClass方法 ^f6a27a

registerBeanDefinitionForImportedConfigurationClass(configClass)
注册配置类自身
loadBeanDefinitionsForBeanMethod(beanMethod)
注册@Bean注解标识的方法
loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
注册@ImportResource引入的XML配置文件中读取的bean定义
loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
注册configClass中经过解析后保存的所有ImportBeanDefinitionRegistrar，注册对应的BeanDefinition

AOP
  
    
  
AOP的实现类是AnnotationAwareAspectJAutoProxyCreator，其是BeanPostProcessor的实现类，具体来说，是InstantiationAwareBeanPostProcessor的实现类，在实例化Bean过程中，通过调用BeanPostProcessor中的实例化前处理器进行短路，得到相应的代理Bean
@EnableAspectJAutoProxy
  
    
  


1
2
3
4
5
6
7
8


@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import({AspectJAutoProxyRegistrar.class})
public @interface EnableAspectJAutoProxy {
    boolean proxyTargetClass() default false;
    boolean exposeProxy() default false;
}

这个注解使用@Import导入了AspectJAutoProxyRegistrar，其是ImportBeanDefinitionRegistrar的实现类，会在处理配置类相应@Import机制的时候将AnnotationAwareAspectJAutoProxyCreator实现类注册到容器中，即注册到BeanDefinition中，实现相应的实例化前处理器功能 (InstantiationAwareBeanPostProcessor)">
<meta name="application-name" content="FixIt?">
<meta name="apple-mobile-web-app-title" content="FixIt?"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" href="http://localhost:1313/posts/6e2a775/" /><link rel="prev" href="http://localhost:1313/posts/583bc6c/" /><link rel="next" href="http://localhost:1313/posts/0840a16/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Spring 主要源码分析",
    "inLanguage": "en",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "http:\/\/localhost:1313\/posts\/6e2a775\/"
    },"genre": "posts","keywords": "Java, Spring","wordcount":  26674 ,
    "url": "http:\/\/localhost:1313\/posts\/6e2a775\/","datePublished": "2024-05-13T11:26:20+08:00","dateModified": "2024-05-13T11:26:20+08:00","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "Shiping Guo"
      },"description": ""
  }
  </script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper" data-github-corner="right">
    <div class="header-title">
      <a href="/" title="Dionysun&#39;s Blog"><img loading="lazy" src="https://minio.dionysunrsshub.top/myimages/2024-img/avatar" alt="Dionysun&#39;s Blog" data-title="Dionysun&#39;s Blog" class="logo" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/><span class="typeit"><template>我的学习小站</template></span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a
                class="menu-link"
                href="/archives/"
                
                
              ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> Archives</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/categories/"
                
                
              ><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden="true"></i> Categories</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/tags/"
                
                
              ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> Tags</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title="Switch Theme">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="Dionysun&#39;s Blog"><img loading="lazy" src="https://minio.dionysunrsshub.top/myimages/2024-img/avatar" alt="https://minio.dionysunrsshub.top/myimages/2024-img/avatar" data-title="https://minio.dionysunrsshub.top/myimages/2024-img/avatar" class="logo" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/><span class="typeit"><template>我的学习小站</template></span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/archives/"
                  
                  
                ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> Archives</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/categories/"
                  
                  
                ><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden="true"></i> Categories</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/tags/"
                  
                  
                ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> Tags</a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title="Switch Theme"><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span></li>
      </ul>
    </nav>
  </div>
</header><main class="container"><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label="Collections"></aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span title="Repost" class="icon-repost"><i class="fa-solid fa-share fa-fw" aria-hidden="true"></i></span><span>Spring 主要源码分析</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><span class="author"><i class="fa-solid fa-user-circle" aria-hidden="true"></i>
      Shiping Guo</span></span><span class="post-included-in">&nbsp;included in <a href="/categories/java/" class="post-category" title="Category - Java"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> Java</a></span></div><div class="post-meta-line"><span title="published on 2024-05-13 11:26:20"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden="true"></i><time datetime="2024-05-13">2024-05-13</time></span>&nbsp;<span title="26674 words"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden="true"></i>About 26700 words</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden="true"></i>54 minutes</span>&nbsp;<span id="busuanzi_container_page_pv" class="busuanzi_visitors comment-visitors" data-flag-title="Spring 主要源码分析">
            <i class="fa-regular fa-eye fa-fw me-1" aria-hidden="true"></i><span id="busuanzi_value_page_pv">-</span>&nbsp;views
          </span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>Contents</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#beandefinition">BeanDefinition</a></li>
    <li><a href="#beanregistry">BeanRegistry</a></li>
  </ul>

  <ul>
    <li><a href="#beanfactory">BeanFactory</a>
      <ul>
        <li><a href="#defaultlistablebeanfactory---abstractbeanfactory">DefaultListableBeanFactory - AbstractBeanFactory</a>
          <ul>
            <li><a href="#dogetbean"><code>doGetBean</code></a>
              <ul>
                <li><a href="#bean-name的转换">Bean Name的转换</a></li>
                <li><a href="#尝试获取单例">尝试获取单例</a></li>
                <li><a href="#factorybean的处理sharedinstance存在的逻辑">FactoryBean的处理(sharedInstance存在的逻辑)</a>
                  <ul>
                    <li><a href="#getobjectbeaninstance">getObjectBeanInstance</a></li>
                    <li><a href="#factorybeanregistrysupportgetobjectfromfactorybean"><code>FactoryBeanRegistrySupport#getObjectFromFactoryBean</code></a></li>
                    <li><a href="#factorybeanregistrysupportdogetobjectfromfactorybean"><code>FactoryBeanRegistrySupport#doGetObjectFromFactoryBean</code></a></li>
                    <li><a href="#abstractautowirecapablebeanfactoryapplybeanpostprocessorafterinitialization"><code>AbstractAutowireCapableBeanFactory#applyBeanPostProcessorAfterInitialization</code></a></li>
                  </ul>
                </li>
                <li><a href="#加载bean实例-sharedinstance不存在的逻辑">加载Bean实例 (sharedInstance不存在的逻辑)</a>
                  <ul>
                    <li><a href="#beandefinition合并-rootbeandefinition">BeanDefinition合并 (RootBeanDefinition)</a></li>
                    <li><a href="#加载dependes-on-beans">加载dependes-On beans</a></li>
                    <li><a href="#加载singleton-bean实例">加载singleton bean实例</a></li>
                    <li><a href="#defaultsingletonbeanregistrygetsingletonstring-objectfactory"><code>DefaultSingletonBeanRegistry#getSingleton(String, ObjectFactory)</code></a></li>
                    <li><a href="#abstractautowirecapablebeanfactorycreatebean"><code>AbstractAutowireCapableBeanFactory#createBean</code></a></li>
                    <li><a href="#docreatebean"><code>doCreateBean</code></a></li>
                    <li><a href="#创建bean实体---abstractautowirecapablebeanfactorycreatebeaninstance">创建Bean实体 - <code>AbstractAutowireCapableBeanFactory#createBeanInstance</code></a></li>
                    <li><a href="#constructorresolverresolvepreparedarguments"><code>ConstructorResolver#resolvePreparedArguments</code></a></li>
                    <li><a href="#constructorresolverautowireconstructor"><code>ConstructorResolver#autowireConstructor</code></a></li>
                    <li><a href="#constructorresolverinstantiate"><code>ConstructorResolver#instantiate</code></a></li>
                    <li><a href="#beandefinition后处理---abstractautowirecapablebeanfactoryapplymergedbeandefinitionpostprocessors">BeanDefinition后处理 - <code>AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors</code></a></li>
                    <li><a href="#提前暴露实体">提前暴露实体</a></li>
                    <li><a href="#属性注入---abstractautowirecapablebeanfactorypopulatebean">属性注入 - <code>AbstractAutowireCapableBeanFactory#populateBean</code></a></li>
                    <li><a href="#初始化---abstractautowirecapablebeanfactoryinitializebean">初始化 - <code>AbstractAutowireCapableBeanFactory#initializeBean</code></a></li>
                    <li><a href="#注册disposable---abstractbeanfactoryregisterdisposablebeanifnecessary">注册Disposable - <code>AbstractBeanFactory#registerDisposableBeanIfNecessary</code></a></li>
                    <li><a href="#加载prototype-bean实例">加载prototype bean实例</a></li>
                    <li><a href="#加载其他scope-bean实例">加载其他scope bean实例</a></li>
                  </ul>
                </li>
                <li><a href="#尝试类型转换">尝试类型转换</a></li>
              </ul>
            </li>
            <li><a href="#bean销毁过程">Bean销毁过程</a></li>
            <li><a href="#循环依赖">循环依赖</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#abstractapplicationcontextrefresh"><code>AbstractApplicationContext#Refresh</code></a>
      <ul>
        <li><a href="#准备上下文---abstractapplicationcontextpreparerefresh">准备上下文 - <code>AbstractApplicationContext#prepareRefresh</code></a></li>
        <li><a href="#加载beanfactory---abstractapplicationcontextobtainfreshbeanfactory">加载BeanFactory - <code>AbstractApplicationContext#obtainFreshBeanFactory</code></a>
          <ul>
            <li><a href="#abstractrefreshableapplicationcontext--genericapplicationcontext">AbstractRefreshableApplicationContext &amp; GenericApplicationContext</a>
              <ul>
                <li><a href="#abstractrefreshableapplicationcontext">AbstractRefreshableApplicationContext</a></li>
                <li><a href="#genericapplicationcontext">GenericApplicationContext</a></li>
                <li><a href="#关系和区别">关系和区别</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#填充部分扩展---abstractapplicationcontextpreparebeanfactory">填充部分扩展 - <code>AbstractApplicationContext#prepareBeanFactory</code></a>
          <ul>
            <li><a href="#注册几个特殊aware的处理逻辑">注册几个特殊Aware的处理逻辑</a></li>
            <li><a href="#注册特殊的bean">注册特殊的Bean</a></li>
          </ul>
        </li>
        <li><a href="#abstractapplicationcontextrefreshpostprocessbeanfactory"><code>AbstractApplicationContext#refresh#postProcessBeanFactory()</code></a></li>
        <li><a href="#激活beanfactorypostprocessor---abstractapplicationcontextinvokebeanfactorypostprocessors">激活BeanFactoryPostProcessor - <code>AbstractApplicationContext#invokeBeanFactoryPostProcessors</code></a></li>
        <li><a href="#注册beanpostprocessor---abstractapplicationcontextregisterbeanpostprocessors">注册BeanPostProcessor - <code>AbstractApplicationContext#registerBeanPostProcessors</code></a>
          <ul>
            <li><a href="#beanpostprocessor">BeanPostProcessor</a>
              <ul>
                <li><a href="#instantiationawarebeanpostprocessor">InstantiationAwareBeanPostProcessor</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#初始化messagesource---abstractapplicationcontextinitmessagesource">初始化MessageSource - <code>AbstractApplicationContext#initMessageSource</code></a></li>
        <li><a href="#初始化applicationeventmulticaster---abstractapplicationcontextinitapplicationeventmulticaster">初始化ApplicationEventMulticaster - <code>AbstractApplicationContext#initApplicationEventMulticaster</code></a></li>
        <li><a href="#注册applicationlistener---abstractapplicationcontextregisterlisteners">注册ApplicationListener - <code>AbstractApplicationContext#registerListeners</code></a></li>
        <li><a href="#初始化所有非lazy-bean---abstractapplicationcontextfinishbeanfactoryinitialization">初始化所有非Lazy Bean - <code>AbstractApplicationContext#finishBeanFactoryInitialization</code></a></li>
        <li><a href="#refresh的后续动作---abstractapplicationcontextfinishrefresh">Refresh的后续动作 - <code>AbstractApplicationContext#finishRefresh</code></a>
          <ul>
            <li><a href="#lifecycleprocessor---abstractapplicationcontextinitlifecycleprocessor">LifecycleProcessor - <code>AbstractApplicationContext#initLifecycleProcessor</code></a></li>
            <li><a href="#refresh事件">refresh事件</a></li>
          </ul>
        </li>
        <li><a href="#beanfactory的销毁---abstractapplicationcontextregistershutdownhook">BeanFactory的销毁 - <code>AbstractApplicationContext#registerShutdownHook</code></a></li>
      </ul>
    </li>
    <li><a href="#aside">ASIDE</a></li>
  </ul>

  <ul>
    <li><a href="#无参构造">无参构造</a>
      <ul>
        <li><a href="#annotatedbeandefinitionreader">AnnotatedBeanDefinitionReader</a></li>
      </ul>
    </li>
    <li><a href="#注册传入的配置类---register">注册传入的配置类 - <code>register</code></a></li>
    <li><a href="#refreshabstractapplicationcontext-refresh-wikilink">[Refresh](#<code>AbstractApplicationContext Refresh</code> &ldquo;wikilink&rdquo;)</a></li>
  </ul>

  <ul>
    <li><a href="#configurationclasspostprocessorpostprocessbeandefinitionregistry"><code>ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry</code></a>
      <ul>
        <li><a href="#configurationclassparserparsecandidates"><code>ConfigurationClassParser#parse(candidates)</code></a>
          <ul>
            <li><a href="#configurationclassparserdoprocessconfigurationclass"><code>ConfigurationClassParser#doProcessConfigurationClass</code></a></li>
            <li><a href="#configurationclassparserprocessimports"><code>ConfigurationClassParser#processImports</code></a>
              <ul>
                <li><a href="#针对importselector">针对<code>ImportSelector</code></a></li>
                <li><a href="#针对deferredimportselector">针对<code>DeferredImportSelector</code></a>
                  <ul>
                    <li><a href="#deferredimportselectorgroupinghandlerregister"><code>DeferredImportSelectorGroupingHandler#register</code></a></li>
                    <li><a href="#deferredimportselectorgroupinghandlerprocessgroupimports"><code>DeferredImportSelectorGroupingHandler#processGroupImports</code></a></li>
                  </ul>
                </li>
                <li><a href="#针对importbeandefinitionregistar">针对<code>ImportBeanDefinitionRegistar</code></a></li>
                <li><a href="#针对普通配置类">针对普通配置类</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#configurationclassparsergetconfigurationclasses"><code>ConfigurationClassParser#getConfigurationClasses</code></a></li>
        <li><a href="#configurationclassbeandefinitionreaderloadbeandefinitions"><code>ConfigurationClassBeanDefinitionReader#loadBeanDefinitions</code></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#enableaspectjautoproxy"><code>@EnableAspectJAutoProxy</code></a></li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><p>Bean的生命周期为：BeanFactory初始化 - Bean注册 - 实例化 - 属性注入 - 初始化 - 后处理</p>
<h1 id="bean的注册" class="heading-element"><span>Bean的注册</span>
  <a href="#bean%e7%9a%84%e6%b3%a8%e5%86%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h1><ol>
<li>扫描：Spring通过配置（XML配置或Java配置）或自动扫描（<code>@ComponentScan</code>）来发现应用中定义的Bean。对于自动扫描，Spring会在指定的包路径下查找标注了<code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code>等注解的类</li>
<li>解析：一旦Bean被发现，Spring将解析Bean的定义信息，包括Bean的作用域（如单例、原型）、生命周期回调（如<code>@PostConstruct</code>、<code>@PreDestroy</code>注解方法）、依赖注入的需求（通过<code>@Autowired</code>、<code>@Resource</code>等注解标记）等 &mdash;&mdash; <code>BeanDefinition</code></li>
<li>注册：Spring将Bean的定义信息注册到<code>BeanDefinitionRegistry</code>中。这是一个重要步骤，因为注册后的Bean定义将被用于后续的Bean实例化和依赖注入过程。此时，Bean还没有被实例化。</li>
</ol>
<h2 id="beandefinition" class="heading-element"><span>BeanDefinition</span>
  <a href="#beandefinition" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><figure>
<img
src="https://minio.dionysunrsshub.top/myimages/2024-img/BeanDefinition.webp"
alt="BeanDefinition" />
<figcaption aria-hidden="true">BeanDefinition</figcaption>
</figure>
<p>Spring在初始化过程中，先收集所有bean的元数据信息并注册，bean的元数据描述为接口<code>BeanDefinition</code>，该接口定义了你能想到的一切有关bean的属性信息</p>
<p><strong>BeanDefinition</strong>衍生出一系列实现类</p>
<ul>
<li>AbstractBeanDefinition: 如同其他Spring类，大部分<strong>BeanDefinition</strong>接口的逻辑都由该抽象类实现</li>
<li>GenericBeanDefinition: 是一站式、用户可见的bean definition；可见的bean definition意味着可以在该bean definition上定义post-processor来对bean进行操作</li>
<li>RootBeanDefinition: 当bean definition存在父子关系的时候，<strong>RootBeanDefinition</strong>用来承载父元数据的角色（也可独立存在），同时它也作为一个可合并的bean definition使用，在Spring初始化阶段，所有的bean definition均会被（向父级）合并为<strong>RootBeanDefinition</strong>，子bean definition（<strong>GenericBeanDefinition</strong>/<strong>ChildBeanDefinition</strong>）中的定义会覆盖其父bean definition（由<strong>parentName</strong>指定）的定义</li>
<li>AnnotatedBeanDefinition: 用来定义注解Bean Definition</li>
</ul>
<p><strong>BeanDefinitionHolder</strong>只是简单捆绑了BeanDefinition、bean-name、bean-alias，用于注册BeanDefinition及别名alias ^BeanDefinitionHolder</p>
<h2 id="beanregistry" class="heading-element"><span>BeanRegistry</span>
  <a href="#beanregistry" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Bean的注册逻辑分为两步，一为<strong>BeanDefinition</strong>的注册，二为别名的注册</p>
<ul>
<li><strong>BeanDefinition</strong>注册的定义在<em><strong>BeanDefinitionRegistry#registerBeanDefinition</strong></em>，其实现使用一个<em><strong>Map&lt;String, BeanDefinition&gt;</strong></em> 来保存bean-name和BeanDefinition的关系</li>
</ul>
<ul>
<li>别名的注册定义在<em><strong>AliasRegistry#registerAlias</strong></em>，其实现同样使用一个<em><strong>Map&lt;String, String&gt;</strong></em> 来保存别名alias-name和bean-name（或另一个别名alias-name）的关系</li>
</ul>
<p>注意Bean的注册时机，通常应该在应用上下文的刷新过程之前进行(<code>onRefresh()</code>)。一旦上下文被刷新，对Bean定义的任何修改可能不会被识别，或者可能会导致不一致的状态</p>
<h1 id="bean的实例化" class="heading-element"><span>Bean的实例化</span>
  <a href="#bean%e7%9a%84%e5%ae%9e%e4%be%8b%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h1><figure>
<img
src="https://minio.dionysunrsshub.top/myimages/2024-img/BigMap.webp"
alt="BigMap" />
<figcaption aria-hidden="true">BigMap</figcaption>
</figure>
<h2 id="beanfactory" class="heading-element"><span>BeanFactory</span>
  <a href="#beanfactory" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><img loading="lazy" src="https://minio.dionysunrsshub.top/myimages/2024-img/BeanFactory.webp" alt="BeanFactory" srcset="https://minio.dionysunrsshub.top/myimages/2024-img/BeanFactory.webp?size=small, https://minio.dionysunrsshub.top/myimages/2024-img/BeanFactory.webp?size=medium 1.5x, https://minio.dionysunrsshub.top/myimages/2024-img/BeanFactory.webp?size=large 2x" data-title="BeanFactory" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>
几个核心接口：</p>
<ul>
<li><strong>AliasRegistry</strong>
bean别名注册和管理</li>
<li><strong>BeanDefinitionRegistry</strong>
bean元数据注册和管理</li>
<li><strong>SingletonBeanRegistry</strong>
单例bean注册和管理</li>
<li><strong>BeanFactory</strong>
bean工厂，提供各种bean的获取及判断方法</li>
</ul>
<p>通过上述的类依赖图，对于Bean的实例化，核心实现是在<strong>DefaultListableBeanFactory</strong></p>
<h3 id="defaultlistablebeanfactory---abstractbeanfactory" class="heading-element"><span>DefaultListableBeanFactory - AbstractBeanFactory</span>
  <a href="#defaultlistablebeanfactory---abstractbeanfactory" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>bean的实例化过程发生在<strong>getBean</strong>调用阶段（对于singleton则发生在首次调用阶段），<em><strong>getBean</strong></em>的实现方法众多，我们追根溯源，找到最通用的方法<code>AbstractBeanFactory#doGetBean</code></p>
<h4 id="dogetbean" class="heading-element"><span><code>doGetBean</code></span>
  <a href="#dogetbean" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// org.springframework.beans.factory.support.AbstractBeanFactory</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">protected</span><span class="w"> </span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="nf">doGetBean</span><span class="p">(</span><span class="kd">final</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="nd">@Nullable</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">requiredType</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nd">@Nullable</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Object</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">typeCheckOnly</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 1. 获取真正的beanName</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transformedBeanName</span><span class="p">(</span><span class="n">name</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">bean</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 2. 尝试获取(提前曝光的)singleton bean实例（为了解决循环依赖）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">sharedInstance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getSingleton</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 3. 如果存在</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sharedInstance</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 4. 如果不存在</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 5. 尝试类型转换</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">requiredType</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">requiredType</span><span class="p">.</span><span class="na">isInstance</span><span class="p">(</span><span class="n">bean</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="n">bean</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><figure>
<img
src="https://minio.dionysunrsshub.top/myimages/2024-img/doGetBean.webp"
alt="doGetBean" />
<figcaption aria-hidden="true">doGetBean</figcaption>
</figure>
<h5 id="bean-name的转换" class="heading-element"><span>Bean Name的转换</span>
  <a href="#bean-name%e7%9a%84%e8%bd%ac%e6%8d%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>在使用bean-name获取bean的时候，除了可以使用原始bean-name之外，还可以使用alias别名等，bean-name的转换则是将传入的&rsquo;bean-name&rsquo;一层层转为最原始的bean-name</p>
<ul>
<li>函数<strong>canonicalName</strong>的作用则是利用别名注册<em><strong>aliasMap</strong></em>，将别名alias转为原始bean-name</li>
<li>函数<strong>transformedBeanName</strong>比较特殊，其是将<strong>FactoryBean</strong>的bean-name前缀 &lsquo;&amp;&rsquo; 去除
<img loading="lazy" src="https://minio.dionysunrsshub.top/myimages/2024-img/bean-name-transform.webp" alt="bean-name-transform" srcset="https://minio.dionysunrsshub.top/myimages/2024-img/bean-name-transform.webp?size=small, https://minio.dionysunrsshub.top/myimages/2024-img/bean-name-transform.webp?size=medium 1.5x, https://minio.dionysunrsshub.top/myimages/2024-img/bean-name-transform.webp?size=large 2x" data-title="bean-name-transform" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></li>
</ul>
<h5 id="尝试获取单例" class="heading-element"><span>尝试获取单例</span>
  <a href="#%e5%b0%9d%e8%af%95%e8%8e%b7%e5%8f%96%e5%8d%95%e4%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>拿到原始的bean-name之后，便可以实例化bean或者直接获取已经实例化的singleton-bean</p>
<p>在获取singleton-bean的时候一般存在三种情况：1. 还未实例化(或者不是单例)；2. 已经实例化；3. 正在实例化；</p>
<ul>
<li>对于 &ldquo;1. 还未实例化&rdquo; ，返回null即可，后续进行实例化动作</li>
<li>对于 &ldquo;2. 已经实例化&rdquo;，直接返回实例化的singleton-bean</li>
<li>对于 &ldquo;3. 正在实例化&rdquo;，会存在循环依赖问题</li>
</ul>
<p>Spring中对于singleton-bean，有一个<em><strong>sharedInstance</strong></em>的概念，在调用<code>getSingleton</code>函数时，返回的不一定是完全实例化的singleton-bean，有可能是一个中间状态（创建完成，但未进行属性依赖注入及其他后处理逻辑），这种中间状态会通过<strong>getSingleton</strong>函数提前曝光出来，目的是为了解决循环依赖</p>
<p>因此，Spring通过提供三层缓存来解决循环依赖问题，并且可以通过这种机制实现诸多的<strong>PostProcessor</strong>增强Bean，例如AOP</p>
<ul>
<li><strong>singletonObjects</strong>
缓存已经实例化完成的singleton-bean</li>
</ul>
<ul>
<li>
<p><strong>earlySingletonObjects</strong>
缓存正在实例化的、提前曝光的singleton-bean，用于处理循环依赖</p>
</li>
<li>
<p><strong>singletonFactories</strong>
缓存用于生成earlySingletonObject的 ObjectFactory</p>
</li>
</ul>
<blockquote>
<p><strong>ObjectFactory</strong>，定义了一个用于创建、生成对象实例的工厂方法</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@FunctionalInterface</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">ObjectFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="nf">getObject</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因此getSingleton的逻辑如下：
<img loading="lazy" src="https://minio.dionysunrsshub.top/myimages/2024-img/getSingleton.webp" alt="getSingleton" srcset="https://minio.dionysunrsshub.top/myimages/2024-img/getSingleton.webp?size=small, https://minio.dionysunrsshub.top/myimages/2024-img/getSingleton.webp?size=medium 1.5x, https://minio.dionysunrsshub.top/myimages/2024-img/getSingleton.webp?size=large 2x" data-title="getSingleton" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></p>
<p><strong>NOTE</strong>: 在<a href="#%e6%8f%90%e5%89%8d%e6%9a%b4%e9%9c%b2%e5%ae%9e%e4%bd%93" title="wikilink">提前暴露实体</a>中，将相应的<strong>ObjectFactory</strong>放入了<strong>singletonFactories</strong></p>
<h5 id="factorybean的处理sharedinstance存在的逻辑" class="heading-element"><span>FactoryBean的处理(sharedInstance存在的逻辑)</span>
  <a href="#factorybean%e7%9a%84%e5%a4%84%e7%90%86sharedinstance%e5%ad%98%e5%9c%a8%e7%9a%84%e9%80%bb%e8%be%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>==<strong>sharedInstance</strong>不一定是我们所需要的bean实例==</p>
<p>例如，我们在定义Bean的时候可以通过实现<strong>FactoryBean</strong>接口来定制bean实例化的逻辑(<a href="JavaSSM#%5e249d21" title="wikilink">实现FactoryBean</a>)，通过注册FactoryBean类型的Bean，实例化后的原始实例类型同样为FactoryBean，但我们需要的是通过FactoryBean#getObject方法得到的实例，这需要针对FactoryBean做一些处理，即<strong>AbstractBeanFactory#getObjectForBeanInstance</strong></p>
<blockquote>
<p>Get the object for the given bean instance, either the bean instance itself or its created object in case of a FactoryBean.
Now we have the bean instance, which may be a normal bean or a FactoryBean. If it&rsquo;s a FactoryBean, we use it to create a bean instance.</p>
</blockquote>
<p>该函数要实现的逻辑比较简单，如果sharedInstance是 FactoryBean，则使用getObject方法创建真正的实例</p>
<blockquote>
<p>getObjectForBeanInstance是一个通用函数，并不只针对通过getSingleton得到的sharedInstance，任何通过缓存或者创建得到的 rawInstance，都需要经过getObjectForBeanInstance处理，拿到真正需要的 beanInstance</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param beanInstance  sharedInstance / rawInstance，可能为FactoryBean
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param name            传入的未做转换的 bean name
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param beanName        对name做过转换后的原始 canonical bean name
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param mbd            合并后的RootBeanDefinition，下文会介绍
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">protected</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">getObjectForBeanInstance</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">beanInstance</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">RootBeanDefinition</span><span class="w"> </span><span class="n">mbd</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><h6 id="getobjectbeaninstance" class="heading-element"><span>getObjectBeanInstance</span>
  <a href="#getobjectbeaninstance" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><figure>
<img
src="https://minio.dionysunrsshub.top/myimages/2024-img/getObjectForBeanInstance.webp"
alt="getObjectForBeanInstance" />
<figcaption aria-hidden="true">getObjectForBeanInstance</figcaption>
</figure>
<p>在这个判断逻辑中，如果入参<strong>name</strong>以&rsquo;&amp;&lsquo;开头则直接返回，这里兼容了一种情况，如果需要获取/注入FactoryBean而不是getObject生成的实例，<a href="JavaSSM#%5e5d8395" title="wikilink">则需要在bean-name/alias-name前加入'&amp;'</a></p>
<p>对于singleton，FactoryBean#getObject的结果会被缓存到factoryBeanObjectCache，对于缓存中不存在或者不是singleton的情况，会通过FactoryBean#getObject生成 ^factorybeangetobject</p>
<h6 id="factorybeanregistrysupportgetobjectfromfactorybean" class="heading-element"><span><code>FactoryBeanRegistrySupport#getObjectFromFactoryBean</code></span>
  <a href="#factorybeanregistrysupportgetobjectfromfactorybean" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">protected</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">getObjectFromFactoryBean</span><span class="p">(</span><span class="n">FactoryBean</span><span class="o">&lt;?&gt;</span><span class="w"> </span><span class="n">factory</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">shouldPostProcess</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">factory</span><span class="p">.</span><span class="na">isSingleton</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">containsSingleton</span><span class="p">(</span><span class="n">beanName</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">synchronized</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">getSingletonMutex</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Object</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">factoryBeanObjectCache</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">object</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">doGetObjectFromFactoryBean</span><span class="p">(</span><span class="n">factory</span><span class="p">,</span><span class="w"> </span><span class="n">beanName</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Object</span><span class="w"> </span><span class="n">alreadyThere</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">factoryBeanObjectCache</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">alreadyThere</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alreadyThere</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shouldPostProcess</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">isSingletonCurrentlyInCreation</span><span class="p">(</span><span class="n">beanName</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="k">return</span><span class="w"> </span><span class="n">object</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">this</span><span class="p">.</span><span class="na">beforeSingletonCreation</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="n">object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">postProcessObjectFromFactoryBean</span><span class="p">(</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="n">beanName</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">Throwable</span><span class="w"> </span><span class="n">var14</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BeanCreationException</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Post-processing of FactoryBean&#39;s singleton object failed&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">var14</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="k">this</span><span class="p">.</span><span class="na">afterSingletonCreation</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">containsSingleton</span><span class="p">(</span><span class="n">beanName</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">this</span><span class="p">.</span><span class="na">factoryBeanObjectCache</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">object</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">object</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Object</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">doGetObjectFromFactoryBean</span><span class="p">(</span><span class="n">factory</span><span class="p">,</span><span class="w"> </span><span class="n">beanName</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shouldPostProcess</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">postProcessObjectFromFactoryBean</span><span class="p">(</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="n">beanName</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">Throwable</span><span class="w"> </span><span class="n">var17</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BeanCreationException</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Post-processing of FactoryBean&#39;s object failed&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">var17</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">object</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于Singleton:</p>
<ul>
<li>首先从缓存中尝试获取，如获取失败，调用[doGetObjectFromFactoryBean](#<code>FactoryBeanRegistrySupport doGetObjectFromFactoryBean</code> &ldquo;wikilink&rdquo;)，其中内核是调用<a href="#%5efactorybeangetobject" title="wikilink">FactoryBean#getObject()</a>方法</li>
<li>对于需要后处理的Bean，首先判断是否处于正在创建状态(<code>isSingletonCurrentlyInCreation</code>)，并且通过<code>this.beforeSingletonCreate()</code> <code>this.afterSingletonCreation()</code>将实际的<code>BeanPostProcessor</code>过程保护</li>
<li>对于<code>BeanPostProcessor</code>，调用<code>this.postProcessObjectFromFactoryBean</code>，其具体实现在[AbstractAutowireCapableBeanFactory#applyBeanPostProcessorAfterInitialization](#<code>AbstractAutowireCapableBeanFactory applyBeanPostProcessorAfterInitialization</code> &ldquo;wikilink&rdquo;)</li>
</ul>
<h6 id="factorybeanregistrysupportdogetobjectfromfactorybean" class="heading-element"><span><code>FactoryBeanRegistrySupport#doGetObjectFromFactoryBean</code></span>
  <a href="#factorybeanregistrysupportdogetobjectfromfactorybean" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><figure>
<img
src="https://minio.dionysunrsshub.top/myimages/2024-img/FactoryBeanRegistrySupport_doGetObjectFromFactoryBean.webp"
alt="FactoryBeanRegistrySupport_doGetObjectFromFactoryBean" />
<figcaption
aria-hidden="true">FactoryBeanRegistrySupport_doGetObjectFromFactoryBean</figcaption>
</figure>
<h6 id="abstractautowirecapablebeanfactoryapplybeanpostprocessorafterinitialization" class="heading-element"><span><code>AbstractAutowireCapableBeanFactory#applyBeanPostProcessorAfterInitialization</code></span>
  <a href="#abstractautowirecapablebeanfactoryapplybeanpostprocessorafterinitialization" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><p>postProcessAfterInitialization函数可以对现有bean instance做进一步的处理，甚至可以返回新的bean instance，这就为bean的增强提供了一个非常方便的扩展方式</p>
<h5 id="加载bean实例-sharedinstance不存在的逻辑" class="heading-element"><span>加载Bean实例 (sharedInstance不存在的逻辑)</span>
  <a href="#%e5%8a%a0%e8%bd%bdbean%e5%ae%9e%e4%be%8b-sharedinstance%e4%b8%8d%e5%ad%98%e5%9c%a8%e7%9a%84%e9%80%bb%e8%be%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><figure>
<img
src="https://minio.dionysunrsshub.top/myimages/2024-img/createBeanInstance.webp"
alt="createBeanInstance" />
<figcaption aria-hidden="true">createBeanInstance</figcaption>
</figure>
<p>Bean的加载/创建分为三大部分</p>
<ol>
<li>将BeanDefinition合并为RootBeanDefinition，类似类继承，子BeanDefinition属性会覆盖父BeanDefinition</li>
<li>依次加载所依赖的bean，对于有依赖的情况，优先递归加载依赖的bean</li>
<li>按照不同的bean类型，根据BeanDefinition的定义进行加载/创建</li>
</ol>
<h6 id="beandefinition合并-rootbeandefinition" class="heading-element"><span>BeanDefinition合并 (RootBeanDefinition)</span>
  <a href="#beandefinition%e5%90%88%e5%b9%b6-rootbeandefinition" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><p>在<code>AbstractBeanFactory#getMergedLocalBeanDefinition</code>中执行核心逻辑</p>
<h6 id="加载dependes-on-beans" class="heading-element"><span>加载dependes-On beans</span>
  <a href="#%e5%8a%a0%e8%bd%bddependes-on-beans" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">dependsOn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mbd</span><span class="p">.</span><span class="na">getDependsOn</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dependsOn</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 遍历所有的依赖</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">dep</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">dependsOn</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 检测循环依赖</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isDependent</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">dep</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* throw exception */</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 注册依赖关系</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">registerDependentBean</span><span class="p">(</span><span class="n">dep</span><span class="p">,</span><span class="w"> </span><span class="n">beanName</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 递归getBean，加载依赖bean</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">getBean</span><span class="p">(</span><span class="n">dep</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">NoSuchBeanDefinitionException</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* throw exception */</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>该过程中涉及两个中间态</p>
<ul>
<li>dependentBeanMap
存储哪些bean依赖了我（哪些bean里注入了我）
如果 beanB -&gt; beanA, beanC -&gt; beanA，key为beanA，value为[beanB, beanC]</li>
</ul>
<ul>
<li>dependenciesForBeanMap
存储我依赖了哪些bean（我注入了哪些bean）
如果 beanA -&gt; beanB, beanA -&gt; beanC，key为beanA，value为[beanB, beanC]</li>
</ul>
<h6 id="加载singleton-bean实例" class="heading-element"><span>加载singleton bean实例</span>
  <a href="#%e5%8a%a0%e8%bd%bdsingleton-bean%e5%ae%9e%e4%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mbd</span><span class="p">.</span><span class="na">isSingleton</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">sharedInstance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getSingleton</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// singletonFactory - ObjectFactory</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">createBean</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">mbd</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">BeansException</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">    </span><span class="n">destroySingleton</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span><span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">ex</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">bean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getObjectForBeanInstance</span><span class="p">(</span><span class="n">sharedInstance</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">mbd</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其中核心为<strong>createBean</strong>与<strong>getObjectForBeanInstance</strong></p>
<ul>
<li><strong>createBean</strong>
根据BeanDefinition的内容，创建/初始化 bean instance</li>
<li><strong><a href="#getObjectBeanInstance" title="wikilink">#getObjectBeanInstance</a></strong>
主要处理FactoryBean</li>
</ul>
<p><strong>createBean</strong>被包装在lambda(singletonFactory)，重写<code>ObjectFactory#getObject()</code>，作为[getSingleton](#<code>DefaultSingletonBeanRegistry getSingleton(String, ObjectFactory)</code> &ldquo;wikilink&rdquo;)的参数</p>
<h6 id="defaultsingletonbeanregistrygetsingletonstring-objectfactory" class="heading-element"><span><code>DefaultSingletonBeanRegistry#getSingleton(String, ObjectFactory)</code></span>
  <a href="#defaultsingletonbeanregistrygetsingletonstring-objectfactory" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><figure>
<img
src="https://minio.dionysunrsshub.top/myimages/2024-img/createSingletonBean.webp"
alt="createSingletonBean" />
<figcaption aria-hidden="true">createSingletonBean</figcaption>
</figure>
<p>同样的，会先在缓存中查找该singleton，如果不存在，创建的核心逻辑在于[createBean](#AbstractAutowireCapableBeanFactory createBean &ldquo;wikilink&rdquo;)</p>
<h6 id="abstractautowirecapablebeanfactorycreatebean" class="heading-element"><span><code>AbstractAutowireCapableBeanFactory#createBean</code></span>
  <a href="#abstractautowirecapablebeanfactorycreatebean" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><figure>
<img
src="https://minio.dionysunrsshub.top/myimages/2024-img/createBean.webp"
alt="createBean" />
<figcaption aria-hidden="true">createBean</figcaption>
</figure>
<ol>
<li><strong>resolveBeanClass</strong>
这一步骤用于锁定bean class，在没有显示指定beanClass的情况下，使用className加载beanClass</li>
<li><strong>验证method overrides</strong>
==在BeanDefinitionReader 中有提到过lookup-method及replace-method，该步骤是为了确认以上两种配置中的method是否存在==</li>
<li><strong>执行InstantiationAwareBeanPostProcessor前处理器</strong>(<strong>postProcessBeforeInstantiation</strong>)
如果这个步骤中生成了&quot;代理&quot;bean instance，则会有一个短路操作，<code>直接返回</code>该bean instance而不再执行doCreate，其中的核心逻辑为调用<code>this.applyBeanPostProcessorsBeforeInstantiation()</code> ^fcb215</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">bean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">resolveBeforeInstantiation</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">mbdToUse</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bean</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="c1">// 如果这里生成了代理的bean instance会直接返回</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">bean</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="n">cache</span><span class="w"> </span><span class="p">(</span><span class="n">Throwable</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// throw exception }</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// 创建bean instance</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">Object</span><span class="w"> </span><span class="n">beanInstance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">doCreateBean</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">mbdToUse</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// ...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li><strong><a href="#%60doCreateBean%60" title="wikilink">doCreateBean</a></strong> (AbstractAutowireCapableBeanFactory)
真正bean的创建及初始化过程在此处实现</li>
</ol>
<h6 id="docreatebean" class="heading-element"><span><code>doCreateBean</code></span>
  <a href="#docreatebean" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">protected</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">doCreateBean</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">RootBeanDefinition</span><span class="w"> </span><span class="n">mbd</span><span class="p">,</span><span class="w"> </span><span class="nd">@Nullable</span><span class="w"> </span><span class="n">Object</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeanCreationException</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">BeanWrapper</span><span class="w"> </span><span class="n">instanceWrapper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mbd</span><span class="p">.</span><span class="na">isSingleton</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">instanceWrapper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">BeanWrapper</span><span class="p">)</span><span class="k">this</span><span class="p">.</span><span class="na">factoryBeanInstanceCache</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">instanceWrapper</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">instanceWrapper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">createBeanInstance</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">mbd</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">bean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instanceWrapper</span><span class="p">.</span><span class="na">getWrappedInstance</span><span class="p">();</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Class</span><span class="o">&lt;?&gt;</span><span class="w"> </span><span class="n">beanType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instanceWrapper</span><span class="p">.</span><span class="na">getWrappedClass</span><span class="p">();</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">beanType</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NullBean</span><span class="p">.</span><span class="na">class</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">mbd</span><span class="p">.</span><span class="na">resolvedTargetType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">beanType</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">synchronized</span><span class="p">(</span><span class="n">mbd</span><span class="p">.</span><span class="na">postProcessingLock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mbd</span><span class="p">.</span><span class="na">postProcessed</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">this</span><span class="p">.</span><span class="na">applyMergedBeanDefinitionPostProcessors</span><span class="p">(</span><span class="n">mbd</span><span class="p">,</span><span class="w"> </span><span class="n">beanType</span><span class="p">,</span><span class="w"> </span><span class="n">beanName</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">Throwable</span><span class="w"> </span><span class="n">var17</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BeanCreationException</span><span class="p">(</span><span class="n">mbd</span><span class="p">.</span><span class="na">getResourceDescription</span><span class="p">(),</span><span class="w"> </span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Post-processing of merged bean definition failed&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">var17</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">mbd</span><span class="p">.</span><span class="na">markAsPostProcessed</span><span class="p">();</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="n">earlySingletonExposure</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mbd</span><span class="p">.</span><span class="na">isSingleton</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">allowCircularReferences</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">isSingletonCurrentlyInCreation</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">earlySingletonExposure</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">logger</span><span class="p">.</span><span class="na">isTraceEnabled</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">logger</span><span class="p">.</span><span class="na">trace</span><span class="p">(</span><span class="s">&#34;Eagerly caching bean &#39;&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">beanName</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;&#39; to allow for resolving potential circular references&#34;</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">addSingletonFactory</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">getEarlyBeanReference</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">mbd</span><span class="p">,</span><span class="w"> </span><span class="n">bean</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">});</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">exposedObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bean</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">populateBean</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">mbd</span><span class="p">,</span><span class="w"> </span><span class="n">instanceWrapper</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">exposedObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">initializeBean</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">exposedObject</span><span class="p">,</span><span class="w"> </span><span class="n">mbd</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">Throwable</span><span class="w"> </span><span class="n">var18</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">var18</span><span class="w"> </span><span class="k">instanceof</span><span class="w"> </span><span class="n">BeanCreationException</span><span class="w"> </span><span class="n">bce</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">beanName</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">bce</span><span class="p">.</span><span class="na">getBeanName</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">throw</span><span class="w"> </span><span class="n">bce</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BeanCreationException</span><span class="p">(</span><span class="n">mbd</span><span class="p">.</span><span class="na">getResourceDescription</span><span class="p">(),</span><span class="w"> </span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">var18</span><span class="p">.</span><span class="na">getMessage</span><span class="p">(),</span><span class="w"> </span><span class="n">var18</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">earlySingletonExposure</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Object</span><span class="w"> </span><span class="n">earlySingletonReference</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">getSingleton</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">earlySingletonReference</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">exposedObject</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">bean</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">exposedObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">earlySingletonReference</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="na">allowRawInjectionDespiteWrapping</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">hasDependentBean</span><span class="p">(</span><span class="n">beanName</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">dependentBeans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">getDependentBeans</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">actualDependentBeans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedHashSet</span><span class="p">(</span><span class="n">dependentBeans</span><span class="p">.</span><span class="na">length</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">var12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dependentBeans</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">var13</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dependentBeans</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">var14</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">var14</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">var13</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">var14</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">String</span><span class="w"> </span><span class="n">dependentBean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">var12</span><span class="o">[</span><span class="n">var14</span><span class="o">]</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="na">removeSingletonIfCreatedForTypeCheckOnly</span><span class="p">(</span><span class="n">dependentBean</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">actualDependentBeans</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">dependentBean</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">actualDependentBeans</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BeanCurrentlyInCreationException</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Bean with name &#39;&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">beanName</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;&#39; has been injected into other beans [&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">StringUtils</span><span class="p">.</span><span class="na">collectionToCommaDelimitedString</span><span class="p">(</span><span class="n">actualDependentBeans</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using &#39;getBeanNamesForType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&#34;</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">registerDisposableBeanIfNecessary</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">bean</span><span class="p">,</span><span class="w"> </span><span class="n">mbd</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">exposedObject</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">BeanDefinitionValidationException</span><span class="w"> </span><span class="n">var16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BeanCreationException</span><span class="p">(</span><span class="n">mbd</span><span class="p">.</span><span class="na">getResourceDescription</span><span class="p">(),</span><span class="w"> </span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Invalid destruction signature&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">var16</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以将该流程细分为如下：</p>
<ol>
<li>[创建Bean实体](#创建Bean实体 <code>AbstractAutowireCapableBeanFactory createBeanInstance</code> &ldquo;wikilink&rdquo;)</li>
<li>[BeanDefinition后处理](#BeanDefinition后处理 - <code>AbstractAutowireCapableBeanFactory applyMergedBeanDefinitionPostProcessors</code> &ldquo;wikilink&rdquo;)</li>
<li><a href="#%e6%8f%90%e5%89%8d%e6%9a%b4%e9%9c%b2%e5%ae%9e%e4%bd%93" title="wikilink">提前暴露实体</a></li>
<li>[属性注入](#属性注入 - <code>AbstractAutowireCapableBeanFactory populateBean</code> &ldquo;wikilink&rdquo;)</li>
<li>[初始化](#初始化 - <code>AbstractAutowireCapableBeanFactory initializeBean</code> &ldquo;wikilink&rdquo;)</li>
<li>[注册Disposable](#注册Disposable - <code>AbstractBeanFactory registerDisposableBeanIfNecessary</code> &ldquo;wikilink&rdquo;)</li>
</ol>
<h6 id="创建bean实体---abstractautowirecapablebeanfactorycreatebeaninstance" class="heading-element"><span>创建Bean实体 - <code>AbstractAutowireCapableBeanFactory#createBeanInstance</code></span>
  <a href="#%e5%88%9b%e5%bb%babean%e5%ae%9e%e4%bd%93---abstractautowirecapablebeanfactorycreatebeaninstance" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><figure>
<img
src="https://minio.dionysunrsshub.top/myimages/2024-img/createBeanInstance_2.webp"
alt="createBeanInstance_2" />
<figcaption aria-hidden="true">createBeanInstance_2</figcaption>
</figure>
<ol>
<li>instanceSupplier
从上面的流程图可以看出，创建bean实体不一定会使用到构造函数，可以使用Supplier的方式</li>
<li>factory method
<a href="JavaSSM#%5e249d21" title="wikilink">工厂模式</a>
@Configuration + @Bean的实现方式就是factory-bean + factory-method
[对应的参数获取](#<code>ConstructorResolver resolvePreparedArguments</code> &ldquo;wikilink&rdquo;)</li>
<li>有参构造函数
<strong>AbstractAutowireCapableBeanFactory#autowireConstructor</strong> -&gt; <strong>[ConstructorResolver#autowireConstructor](#<code>**ConstructorResolver autowireConstructor**</code> &ldquo;wikilink&rdquo;)</strong></li>
<li>无参构造函数
与有参构造创建过程一致，除了不需要参数的依赖注入，使用默认无参构造函数进行实例化</li>
</ol>
<h6 id="constructorresolverresolvepreparedarguments" class="heading-element"><span><code>ConstructorResolver#resolvePreparedArguments</code></span>
  <a href="#constructorresolverresolvepreparedarguments" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><p>使用指定（类）bean的（静态）方法创建bean实体的逻辑在ConstructorResolver#instantiate(String, RootBeanDefinition, Object, Method, args)，而真正的逻辑在SimpleInstantiationStrategy#instantiate(RootBeanDefinition, String, BeanFactory, Object, Method, Object&hellip;)，其核心的执行逻辑非常简单，有了方法factoryMethod(factoryBean)及入参args，便可以调用该方法创建bean实体</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Object</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factoryMethod</span><span class="p">.</span><span class="na">invoke</span><span class="p">(</span><span class="n">factoryBean</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>factoryBean可以通过beanFactory.getBean获取到（正是当前在讲的逻辑），factoryMethod可以通过反射获取到，而入参args就从<code>ConstructorResolver#resolvePreparedArguments</code>中获取，即是Spring中<strong>依赖注入</strong>的核心实现</p>
<p>该函数的作用是将BeanDefinition中定义的入参转换为需要的参数(==将BeanDefinitionReader中封装的对象转换==)</p>
<figure>
<img
src="https://minio.dionysunrsshub.top/myimages/2024-img/resolvePreparedArguments.webp"
alt="resolvePreparedArguments" />
<figcaption aria-hidden="true">resolvePreparedArguments</figcaption>
</figure>
<p><strong><a href="https://segmentfault.com/a/1190000022309143#item-3-4"target="_blank" rel="external nofollow noopener noreferrer">More in blogs</a></strong></p>
<h6 id="constructorresolverautowireconstructor" class="heading-element"><span><code>ConstructorResolver#autowireConstructor</code></span>
  <a href="#constructorresolverautowireconstructor" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><p>同样的，调用<strong>ConstructorResolver#resolvePreparedArguments</strong>进行参数的解析和转换(参数的依赖注入)，然后调用 <strong>[ConstructorResolver#instantiate](#<code>ConstructorResolver instantiate</code> &ldquo;wikilink&rdquo;)</strong> 来创建Bean实例</p>
<h6 id="constructorresolverinstantiate" class="heading-element"><span><code>ConstructorResolver#instantiate</code></span>
  <a href="#constructorresolverinstantiate" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><p>内部并没有统一利用反射技术直接使用构造函数创建，而是通过<code>InstantiationStrategy.instantiate</code>进行创建</p>
<figure>
<img
src="https://minio.dionysunrsshub.top/myimages/2024-img/Instantiate.webp"
alt="Instantiate" />
<figcaption aria-hidden="true">Instantiate</figcaption>
</figure>
<ul>
<li>没有设置override-method时，直接使用构造函数创建</li>
<li>设置了override-method时，使用cglib技术构造代理类，并代理override方法</li>
</ul>
<p>Spring默认的实例化策略为<strong>CglibSubclassingInstantiationStrategy</strong></p>
<h6 id="beandefinition后处理---abstractautowirecapablebeanfactoryapplymergedbeandefinitionpostprocessors" class="heading-element"><span>BeanDefinition后处理 - <code>AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors</code></span>
  <a href="#beandefinition%e5%90%8e%e5%a4%84%e7%90%86---abstractautowirecapablebeanfactoryapplymergedbeandefinitionpostprocessors" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><p>在属性注入之前提供一次机会来对BeanDefinition进行处理，内部执行所有注册<strong>MergedBeanDefinitionPostProcessor</strong>的<strong>postProcessMergedBeanDefinition</strong>方法</p>
<blockquote>
<p>[!hint] <strong>MergedBeanDefinitionPostProcessor</strong>
<code>MergedBeanDefinitionPostProcessor</code> 是一个特定类型的 <code>BeanPostProcessor</code>。<code>MergedBeanDefinitionPostProcessor</code> 的 <code>postProcessMergedBeanDefinition</code> 方法允许在实例化bean之后但在设置bean属性之前，对bean的定义（<code>BeanDefinition</code>）进行后处理。这个阶段是用于修改或增强bean定义的，例如，可以解析注解并相应地修改 <code>BeanDefinition</code> 的属性。</p>
</blockquote>
<p>对于<code>MergedBeanDefinitionPostProcessor</code>的实现类<code>AutowiredAnnotationBeanPostProcessor</code>，其内部方法AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata 实现了两个注解类的解析 @Value 及 @Autowired ，找到注解修饰的Filed或者Method并缓存，具体逻辑在[属性注入](#属性注入 - <code>AbstractAutowireCapableBeanFactory populateBean</code> &ldquo;wikilink&rdquo;) ^autowiredAnnotationBeanPostProcessor1</p>
<h6 id="提前暴露实体" class="heading-element"><span>提前暴露实体</span>
  <a href="#%e6%8f%90%e5%89%8d%e6%9a%b4%e9%9c%b2%e5%ae%9e%e4%bd%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><p>通过将<strong>AbstractAutowireCapableBeanFactory#getEarlyBeanReference</strong>封装为ObjectFactory，调用<strong>DefaultSingletonBeanRegistry#addSingletonFactory</strong>，将该ObjectFactory缓存在<strong>DefaultSingletonBeanRegistry.singletonFactories</strong>中，在<code>getBean</code>逻辑中的<code>getSingleton</code>会执行ObjectFactory将singleton提前暴露
==此处即为何时添加ObjectFactory进入singletonFactories中，解决循环依赖==</p>
<blockquote>
<p>此时暴露的singleton-bean仅完成了bean的实例化，属性注入、初始化等逻辑均暂未执行</p>
</blockquote>
<h6 id="属性注入---abstractautowirecapablebeanfactorypopulatebean" class="heading-element"><span>属性注入 - <code>AbstractAutowireCapableBeanFactory#populateBean</code></span>
  <a href="#%e5%b1%9e%e6%80%a7%e6%b3%a8%e5%85%a5---abstractautowirecapablebeanfactorypopulatebean" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><p>在[创建Bean实体](#创建Bean实体 - <code>AbstractAutowireCapableBeanFactory createBeanInstance</code> &ldquo;wikilink&rdquo;)中介绍了factory method方式及有参构造函数方式的参数注入逻辑，除此之外还有一种注入便是属性注入</p>
<figure>
<img
src="https://minio.dionysunrsshub.top/myimages/2024-img/populateBean.webp"
alt="populateBean" />
<figcaption aria-hidden="true">populateBean</figcaption>
</figure>
<p>流程中出现了两次<strong>InstantiationAwareBeanPostProcessor</strong>，在第一次出现中调用的<code>postProcessorAfterInstantiation</code>也与前面的<strong>InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation</strong>相同，拥有短路操作：如果该步骤生成了&quot;代理&quot;bean instance，<code>直接返回</code>该bean instance而不再执行后续的doCreate；如果有任意一个InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation方法返回false，则会跳出属性注入的逻辑，官方对此的解释如下</p>
<blockquote>
<p>Give any InstantiationAwareBeanPostProcessors the opportunity to modify the state of the bean before properties are set. This can be used, for example, to support styles of field injection.</p>
</blockquote>
<p><strong>autowireByName</strong>及<strong>autowireByType</strong>方法作为&quot;候补&quot;补充BeanDefinition的propertyValues</p>
<p><strong>PropertyValue</strong>中记录了需要注入的属性信息及需要注入的属性值，那BeanDefinition的propertyValues都来自哪里？xml中的bean配置、自定义的BeanDefinition等</p>
<p>通过注解修饰的属性(方法)通过<strong>InstantiationAwareBeanPostProcessor#postProcessProperties</strong>进行注入 -&gt; ==AutowiredAnnotationBeanPostProcessor#postProcessProperties &amp; CommonAnnotationBeanPostProcessor#postProcessProperties==</p>
<p>最后，通过AbstractAutowireCapableBeanFactory#applyPropertyValues 将<strong>PropertyValue</strong>中记录的需要注入的属性，已经依赖的类型（String、RuntimeBeanReference、等），根据不同的类型解析依赖的bean并设置到对应的属性上（==此过程与DefaultListableBeanFactory#doResolveDependency相似==）</p>
<h6 id="初始化---abstractautowirecapablebeanfactoryinitializebean" class="heading-element"><span>初始化 - <code>AbstractAutowireCapableBeanFactory#initializeBean</code></span>
  <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96---abstractautowirecapablebeanfactoryinitializebean" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><p>以上，完成了bean实例的创建和属性注入，之后还有一些初始化的方法，比如各种<strong>Aware</strong>的<strong>setXxx</strong>是如何调用的、@PostConstruct是怎么调用的？</p>
<figure>
<img
src="https://minio.dionysunrsshub.top/myimages/2024-img/initializeBean.webp"
alt="initializeBean" />
<figcaption aria-hidden="true">initializeBean</figcaption>
</figure>
<h6 id="注册disposable---abstractbeanfactoryregisterdisposablebeanifnecessary" class="heading-element"><span>注册Disposable - <code>AbstractBeanFactory#registerDisposableBeanIfNecessary</code></span>
  <a href="#%e6%b3%a8%e5%86%8cdisposable---abstractbeanfactoryregisterdisposablebeanifnecessary" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><p>至此，终于完成了bean实例的创建、属性注入以及之后的初始化，此后便可以开始使用了</p>
<p>在使用Spring的过程中经常还会碰到设置销毁逻辑的情况，如数据库连接池、线程池等等，在Spring销毁bean的时候还需要做一些处理，类似于C++中的析构</p>
<p>在bean的创建逻辑中，最后一个步骤则是注册bean的销毁逻辑（DisposableBean）</p>
<p>销毁逻辑的注册有几个条件</p>
<ol>
<li>非prototype（singleton或者注册的scope）</li>
<li>非NullBean</li>
<li>指定了destroy-method（如xml中指定或者BeanDefinition中直接设置）或者存在**@PreDestroy** 注解的方法（<strong>CommonAnnotationBeanPostProcessor.requiresDestruction</strong>）</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mbd</span><span class="p">.</span><span class="na">isPrototype</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">requiresDestruction</span><span class="p">(</span><span class="n">bean</span><span class="p">,</span><span class="w"> </span><span class="n">mbd</span><span class="p">))</span></span></span></code></pre></td></tr></table>
</div>
</div><p>满足以上条件的bean会被封装为<strong>DisposableBeanAdapter</strong>，并注册在<strong>DefaultSingletonBeanRegistry.disposableBeans</strong>中</p>
<h6 id="加载prototype-bean实例" class="heading-element"><span>加载prototype bean实例</span>
  <a href="#%e5%8a%a0%e8%bd%bdprototype-bean%e5%ae%9e%e4%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mbd</span><span class="p">.</span><span class="na">isPrototype</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">prototypeInstance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">beforePrototypeCreation</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">prototypeInstance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">createBean</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">mbd</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">afterPrototypeCreation</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">bean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getObjectForBeanInstance</span><span class="p">(</span><span class="n">prototypeInstance</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">mbd</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>prototype bean的创建与singleton bean类似，只是不会缓存创建完成的bean</p>
<h6 id="加载其他scope-bean实例" class="heading-element"><span>加载其他scope bean实例</span>
  <a href="#%e5%8a%a0%e8%bd%bd%e5%85%b6%e4%bb%96scope-bean%e5%ae%9e%e4%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><p>scope，即作用域，或者可以理解为生命周期</p>
<p>上文介绍了singleton-bean及prototype-bean的创建过程，严格意义上讲以上两种都是一种特殊的scope-bean，分别对应ConfigurableBeanFactory#SCOPE_SINGLETON及ConfigurableBeanFactory#SCOPE_PROTOTYPE，前者作用域为整个IOC容器，也可理解为单例，后者作用域为所注入的bean，每次注入(每次触发getBean)都会重新生成</p>
<p>Spring中还提供很多其他的scope，如WebApplicationContext#SCOPE_REQUEST或WebApplicationContext#SCOPE_SESSION，前者作用域为一次web request，后者作用域为一个web session周期</p>
<p>自定义scope的bean实例创建过程与singleton bean的创建过程十分相似，需要实现Scope的get方法(org.springframework.beans.factory.config.Scope#get)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">scopeName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mbd</span><span class="p">.</span><span class="na">getScope</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">Scope</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">scopes</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">scopeName</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">scope</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* throw exception */</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Object</span><span class="w"> </span><span class="n">scopedInstance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scope</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">beforePrototypeCreation</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// createBean被封装在Scope#get函数的lambda参数ObjectFactory中</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">createBean</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">mbd</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">afterPrototypeCreation</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">bean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getObjectForBeanInstance</span><span class="p">(</span><span class="n">scopedInstance</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">mbd</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">IllegalStateException</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* throw exception */</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Scope接口除了get方法之外，还有一个remove方法，前者用于定义bean的初始化逻辑，后者用于定义bean的销毁逻辑</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">Scope</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * Return the object with the given name from the underlying scope
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">Object</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">ObjectFactory</span><span class="o">&lt;?&gt;</span><span class="w"> </span><span class="n">objectFactory</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * Remove the object with the given name from the underlying scope.
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">Object</span><span class="w"> </span><span class="nf">remove</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>WebApplicationContext#SCOPE_SESSION</strong>对应的Scope实现见<strong>org.springframework.web.context.request.SessionScope</strong></p>
<p><strong>WebApplicationContext#SCOPE_REQUEST</strong>对应的Scope实现见<strong>org.springframework.web.context.request.RequestScope</strong></p>
<p>以上两种Scope实现都较为简单，前者将初始化的bean存储在request attribute中，后者将初始化的bean存储在http session中</p>
<h5 id="尝试类型转换" class="heading-element"><span>尝试类型转换</span>
  <a href="#%e5%b0%9d%e8%af%95%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>以上，完成了bean的创建、属性的注入、dispose逻辑的注册，但获得的bean类型与实际需要的类型可能依然不相符，在最终交付bean之前（getBean）还需要进行一次类型转换，使用<strong>PropertyEditor</strong>进行类型转换，将bean转换为真正需要的类型后，便完成了整个getBean的使命</p>
<h4 id="bean销毁过程" class="heading-element"><span>Bean销毁过程</span>
  <a href="#bean%e9%94%80%e6%af%81%e8%bf%87%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>bean的创建过程始于<strong>DefaultListableBeanFactory#getBean</strong>，销毁过程则终于ConfigurableApplicationContext#close，跟踪下去，具体的逻辑在<strong>DefaultSingletonBeanRegistry#destroySingletons</strong></p>
<ol>
<li><strong>DefaultSingletonBeanRegistry.disposableBeans</strong>
需要注册销毁逻辑的bean会被封装为<strong>DisposableBeanAdapter</strong>并缓存在此处</li>
<li><strong>DefaultSingletonBeanRegistry.dependentBeanMap</strong>
对于存在依赖注入关系的bean，会将bean的依赖关系缓存在此处（dependentBeanMap: 哪些bean依赖了我; dependenciesForBeanMap: 我依赖了哪些bean）</li>
</ol>
<figure>
<img
src="https://minio.dionysunrsshub.top/myimages/2024-img/destory.webp"
alt="destory" />
<figcaption aria-hidden="true">destory</figcaption>
</figure>
<p>从上图中可以看出，bean的销毁顺序与创建顺序正好相反，如果有 beanA &ndash;dependsOn&ndash;&gt; beanB &ndash;&gt; beanC ，创建（getBean）时一定是beanC -&gt; beanB -&gt; beanA，销毁时一定是 beanA -&gt; beanB -&gt; beanC，以此避免因为依赖关系造成的一些异常情况</p>
<h4 id="循环依赖" class="heading-element"><span>循环依赖</span>
  <a href="#%e5%be%aa%e7%8e%af%e4%be%9d%e8%b5%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><strong>earlySingletonObject</strong>是用来解决循环依赖的问题，具体时机是在实例化完后属性注入之前，会提前将当前的bean实体暴露出来，以防止在属性注入过程中所注入的bean又依赖当前的bean造成的类似&quot;死锁&quot;的状态</p>
<p>但是存在以下情况，Spring依旧会陷入循环依赖死锁：</p>
<ul>
<li>显式设置dependsOn的循环依赖</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@DependsOn</span><span class="p">(</span><span class="s">&#34;beanB&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">BeanA</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@DependsOn</span><span class="p">(</span><span class="s">&#34;beanC&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">BeanB</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@DependsOn</span><span class="p">(</span><span class="s">&#34;beanA&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">BeanC</span><span class="w"> </span><span class="p">{}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>构造函数循环依赖</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">BeanA</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">BeanA</span><span class="p">(</span><span class="n">BeanB</span><span class="w"> </span><span class="n">beanB</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">BeanB</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">BeanB</span><span class="p">(</span><span class="n">BeanC</span><span class="w"> </span><span class="n">beanC</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">BeanC</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">BeanC</span><span class="p">(</span><span class="n">BeanA</span><span class="w"> </span><span class="n">beanA</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>factory-method循环依赖</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Bean</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="n">BeanA</span><span class="w"> </span><span class="nf">beanA</span><span class="p">(</span><span class="n">BeanB</span><span class="w"> </span><span class="n">beanB</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BeanA</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Bean</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="n">BeanB</span><span class="w"> </span><span class="nf">beanB</span><span class="p">(</span><span class="n">BeanC</span><span class="w"> </span><span class="n">beanC</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BeanB</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Bean</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="n">BeanC</span><span class="w"> </span><span class="nf">beanC</span><span class="p">(</span><span class="n">BeanA</span><span class="w"> </span><span class="n">beanA</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BeanC</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>上述三种依赖混合</li>
</ul>
<p>只要一个循环依赖中的所有bean，其依赖关系都需要在创建bean实例之前进行解决，此循环依赖则一定无解</p>
<p>要打破无解的循环依赖，在构成循环依赖的一个环中，只需要保证其中至少一个Bean的依赖在该Bean创建且暴露<strong>earlySingleton</strong>之后处理即可，即在属性注入阶段进行属性依赖的处理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">BeanA</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Autowired</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">BeanB</span><span class="w"> </span><span class="n">beanB</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">BeanB</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">BeanB</span><span class="p">(</span><span class="n">BeanC</span><span class="w"> </span><span class="n">beanC</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Bean</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="n">BeanC</span><span class="w"> </span><span class="nf">beanC</span><span class="p">(</span><span class="n">BeanA</span><span class="w"> </span><span class="n">beanA</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BeanC</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>以&quot;bean创建且暴露earlySingleton&quot;为节点，在此之前处理依赖的有<code>instance supplier parameter</code>、<code>factory method parameter</code>、<code>constructor parameter</code>、等，在此之后处理的依赖有 <code>class property</code>、<code>setter parameter</code>等</p>
<h1 id="applicationcontext" class="heading-element"><span>ApplicationContext</span>
  <a href="#applicationcontext" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h1><p><strong>BeanFactory</strong>实现了IoC的基础能力，而<strong>ApplicationContext</strong>是<strong>BeanFactory</strong>的子类，除了继承IoC的基础能力外</p>
<ul>
<li>支持国际化 (MessageSource)</li>
<li>支持资源访问 (ResourcePatternResolver)</li>
<li>事件机制 (ApplicationEventPublisher)</li>
<li>默认初始化所有Singleton</li>
<li>提供扩展能力</li>
</ul>
<figure>
<img
src="https://minio.dionysunrsshub.top/myimages/2024-img/ApplicationContext.webp"
alt="ApplicationContext" />
<figcaption aria-hidden="true">ApplicationContext</figcaption>
</figure>
<p>无论何种功能的ApplicationContext，在做完基本的初始化后均会调用<strong>AbstractApplicationContext#Refresh</strong></p>
<h2 id="abstractapplicationcontextrefresh" class="heading-element"><span><code>AbstractApplicationContext#Refresh</code></span>
  <a href="#abstractapplicationcontextrefresh" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><figure>
<img
src="https://minio.dionysunrsshub.top/myimages/2024-img/refresh.webp"
alt="refresh" />
<figcaption aria-hidden="true">refresh</figcaption>
</figure>
<h3 id="准备上下文---abstractapplicationcontextpreparerefresh" class="heading-element"><span>准备上下文 - <code>AbstractApplicationContext#prepareRefresh</code></span>
  <a href="#%e5%87%86%e5%a4%87%e4%b8%8a%e4%b8%8b%e6%96%87---abstractapplicationcontextpreparerefresh" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>该部分主要实现对上下文的准备工作，其主要涉及到两个接口<strong>AbstractApplicationContext#initPropertySources</strong>及<strong>ConfigurablePropertyResolver#validateRequiredProperties</strong>，前者由子类实现，用于初始化PropertySource；后者用于对必要属性进行验证</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MyClasspathXmlApplicationContext</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">ClassPathXmlApplicationContext</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">initPropertySources</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">super</span><span class="p">.</span><span class="na">initPropertySources</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">getEnvironment</span><span class="p">().</span><span class="na">setRequiredProperties</span><span class="p">(</span><span class="s">&#34;runtimeEnv&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>重写<strong>initPropertySources</strong>方法，并添加runtimeEnv为必须的环境变量属性，如此在系统启动的时候便会进行检测，对于不存在任何一个必要环境变量的情况均会抛出异常终止启动</p>
<h3 id="加载beanfactory---abstractapplicationcontextobtainfreshbeanfactory" class="heading-element"><span>加载BeanFactory - <code>AbstractApplicationContext#obtainFreshBeanFactory</code></span>
  <a href="#%e5%8a%a0%e8%bd%bdbeanfactory---abstractapplicationcontextobtainfreshbeanfactory" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>该函数内部实现比较简单，重点在<strong>refreshBeanFactory</strong>，该函数同样由子类实现</p>
<p>对于<strong>AbstractRefreshableApplicationContext</strong>，refreshBeanFactory基本步骤为</p>
<ol>
<li>创建BeanFactory (<strong>DefaultListableBeanFactory</strong>)</li>
<li>设置BeanFactory</li>
<li><strong><a href="#Bean%e7%9a%84%e6%b3%a8%e5%86%8c" title="wikilink">加载BeanDefinition</a></strong></li>
</ol>
<p>在第3步中，AbstractXmlApplicationContext的实现则是对xml配置文件的解析及加载；AnnotationConfigWebApplicationContext的实现则是对class文件的扫描并加载，以及其他基于AbstractRefreshableApplicationContext的ApplicationContext实现</p>
<p>对于<strong>GenericApplicationContext</strong>，BeanFactory的创建及BeanDefinition的加载在<strong>refresh</strong>调用之前早已完成，refreshBeanFactory的实现则是对BeanFactory加载状态的简单校验</p>
<h4 id="abstractrefreshableapplicationcontext--genericapplicationcontext" class="heading-element"><span>AbstractRefreshableApplicationContext &amp; GenericApplicationContext</span>
  <a href="#abstractrefreshableapplicationcontext--genericapplicationcontext" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><h5 id="abstractrefreshableapplicationcontext" class="heading-element"><span>AbstractRefreshableApplicationContext</span>
  <a href="#abstractrefreshableapplicationcontext" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>对于继承自 <code>AbstractRefreshableApplicationContext</code> 的上下文，例如 <code>ClassPathXmlApplicationContext</code> 或 <code>AnnotationConfigApplicationContext</code>，它们通过覆盖 <code>refreshBeanFactory()</code> 方法来实现具体的 BeanDefinition 加载逻辑。这些上下文类型专门用于从外部资源（如 XML 文件、Java 配置类等）加载配置信息，并将这些配置信息解析为一组 BeanDefinition，然后注册到内部的 BeanFactory 中。这个过程通常发生在上下文的 <code>refresh()</code> 方法调用过程中（我们正在讨论的），这个方法不仅负责加载和注册 BeanDefinition，还包括初始化单例bean、处理别名定义、注册BeanPostProcessor等一系列容器启动时的活动。</p>
<blockquote>
<p>[!QUOTE] refresh()关键步骤 ^configurerRelated</p>
<ol>
<li><strong>创建 BeanFactory</strong>：<code>AbstractRefreshableApplicationContext</code> 首先会创建一个新的 <code>BeanFactory</code> 实例，这通常是一个 <code>DefaultListableBeanFactory</code> 实例。这个 <code>BeanFactory</code> 实现了 <code>BeanDefinitionRegistry</code> 接口，使得它能够注册 BeanDefinition。</li>
<li>==<strong>加载 BeanDefinition</strong>：接着，上下文会调用特定的方法（例如，对于基于 XML 的配置，会使用 <code>XmlBeanDefinitionReader</code>；对于基于注解的配置，会使用 <code>AnnotatedBeanDefinitionReader</code> 和 <code>ClassPathBeanDefinitionScanner</code>）来加载 BeanDefinition。这些 Reader 和 Scanner 实现了 <code>BeanDefinitionRegistry</code> 接口的 <code>registerBeanDefinition</code> 方法来实际完成注册工作。==</li>
<li><strong>刷新 BeanFactory</strong>：加载完所有 BeanDefinition 后，<code>AbstractRefreshableApplicationContext</code> 会对 <code>BeanFactory</code> 进行刷新，这涉及到预实例化单例、注册 <code>BeanPostProcessor</code>、初始化剩余的非懒加载单例等一系列操作。</li>
<li><strong>发布事件</strong>：在整个容器刷新过程中，还会发布各种应用事件，如 <code>ContextRefreshedEvent</code>，允许应用中的其他组件对这些事件作出响应。</li>
</ol>
<p>通过上述步骤，<code>AbstractRefreshableApplicationContext</code> 完成了 BeanDefinition 的加载、注册以及整个 Spring 容器的初始化和刷新工作。在这个过程中，<code>BeanDefinitionRegistry</code> 接口扮演了 BeanDefinition 注册的关键角色</p>
<h5 id="genericapplicationcontext" class="heading-element"><span>GenericApplicationContext</span>
  <a href="#genericapplicationcontext" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5></blockquote>
<p><code>GenericApplicationContext</code> 直接实现了 <code>BeanDefinitionRegistry</code> 接口，使得它可以在运行时动态注册 BeanDefinition。与 <code>AbstractRefreshableApplicationContext</code> 的子类不同，<code>GenericApplicationContext</code> 并不专门依赖于外部资源来加载 BeanDefinition。相反，它提供了一套程序化的接口，允许开发者直接在代码中通过调用 <code>registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</code> 方法来注册 BeanDefinition。这种方式使得 <code>GenericApplicationContext</code> 非常灵活，适用于那些需要在运行时动态调整 Spring 配置的场景。</p>
<h5 id="关系和区别" class="heading-element"><span>关系和区别</span>
  <a href="#%e5%85%b3%e7%b3%bb%e5%92%8c%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><ul>
<li><strong>加载方式的区别</strong>：<code>AbstractRefreshableApplicationContext</code> 的子类通常通过解析配置资源（XML、注解等）来加载 BeanDefinition，而 <code>GenericApplicationContext</code> 允许以编程方式直接注册 BeanDefinition。</li>
<li><strong>使用场景的区别</strong>：<code>AbstractRefreshableApplicationContext</code> 的子类适合于静态配置资源的场景，其中配置信息在应用启动时已经确定。<code>GenericApplicationContext</code> 更适合于动态配置的场景，比如基于条件的 BeanDefinition 注册或运行时的配置调整。</li>
<li><strong>刷新容器的能力</strong>：虽然两者都可以通过 <code>refresh()</code> 方法来刷新应用上下文，但 <code>AbstractRefreshableApplicationContext</code> 的子类通常在设计时就考虑了完整的容器刷新流程（包括重新加载配置资源），而 <code>GenericApplicationContext</code> 刷新主要是为了应用新注册的 BeanDefinition。==前者会重置BeanFactory而后者不会==</li>
</ul>
<h3 id="填充部分扩展---abstractapplicationcontextpreparebeanfactory" class="heading-element"><span>填充部分扩展 - <code>AbstractApplicationContext#prepareBeanFactory</code></span>
  <a href="#%e5%a1%ab%e5%85%85%e9%83%a8%e5%88%86%e6%89%a9%e5%b1%95---abstractapplicationcontextpreparebeanfactory" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>该函数执行以下逻辑</p>
<ol>
<li>设置BeanFactory的ClassLoader</li>
<li>注册默认<strong>BeanExpressionResolver</strong>，用于依赖注入时SpEL的支持</li>
<li>注册默认<strong>PropertyEditor</strong>，用于依赖注入时对参数的解析转换</li>
<li>注册几个特殊Aware的处理逻辑</li>
<li>注册AspectJ相关的几个处理器，用于AOP的支持</li>
<li>注册几个特殊的BeanDefinition</li>
</ol>
<p>==2-3 的核心逻辑在于解析依赖的值，<code>DefaultListableBenFactory#doResolveDependency</code>==</p>
<h4 id="注册几个特殊aware的处理逻辑" class="heading-element"><span>注册几个特殊Aware的处理逻辑</span>
  <a href="#%e6%b3%a8%e5%86%8c%e5%87%a0%e4%b8%aa%e7%89%b9%e6%ae%8aaware%e7%9a%84%e5%a4%84%e7%90%86%e9%80%bb%e8%be%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>在Bean实例化、注入依赖之后会对Bean进行[最后的初始化](#初始化 - <code>AbstractAutowireCapableBeanFactory initializeBean</code> &ldquo;wikilink&rdquo;)，调用相应的setter方法分别针对<strong>BeanNameAware</strong>、<strong>BeanClassLoaderAware</strong>、<strong>BeanFactoryAware</strong>进行处理</p>
<p>在该函数中，会注册几个特殊的<strong>BeanPostProcessor</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">beanFactory</span><span class="p">.</span><span class="na">addBeanPostProcessor</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ApplicationContextAwareProcessor</span><span class="p">(</span><span class="k">this</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其实现了<strong>postProcessBeforeInitialization</strong>方法，内部调用<strong>ApplicationContextAwareProcessor#invokeAwareInterfaces</strong>针对另外的几类Aware进行了处理</p>
<p>除此之外，Spring会将上述几类Aware设置为<strong>ignoreDependencyInterface</strong>，这意味着以上几类Bean的注入只能通过Aware的方式而不能通过其他属性依赖注入的方式（属性注入、函数参数注入等）</p>
<h4 id="注册特殊的bean" class="heading-element"><span>注册特殊的Bean</span>
  <a href="#%e6%b3%a8%e5%86%8c%e7%89%b9%e6%ae%8a%e7%9a%84bean" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>在使用Spring时，是否有过直接注入<strong>BeanFactory</strong>亦或是<strong>ResourceLoader</strong>，这些bean正是在这里被Spring注册进去的，除以上外Spring还注入了</p>
<ul>
<li>BeanFactory</li>
<li>ResourceLoader</li>
<li>ApplicationEventPublisher</li>
<li>ApplicationContext</li>
<li>Environment</li>
<li><em>systemProperties</em> - Environment#.getSystemProperties:Map&lt;String, Object&gt;</li>
<li>systemEnvironment - Environment#.getSystemEnvironment:Map&lt;String, Object&gt;
<h3 id="abstractapplicationcontextrefreshpostprocessbeanfactory" class="heading-element"><span><code>AbstractApplicationContext#refresh#postProcessBeanFactory()</code></span>
  <a href="#abstractapplicationcontextrefreshpostprocessbeanfactory" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3></li>
</ul>
<p>对于不同的实现类，注册相应的<code>BeanPostProcessor</code>，例如<code>ServletWebServerApplicationContext</code></p>
<h3 id="激活beanfactorypostprocessor---abstractapplicationcontextinvokebeanfactorypostprocessors" class="heading-element"><span>激活BeanFactoryPostProcessor - <code>AbstractApplicationContext#invokeBeanFactoryPostProcessors</code></span>
  <a href="#%e6%bf%80%e6%b4%bbbeanfactorypostprocessor---abstractapplicationcontextinvokebeanfactorypostprocessors" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>其内部实现在<strong>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors</strong></p>
<p><strong>BeanFactoryPostProcessor</strong>的定义非常简单，其<strong>postProcessBeanFactory</strong>方法允许在bean实例化前对BeanFactory做一些额外的设置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">BeanFactoryPostProcessor</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Modify the application context&#39;s internal bean factory after its standard
</span></span></span><span class="line"><span class="cl"><span class="cm">     * initialization. All bean definitions will have been loaded, but no beans
</span></span></span><span class="line"><span class="cl"><span class="cm">     * will have been instantiated yet. This allows for overriding or adding
</span></span></span><span class="line"><span class="cl"><span class="cm">     * properties even to eager-initializing beans.
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">postProcessBeanFactory</span><span class="p">(</span><span class="n">ConfigurableListableBeanFactory</span><span class="w"> </span><span class="n">beanFactory</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>核心逻辑如下</p>
<figure>
<img
src="https://minio.dionysunrsshub.top/myimages/2024-img/invokeBeanFactoryPostProcessors.webp"
alt="invokeBeanFactoryPostProcessors" />
<figcaption
aria-hidden="true">invokeBeanFactoryPostProcessors</figcaption>
</figure>
<p>其中涉及两种类型，<strong>BeanDefinitionRegistryPostProcessor</strong>及<strong>BeanFactoryPostProcessor</strong>，前者为后者的子类，<strong>BeanDefinitionRegistryPostProcessors</strong>提供了额外的接口<strong>postProcessBeanDefinitionRegistry</strong>，用于更加方便地<strong>动态</strong>地注册额外的BeanDefinition (<code>registryProcessor.postProcessBeanDefinitionRegistry(registry)</code>)，如读取配置文件（json、properties、yml）并解析（或者任何其他的形式），并通过该接口注册相应的BeanDefinition，基于Spring Boot Starter的很多框架均使用该方式进行bean的注册</p>
<p>以上流程图可以看出，优先执行<strong>BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry</strong>，再执行<strong>BeanFactoryPostProcessor#postProcessBeanFactory</strong>，各自内部优先执行<strong>PriorityOrdered</strong>实现，再执行<strong>Ordered</strong>实现，最后执行无任何排序的实现</p>
<h3 id="注册beanpostprocessor---abstractapplicationcontextregisterbeanpostprocessors" class="heading-element"><span>注册BeanPostProcessor - <code>AbstractApplicationContext#registerBeanPostProcessors</code></span>
  <a href="#%e6%b3%a8%e5%86%8cbeanpostprocessor---abstractapplicationcontextregisterbeanpostprocessors" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>其内部实现在<strong>PostProcessorRegistrationDelegate#registerBeanPostProcessors</strong>
b</p>
<h4 id="beanpostprocessor" class="heading-element"><span>BeanPostProcessor</span>
  <a href="#beanpostprocessor" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">BeanPostProcessor</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Apply this BeanPostProcessor to the given new bean instance before any bean
</span></span></span><span class="line"><span class="cl"><span class="cm">     * initialization callbacks (like InitializingBean&#39;s afterPropertiesSet
</span></span></span><span class="line"><span class="cl"><span class="cm">     * or a custom init-method). 
</span></span></span><span class="line"><span class="cl"><span class="cm">     * The returned bean instance may be a wrapper around the original.
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Nullable</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">default</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">postProcessBeforeInitialization</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">bean</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">bean</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Apply this BeanPostProcessor to the given new bean instance after any bean
</span></span></span><span class="line"><span class="cl"><span class="cm">     * initialization callbacks (like InitializingBean&#39;s afterPropertiesSet
</span></span></span><span class="line"><span class="cl"><span class="cm">     * or a custom init-method).
</span></span></span><span class="line"><span class="cl"><span class="cm">     * The returned bean instance may be a wrapper around the original.
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Nullable</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">default</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">postProcessAfterInitialization</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">bean</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">bean</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>postProcessBeforeInitialization方法在调用bean的init-method之前执行</li>
<li>postProcessAfterInitialization方法在调用bean的init-method之后执行</li>
<li>任何一个方法可对现有bean实例做进一步的修改</li>
<li>任何一个方法可返回新的bean实例，用来替代现有的bean实例</li>
</ol>
<p>第四点即是AOP生成当前Bean代理的方法</p>
<h5 id="instantiationawarebeanpostprocessor" class="heading-element"><span>InstantiationAwareBeanPostProcessor</span>
  <a href="#instantiationawarebeanpostprocessor" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>该接口继承自<strong>BeanPostProcessor</strong>，其同样有两个方法，一个在创建bean实例之前调用([createBean](#<code>AbstractAutowireCapableBeanFactory createBean</code> &ldquo;wikilink&rdquo;))，一个在创建bean实例之后、属性注入之前调用([属性注入](#属性注入 - <code>AbstractAutowireCapableBeanFactory populateBean</code> &ldquo;wikilink&rdquo;))</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">InstantiationAwareBeanPostProcessor</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">BeanPostProcessor</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Nullable</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">default</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">postProcessBeforeInstantiation</span><span class="p">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span><span class="w"> </span><span class="n">beanClass</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">default</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">postProcessAfterInstantiation</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">bean</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Nullable</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">default</span><span class="w"> </span><span class="n">PropertyValues</span><span class="w"> </span><span class="nf">postProcessProperties</span><span class="p">(</span><span class="n">PropertyValues</span><span class="w"> </span><span class="n">pvs</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="n">bean</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">pvs</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>AbstractApplicationContext#registerBeanPostProcessors</strong>，其内部逻辑与BeanFactoryPostProcessor的注册逻辑类似：</p>
<ol>
<li>找到所有BeanPostProcessor并实例化</li>
<li>按照实现的Ordered接口分别放入priorityOrderedPostProcessors、orderedPostProcessors、nonOrderedPostProcessors并各自排序</li>
<li>如果实现了MergedBeanDefinitionPostProcessor则放入internalPostProcessors并排序</li>
<li>按顺序依次注册priorityOrderedPostProcessors、orderedPostProcessors、nonOrderedPostProcessors</li>
<li>最后注册internalPostProcessors</li>
</ol>
<p><strong>MergedBeanDefinitionPostProcessor</strong>其有一个接口<strong>postProcessMergedBeanDefinition</strong>，在bean实例化完成后属性注入之前被调用，可以用来对当前的BeanDefinition做进一步的修改，如增加PropertyValue等，实现特殊的属性依赖注入，参考[BeanDefinition后处理](#BeanDefinition后处理 - <code>AbstractAutowireCapableBeanFactory applyMergedBeanDefinitionPostProcessors</code> &ldquo;wikilink&rdquo;)与[属性注入](#属性注入 - <code>AbstractAutowireCapableBeanFactory populateBean</code> &ldquo;wikilink&rdquo;)</p>
<h3 id="初始化messagesource---abstractapplicationcontextinitmessagesource" class="heading-element"><span>初始化MessageSource - <code>AbstractApplicationContext#initMessageSource</code></span>
  <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96messagesource---abstractapplicationcontextinitmessagesource" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Spring的<strong>MessageSource</strong>提供了国际化能力，在开发者未注册MessageSource的情况下Spring会提供一个默认的<strong>DelegatingMessageSource</strong></p>
<h3 id="初始化applicationeventmulticaster---abstractapplicationcontextinitapplicationeventmulticaster" class="heading-element"><span>初始化ApplicationEventMulticaster - <code>AbstractApplicationContext#initApplicationEventMulticaster</code></span>
  <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96applicationeventmulticaster---abstractapplicationcontextinitapplicationeventmulticaster" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Spring提供了一套事件（ApplicationEvent）的发布&amp;订阅机制，开发者可自定义事件（继承<strong>ApplicationEvent</strong>），注册事件监听器来订阅消费事件（实现<strong>ApplicationListener</strong> 或使用<code>@EventListener</code> 注解），并使用<strong>ApplicationEventPublisher</strong>（直接依赖注入或者使用<strong>ApplicationEventPublisherAware</strong>）发送事件，使用示例可参考<a href="https://link.segmentfault.com/?enc=4cCMPoMwXwyBCW1s98GYow%3D%3D.zKZN5tVMJt9hm6zq2%2B3EFcY86QBjsZcPTtzSUaDvc8amL7BSpuMwZBbobUSICoS%2B"target="_blank" rel="external nofollow noopener noreferrer">https://www.baeldung.com/spri&hellip;</a></p>
<p>其实ApplicationContext实现了ApplicationEventPublisher，跟踪其publishEvent方法会发现，最终调用了<strong>AbstractApplicationContext#applicationEventMulticaster.multicastEvent</strong>，开发者可以自行注册一个<strong>ApplicationEventMulticaster</strong>，如果没有Spring会提供一个默认的<strong>SimpleApplicationEventMulticaster</strong></p>
<p><strong>SimpleApplicationEventMulticaster#multicastEvent</strong>的逻辑比较简单，会根据事件的类型找到可以处理的所有<strong>ApplicationListener</strong>，依次调用它们的<strong>onApplicationEvent</strong>方法消费事件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">multicastEvent</span><span class="p">(</span><span class="kd">final</span><span class="w"> </span><span class="n">ApplicationEvent</span><span class="w"> </span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="nd">@Nullable</span><span class="w"> </span><span class="n">ResolvableType</span><span class="w"> </span><span class="n">eventType</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ResolvableType</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">eventType</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">eventType</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">resolveDefaultEventType</span><span class="p">(</span><span class="n">event</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Executor</span><span class="w"> </span><span class="n">executor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getTaskExecutor</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ApplicationListener</span><span class="o">&lt;?&gt;</span><span class="w"> </span><span class="n">listener</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">getApplicationListeners</span><span class="p">(</span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">executor</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c1">// 设置了executor，则异步执行</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">executor</span><span class="p">.</span><span class="na">execute</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">invokeListener</span><span class="p">(</span><span class="n">listener</span><span class="p">,</span><span class="w"> </span><span class="n">event</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c1">// 否则同步执行</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">invokeListener</span><span class="p">(</span><span class="n">listener</span><span class="p">,</span><span class="w"> </span><span class="n">event</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>默认情况下会同步、顺序的调用listeners的onApplicationEvent方法，只有设置了executor才会异步调用，不过这样的控制粒度比较粗，要么全部同步消费要么全部异步消费，比较细粒度的控制事件的消费有几种常用方法</p>
<ol>
<li>使用@Async注解，独立控制某一listener异步消费（<a href="https://link.segmentfault.com/?enc=4rWP3QJ9vlr387BZsONaMg%3D%3D.W43YbA7ycrHpfL3%2FPNVlG%2BEx21WzzhgH1DTfOK4vDavSLj8oIqkTtiWfo2eOrQGz"target="_blank" rel="external nofollow noopener noreferrer">https://www.baeldung.com/spri&hellip;</a>）</li>
<li>自行编码，将<strong>onApplicationEvent</strong>逻辑放在线程中执行</li>
<li>注册自定义的<strong>ApplicationEventMulticaster</strong>，内部实现自己的同步、异步Event处理逻辑</li>
</ol>
<h3 id="注册applicationlistener---abstractapplicationcontextregisterlisteners" class="heading-element"><span>注册ApplicationListener - <code>AbstractApplicationContext#registerListeners</code></span>
  <a href="#%e6%b3%a8%e5%86%8capplicationlistener---abstractapplicationcontextregisterlisteners" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>这里的逻辑比较简单</p>
<ol>
<li>在BeanFactory中找到ApplicationListener类型的bean并实例化</li>
<li>调用<strong>ApplicationEventMulticaster#addApplicationListenerBean</strong>方法将ApplicationListeners注册进去</li>
</ol>
<h3 id="初始化所有非lazy-bean---abstractapplicationcontextfinishbeanfactoryinitialization" class="heading-element"><span>初始化所有非Lazy Bean - <code>AbstractApplicationContext#finishBeanFactoryInitialization</code></span>
  <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96%e6%89%80%e6%9c%89%e9%9d%9elazy-bean---abstractapplicationcontextfinishbeanfactoryinitialization" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>对于Singleton Bean而言，实例化发生在首次getBean，但你是否有疑惑，我们只是注册了众多Singleton Bean，但在Spring初始化完成后所有的Singleton Bean（Lazy Bean除外）均已经完成实例化</p>
<p>回到<strong>AbstractApplicationContext#finishBeanFactoryInitialization</strong>，该函数会实现几个逻辑</p>
<ol>
<li>如果自定义了<strong>ConversionService</strong>(另一种注入类型转换的方式)类型bean且bean-name为<em>conversionService</em>，则将其注册到BeanFactory中</li>
<li>如果BeanFactory中不存在<strong>EmbeddedValueResolver</strong>（<strong>PropertyResourceConfigurer</strong>会注册一个<strong>PlaceholderResolvingStringValueResolver</strong>到BeanFactory中），则会注册一个默认的<strong>StringValueResolver</strong>用来处理 <code>${ ... }</code>类型的值（<strong>Environment#resolvePlaceholders</strong>）</li>
<li>找到所有非Lazy的Singleton BeanDefinition进行实例化（<strong>getBean</strong>）
<ol>
<li>如果是FactoryBean，则在bean name前加上&rsquo;&amp;&rsquo;，并实例化该FactoryBean，随后实例化真实的bean</li>
<li>如果不是FactoryBean，则直接实例化该bean</li>
</ol>
</li>
<li>执行<strong>SmartInitializingSingleton</strong>实现类的<strong>afterSingletonsInstantiated</strong>方法</li>
</ol>
<h3 id="refresh的后续动作---abstractapplicationcontextfinishrefresh" class="heading-element"><span>Refresh的后续动作 - <code>AbstractApplicationContext#finishRefresh</code></span>
  <a href="#refresh%e7%9a%84%e5%90%8e%e7%bb%ad%e5%8a%a8%e4%bd%9c---abstractapplicationcontextfinishrefresh" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>除了一些中间状态需要清理外，还有两件比较特殊的地方</p>
<h4 id="lifecycleprocessor---abstractapplicationcontextinitlifecycleprocessor" class="heading-element"><span>LifecycleProcessor - <code>AbstractApplicationContext#initLifecycleProcessor</code></span>
  <a href="#lifecycleprocessor---abstractapplicationcontextinitlifecycleprocessor" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>Spring提供了<strong>LifecycleProcessor</strong>用于监听BeanFactory的refresh及close，在BeanFactory的各阶段会调用<strong>LifecycleProcessor</strong>的<strong>onFresh</strong>及<strong>onClose</strong>方法</p>
<p>开发者可以自行注册<strong>LifecycleProcessor</strong>类型的bean，bean-name必须为&quot;lifecycleProcessor&quot;，否则Spring会提供一个默认的<strong>DefaultLifecycleProcessor</strong></p>
<p>之后则会触发<strong>LifecycleProcessor</strong>的<strong>onFresh</strong>方法</p>
<blockquote>
<p>除此之外，还可以监听<strong>ContextRefreshedEvent</strong>及<strong>ContextClosedEvent</strong>消息</p>
</blockquote>
<h4 id="refresh事件" class="heading-element"><span>refresh事件</span>
  <a href="#refresh%e4%ba%8b%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>在BeanFactory初始化完成后，则会发出<strong>ContextRefreshedEvent</strong>事件</p>
<h3 id="beanfactory的销毁---abstractapplicationcontextregistershutdownhook" class="heading-element"><span>BeanFactory的销毁 - <code>AbstractApplicationContext#registerShutdownHook</code></span>
  <a href="#beanfactory%e7%9a%84%e9%94%80%e6%af%81---abstractapplicationcontextregistershutdownhook" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>该函数用来注册BeanFactory的销毁逻辑</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">registerShutdownHook</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">shutdownHook</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">shutdownHook</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(</span><span class="s">&#34;SpringContextShutdownHook&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kd">synchronized</span><span class="p">(</span><span class="n">AbstractApplicationContext</span><span class="p">.</span><span class="na">this</span><span class="p">.</span><span class="na">startupShutdownMonitor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">AbstractApplicationContext</span><span class="p">.</span><span class="na">this</span><span class="p">.</span><span class="na">doClose</span><span class="p">();</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">};</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Runtime</span><span class="p">.</span><span class="na">getRuntime</span><span class="p">().</span><span class="na">addShutdownHook</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">shutdownHook</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其直接使用了java的<strong>addShutdownHook</strong>函数，在jvm进程<strong>正常</strong>退出的时候触发</p>
<p><strong>AbstractApplicationContext#doClose</strong>函数定义了BeanFactory具体的销毁过程</p>
<ol>
<li>发出<strong>ContextClosedEvent</strong>事件</li>
<li>触发<strong>LifecycleProcessor</strong>的<strong>onClose</strong>方法</li>
<li>销毁bean，细节参考<a href="#Bean%e9%94%80%e6%af%81%e8%bf%87%e7%a8%8b" title="wikilink">Bean销毁过程</a></li>
<li>由子类实现的<strong>AbstractApplicationContext#closeBeanFactory</strong>及<strong>AbstractApplicationContext#onClose</strong>方法</li>
</ol>
<h2 id="aside" class="heading-element"><span>ASIDE</span>
  <a href="#aside" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>BeanDefinition的加载在[AbstractApplicationContext#obtainFreshBeanFactory](#加载BeanFactory - <code>AbstractApplicationContext obtainFreshBeanFactory</code> &ldquo;wikilink&rdquo;)中实现</li>
<li>TODO
<ul>
<li><code>#{ ... }</code>类型值的解析由<strong>StandardBeanExpressionResolve</strong>实现</li>
<li><code>${ ... }</code>类型值的解析由<strong>PlaceholderResolvingStringValueResolver</strong>实现</li>
<li>Spring提供了众多默认的PropertyEditor，若需要自定义PropertyEditor可以通过注册<strong>CustomEditorConfigurer</strong>实现</li>
<li>Spring提供了众多Aware，若需要自定义Aware可以通过<strong>BeanPostProcessor</strong>实现</li>
<li>BeanFactoryPostProcessor用于在实例化bean之前对BeanFactory做额外的动作
如，<strong>PropertyResourceConfigurer</strong>用来将<strong>PlaceholderResolvingStringValueResolver</strong>注册到BeanFactory的embeddedValueResolvers中</li>
</ul>
</li>
<li>[BeanDefinitionRegistryPostProcessor](#激活BeanFactoryPostProcessor - <code>AbstractApplicationContext invokeBeanFactoryPostProcessors</code> &ldquo;wikilink&rdquo;)用于在实例化bean之前（动态）注册额外的BeanDefinition ^fa1ce8</li>
<li><a href="#BeanPostProcessor" title="wikilink">BeanPostProcessor</a>用于在调用bean的init-method前后，对实例化完成的bean做一些额外的干预
如，<strong>CommonAnnotationBeanPostProcessor</strong>用来处理@PostConstructor，<strong>AbstractAdvisingBeanPostProcessor</strong>用来实现AOP</li>
</ul>
<h1 id="applicationcontext具体实现类---annotationconfigapplicationcontext" class="heading-element"><span>ApplicationContext具体实现类 - AnnotationConfigApplicationContext</span>
  <a href="#applicationcontext%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0%e7%b1%bb---annotationconfigapplicationcontext" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h1><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="nf">AnnotationConfigApplicationContext</span><span class="p">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span><span class="p">...</span><span class="w"> </span><span class="n">componentClasses</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">();</span><span class="w"> </span><span class="c1">//1. 首先会调用自己的无参构造 </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">register</span><span class="p">(</span><span class="n">componentClasses</span><span class="p">);</span><span class="w"> </span><span class="c1">//2. 然后注册我们传入的配置类 </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">refresh</span><span class="p">();</span><span class="w"> </span><span class="c1">//3. 最后进行刷新操作（关键） </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="无参构造" class="heading-element"><span>无参构造</span>
  <a href="#%e6%97%a0%e5%8f%82%e6%9e%84%e9%80%a0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="nf">AnnotationConfigApplicationContext</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">StartupStep</span><span class="w"> </span><span class="n">createAnnotatedBeanDefReader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">getApplicationStartup</span><span class="p">().</span><span class="na">start</span><span class="p">(</span><span class="s">&#34;spring.context.annotated-bean-reader.create&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c1">//创建AnnotatedBeanDefinitionReader对象，用于后续处理 @Bean 注解</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">reader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AnnotatedBeanDefinitionReader</span><span class="p">(</span><span class="k">this</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">createAnnotatedBeanDefReader</span><span class="p">.</span><span class="na">end</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c1">//创建ClassPathBeanDefinitionScanner对象，用于扫描类路径上的Bean</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">scanner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ClassPathBeanDefinitionScanner</span><span class="p">(</span><span class="k">this</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="annotatedbeandefinitionreader" class="heading-element"><span>AnnotatedBeanDefinitionReader</span>
  <a href="#annotatedbeandefinitionreader" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="nf">AnnotatedBeanDefinitionReader</span><span class="p">(</span><span class="n">BeanDefinitionRegistry</span><span class="w"> </span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="n">Environment</span><span class="w"> </span><span class="n">environment</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Assert</span><span class="p">.</span><span class="na">notNull</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;BeanDefinitionRegistry must not be null&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Assert</span><span class="p">.</span><span class="na">notNull</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Environment must not be null&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">registry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">registry</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">conditionEvaluator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConditionEvaluator</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="n">environment</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c1">//这里注册了注解处理配置相关的后置处理器</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">AnnotationConfigUtils</span><span class="p">.</span><span class="na">registerAnnotationConfigProcessors</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">registry</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里会将ConfigurationClassPostProcessor后置处理器加入到BeanFactory中，它继承自BeanFactoryPostProcessor，也就是说一会会在BeanFactory初始化完成之后进行后置处理，同时这里也会注册一个<a href="#%5eautowiredAnnotationBeanPostProcessor1" title="wikilink">AutowiredAnnotationBeanPostProcessor</a>后置处理器到BeanFactory，它继承自BeanPostProcessor，用于处理后续生成的Bean对象，其实看名字就知道，这玩意就是为了处理@Autowire、@Value这种注解，用于自动注入</p>
<h2 id="注册传入的配置类---register" class="heading-element"><span>注册传入的配置类 - <code>register</code></span>
  <a href="#%e6%b3%a8%e5%86%8c%e4%bc%a0%e5%85%a5%e7%9a%84%e9%85%8d%e7%bd%ae%e7%b1%bb---register" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">register</span><span class="p">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span><span class="p">...</span><span class="w"> </span><span class="n">componentClasses</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Assert</span><span class="p">.</span><span class="na">notEmpty</span><span class="p">(</span><span class="n">componentClasses</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;At least one component class must be specified&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">StartupStep</span><span class="w"> </span><span class="n">registerComponentClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">getApplicationStartup</span><span class="p">().</span><span class="na">start</span><span class="p">(</span><span class="s">&#34;spring.context.component-classes.register&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="na">tag</span><span class="p">(</span><span class="s">&#34;classes&#34;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Arrays</span><span class="p">.</span><span class="na">toString</span><span class="p">(</span><span class="n">componentClasses</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c1">//使用我们上面创建的Reader注册配置类</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">reader</span><span class="p">.</span><span class="na">register</span><span class="p">(</span><span class="n">componentClasses</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">registerComponentClass</span><span class="p">.</span><span class="na">end</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="refreshabstractapplicationcontext-refresh-wikilink" class="heading-element"><span>[Refresh](#<code>AbstractApplicationContext Refresh</code> &ldquo;wikilink&rdquo;)</span>
  <a href="#refreshabstractapplicationcontext-refresh-wikilink" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h1 id="todo" class="heading-element"><span>==TODO==</span>
  <a href="#todo" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h1><ul>
<li>☒ Spring AOP</li>
<li>☐ 注解运行逻辑
<ul>
<li><a href="https://www.jianshu.com/p/3fbfbb843b63"target="_blank" rel="external nofollow noopener noreferrer"><code>@Component</code>与<code>@Bean</code>的区别</a></li>
<li><a href="JavaSSM#%5e473168" title="wikilink">JavaSSM#^473168</a></li>
<li>☐ @Bean 在处理属性注入时？</li>
</ul>
</li>
<li>☒ AnnotationConfigApplicationContext - 与 配置类的关系 - 具体例子</li>
<li>☐ BeanDefinitionReader和BeanDefinitionRegistry</li>
<li>☐ 完善调用链图
<h1 id="配置类的注册---configurationclasspostprocessor" class="heading-element"><span>配置类的注册 - <code>ConfigurationClassPostProcessor</code></span>
  <a href="#%e9%85%8d%e7%bd%ae%e7%b1%bb%e7%9a%84%e6%b3%a8%e5%86%8c---configurationclasspostprocessor" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h1></li>
</ul>
<p>ConfigurationClassPostProcessor继承自<a href="#%5efa1ce8" title="wikilink">BeanDefinitionRegistryPostProcessor</a> -&gt; BeanFactoryPostProcessor，这个后置处理器是Spring中提供的，这是专门用于处理配置类的后置处理器，其中<code>ImportBeanDefinitionRegistrar</code>，还有<code>ImportSelector</code>都是靠它来处理</p>
<h2 id="configurationclasspostprocessorpostprocessbeandefinitionregistry" class="heading-element"><span><code>ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry</code></span>
  <a href="#configurationclasspostprocessorpostprocessbeandefinitionregistry" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>内部调用 <strong>processConfigBeanDefinitions(BeanDefinitionRegistry)</strong> 方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">processConfigBeanDefinitions</span><span class="p">(</span><span class="n">BeanDefinitionRegistry</span><span class="w"> </span><span class="n">registry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 将Spring认为可能是配置类的候选类加入candidates，例如@Configuration、@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// @ComponentScan、@Import，以及通过实现ImportSelector或ImportBeanDefinitionRegistrar间接引入的配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">List</span><span class="o">&lt;</span><span class="n">BeanDefinitionHolder</span><span class="o">&gt;</span><span class="w"> </span><span class="n">configCandidates</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 直接取出所有已注册Bean的名称</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">candidateNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">registry</span><span class="p">.</span><span class="na">getBeanDefinitionNames</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">candidateNames</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="c1">// 依次拿到对应的Bean定义，然后进行判断</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">BeanDefinition</span><span class="w"> </span><span class="n">beanDef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">registry</span><span class="p">.</span><span class="na">getBeanDefinition</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">beanDef</span><span class="p">.</span><span class="na">getAttribute</span><span class="p">(</span><span class="n">ConfigurationClassUtils</span><span class="p">.</span><span class="na">CONFIGURATION_CLASS_ATTRIBUTE</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="c1">// 检查一个Bean定义是否符合作为配置类的条件，即使它没有直接使用@Configuration注解</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ConfigurationClassUtils</span><span class="p">.</span><span class="na">checkConfigurationClassCandidate</span><span class="p">(</span><span class="n">beanDef</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">metadataReaderFactory</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="n">configCandidates</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">BeanDefinitionHolder</span><span class="p">(</span><span class="n">beanDef</span><span class="p">,</span><span class="w"> </span><span class="n">beanName</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 如果一个打了 @Configuration 的类都没发现，直接返回</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">configCandidates</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 对所有的配置类依据 @Order 进行排序</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">configCandidates</span><span class="p">.</span><span class="na">sort</span><span class="p">((</span><span class="n">bd1</span><span class="p">,</span><span class="w"> </span><span class="n">bd2</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="kt">int</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ConfigurationClassUtils</span><span class="p">.</span><span class="na">getOrder</span><span class="p">(</span><span class="n">bd1</span><span class="p">.</span><span class="na">getBeanDefinition</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="kt">int</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ConfigurationClassUtils</span><span class="p">.</span><span class="na">getOrder</span><span class="p">(</span><span class="n">bd2</span><span class="p">.</span><span class="na">getBeanDefinition</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">return</span><span class="w"> </span><span class="n">Integer</span><span class="p">.</span><span class="na">compare</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="w"> </span><span class="n">i2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 这里使用do-while语句依次解析所有的配置类</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ConfigurationClassParser</span><span class="w"> </span><span class="n">parser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConfigurationClassParser</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="k">this</span><span class="p">.</span><span class="na">metadataReaderFactory</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">problemReporter</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">environment</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="k">this</span><span class="p">.</span><span class="na">resourceLoader</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">componentScanBeanNameGenerator</span><span class="p">,</span><span class="w"> </span><span class="n">registry</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">BeanDefinitionHolder</span><span class="o">&gt;</span><span class="w"> </span><span class="n">candidates</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedHashSet</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">configCandidates</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">ConfigurationClass</span><span class="o">&gt;</span><span class="w"> </span><span class="n">alreadyParsed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashSet</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">configCandidates</span><span class="p">.</span><span class="na">size</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">StartupStep</span><span class="w"> </span><span class="n">processConfig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">applicationStartup</span><span class="p">.</span><span class="na">start</span><span class="p">(</span><span class="s">&#34;spring.context.config-classes.parse&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="c1">//这里就会通过Parser解析配置类中大部分内容，包括我们之前遇到的@Import注解</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">             </span><span class="n">parser</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="n">candidates</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">             </span><span class="n">parser</span><span class="p">.</span><span class="na">validate</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="c1">//解析完成后读取到所有的配置类</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">ConfigurationClass</span><span class="o">&gt;</span><span class="w"> </span><span class="n">configClasses</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedHashSet</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">parser</span><span class="p">.</span><span class="na">getConfigurationClasses</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">             </span><span class="n">configClasses</span><span class="p">.</span><span class="na">removeAll</span><span class="p">(</span><span class="n">alreadyParsed</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="p">...</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="c1">//将上面读取的配置类加载为Bean</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">this</span><span class="p">.</span><span class="na">reader</span><span class="p">.</span><span class="na">loadBeanDefinitions</span><span class="p">(</span><span class="n">configClasses</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">candidates</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="configurationclassparserparsecandidates" class="heading-element"><span><code>ConfigurationClassParser#parse(candidates)</code></span>
  <a href="#configurationclassparserparsecandidates" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">parse</span><span class="p">(</span><span class="n">Set</span><span class="o">&lt;</span><span class="n">BeanDefinitionHolder</span><span class="o">&gt;</span><span class="w"> </span><span class="n">configCandidates</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">BeanDefinitionHolder</span><span class="w"> </span><span class="n">holder</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">configCandidates</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">BeanDefinition</span><span class="w"> </span><span class="n">bd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">holder</span><span class="p">.</span><span class="na">getBeanDefinition</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bd</span><span class="w"> </span><span class="k">instanceof</span><span class="w"> </span><span class="n">AnnotatedBeanDefinition</span><span class="w"> </span><span class="n">annotatedBeanDef</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">parse</span><span class="p">(</span><span class="n">annotatedBeanDef</span><span class="p">,</span><span class="w"> </span><span class="n">holder</span><span class="p">.</span><span class="na">getBeanName</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bd</span><span class="w"> </span><span class="k">instanceof</span><span class="w"> </span><span class="n">AbstractBeanDefinition</span><span class="w"> </span><span class="n">abstractBeanDef</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">abstractBeanDef</span><span class="p">.</span><span class="na">hasBeanClass</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">parse</span><span class="p">(</span><span class="n">abstractBeanDef</span><span class="p">.</span><span class="na">getBeanClass</span><span class="p">(),</span><span class="w"> </span><span class="n">holder</span><span class="p">.</span><span class="na">getBeanName</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">parse</span><span class="p">(</span><span class="n">bd</span><span class="p">.</span><span class="na">getBeanClassName</span><span class="p">(),</span><span class="w"> </span><span class="n">holder</span><span class="p">.</span><span class="na">getBeanName</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">BeanDefinitionStoreException</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="n">ex</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">Throwable</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BeanDefinitionStoreException</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="s">&#34;Failed to parse configuration class [&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bd</span><span class="p">.</span><span class="na">getBeanClassName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;]&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">ex</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">deferredImportSelectorHandler</span><span class="p">.</span><span class="na">process</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>内部遍历candidates中的每一个BeanDefinitionHolder，调用parse的多态方法，最终调用<code>ConfigurationClassParser#processConfigurationClass</code>，最后调用<code>deferredImportSelectorHandler.process()</code>处理<a href="#%e9%92%88%e5%af%b9%60DeferredImportSelector%60" title="wikilink">DeferredImportSelector</a>相关的Bean注册 ^processConfigurationClass</p>
<p>首先判断条件注释，即处理<code>@Conditional</code>相关注解</p>
<p>然后将不同来源的配置类源信息通过<code>asSourceClass</code>进行封装，交给最核心的调用[doProcessConfigurationClass](#<code>ConfigurationClassParser doProcessConfigurationClass</code> &ldquo;wikilink&rdquo;)</p>
<blockquote>
<p>将配置类<code>ConfigurationClass</code>实例化为<code>SourceClass</code>。这样做的目的是为了让后续的处理逻辑能够通过<code>SourceClass</code>访问到配置类中定义的所有相关信息（比如注解信息，Meta-info），并进行相应的处理。例如，通过<code>SourceClass</code>可以读取配置类上的<code>@ComponentScan</code>注解，并执行组件扫描；读取<code>@Import</code>注解，并处理导入的配置类或组件；读取<code>@Bean</code>方法，并注册对应的Bean定义等。</p>
</blockquote>
<h4 id="configurationclassparserdoprocessconfigurationclass" class="heading-element"><span><code>ConfigurationClassParser#doProcessConfigurationClass</code></span>
  <a href="#configurationclassparserdoprocessconfigurationclass" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Nullable</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">protected</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">SourceClass</span><span class="w"> </span><span class="nf">doProcessConfigurationClass</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ConfigurationClass</span><span class="w"> </span><span class="n">configClass</span><span class="p">,</span><span class="w"> </span><span class="n">SourceClass</span><span class="w"> </span><span class="n">sourceClass</span><span class="p">,</span><span class="w"> </span><span class="n">Predicate</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">filter</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">throws</span><span class="w"> </span><span class="n">IOException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">configClass</span><span class="p">.</span><span class="na">getMetadata</span><span class="p">().</span><span class="na">isAnnotated</span><span class="p">(</span><span class="n">Component</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">getName</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Recursively process any member (nested) classes first</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">processMemberClasses</span><span class="p">(</span><span class="n">configClass</span><span class="p">,</span><span class="w"> </span><span class="n">sourceClass</span><span class="p">,</span><span class="w"> </span><span class="n">filter</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Process any @PropertySource annotations</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">AnnotationAttributes</span><span class="w"> </span><span class="n">propertySource</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">AnnotationConfigUtils</span><span class="p">.</span><span class="na">attributesForRepeatable</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">sourceClass</span><span class="p">.</span><span class="na">getMetadata</span><span class="p">(),</span><span class="w"> </span><span class="n">org</span><span class="p">.</span><span class="na">springframework</span><span class="p">.</span><span class="na">context</span><span class="p">.</span><span class="na">annotation</span><span class="p">.</span><span class="na">PropertySource</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">PropertySources</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">propertySourceRegistry</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">propertySourceRegistry</span><span class="p">.</span><span class="na">processPropertySource</span><span class="p">(</span><span class="n">propertySource</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">logger</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="s">&#34;Ignoring @PropertySource annotation on [&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sourceClass</span><span class="p">.</span><span class="na">getMetadata</span><span class="p">().</span><span class="na">getClassName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="s">&#34;]. Reason: Environment must implement ConfigurableEnvironment&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Search for locally declared @ComponentScan annotations first.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">AnnotationAttributes</span><span class="o">&gt;</span><span class="w"> </span><span class="n">componentScans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AnnotationConfigUtils</span><span class="p">.</span><span class="na">attributesForRepeatable</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">sourceClass</span><span class="p">.</span><span class="na">getMetadata</span><span class="p">(),</span><span class="w"> </span><span class="n">ComponentScan</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">ComponentScans</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">MergedAnnotation</span><span class="p">::</span><span class="n">isDirectlyPresent</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Fall back to searching for @ComponentScan meta-annotations (which indirectly</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// includes locally declared composed annotations).</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">componentScans</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">componentScans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AnnotationConfigUtils</span><span class="p">.</span><span class="na">attributesForRepeatable</span><span class="p">(</span><span class="n">sourceClass</span><span class="p">.</span><span class="na">getMetadata</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">ComponentScan</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">ComponentScans</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">MergedAnnotation</span><span class="p">::</span><span class="n">isMetaPresent</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">componentScans</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Condition</span><span class="o">&gt;</span><span class="w"> </span><span class="n">registerBeanConditions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collectRegisterBeanConditions</span><span class="p">(</span><span class="n">configClass</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">registerBeanConditions</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ApplicationContextException</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="s">&#34;Component scan could not be used with conditions in REGISTER_BEAN phase: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">registerBeanConditions</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">AnnotationAttributes</span><span class="w"> </span><span class="n">componentScan</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">componentScans</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">BeanDefinitionHolder</span><span class="o">&gt;</span><span class="w"> </span><span class="n">scannedBeanDefinitions</span><span class="w"> </span><span class="o">=</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">this</span><span class="p">.</span><span class="na">componentScanParser</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="n">componentScan</span><span class="p">,</span><span class="w"> </span><span class="n">sourceClass</span><span class="p">.</span><span class="na">getMetadata</span><span class="p">().</span><span class="na">getClassName</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">BeanDefinitionHolder</span><span class="w"> </span><span class="n">holder</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">scannedBeanDefinitions</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">BeanDefinition</span><span class="w"> </span><span class="n">bdCand</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">holder</span><span class="p">.</span><span class="na">getBeanDefinition</span><span class="p">().</span><span class="na">getOriginatingBeanDefinition</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bdCand</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">bdCand</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">holder</span><span class="p">.</span><span class="na">getBeanDefinition</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ConfigurationClassUtils</span><span class="p">.</span><span class="na">checkConfigurationClassCandidate</span><span class="p">(</span><span class="n">bdCand</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">metadataReaderFactory</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">parse</span><span class="p">(</span><span class="n">bdCand</span><span class="p">.</span><span class="na">getBeanClassName</span><span class="p">(),</span><span class="w"> </span><span class="n">holder</span><span class="p">.</span><span class="na">getBeanName</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Process any @Import annotations</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">processImports</span><span class="p">(</span><span class="n">configClass</span><span class="p">,</span><span class="w"> </span><span class="n">sourceClass</span><span class="p">,</span><span class="w"> </span><span class="n">getImports</span><span class="p">(</span><span class="n">sourceClass</span><span class="p">),</span><span class="w"> </span><span class="n">filter</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Process any @ImportResource annotations</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">AnnotationAttributes</span><span class="w"> </span><span class="n">importResource</span><span class="w"> </span><span class="o">=</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">AnnotationConfigUtils</span><span class="p">.</span><span class="na">attributesFor</span><span class="p">(</span><span class="n">sourceClass</span><span class="p">.</span><span class="na">getMetadata</span><span class="p">(),</span><span class="w"> </span><span class="n">ImportResource</span><span class="p">.</span><span class="na">class</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">importResource</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">resources</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">importResource</span><span class="p">.</span><span class="na">getStringArray</span><span class="p">(</span><span class="s">&#34;locations&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Class</span><span class="o">&lt;?</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">BeanDefinitionReader</span><span class="o">&gt;</span><span class="w"> </span><span class="n">readerClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">importResource</span><span class="p">.</span><span class="na">getClass</span><span class="p">(</span><span class="s">&#34;reader&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">resource</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">resources</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">String</span><span class="w"> </span><span class="n">resolvedResource</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">environment</span><span class="p">.</span><span class="na">resolveRequiredPlaceholders</span><span class="p">(</span><span class="n">resource</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">configClass</span><span class="p">.</span><span class="na">addImportedResource</span><span class="p">(</span><span class="n">resolvedResource</span><span class="p">,</span><span class="w"> </span><span class="n">readerClass</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Process individual @Bean methods</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">MethodMetadata</span><span class="o">&gt;</span><span class="w"> </span><span class="n">beanMethods</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">retrieveBeanMethodMetadata</span><span class="p">(</span><span class="n">sourceClass</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">MethodMetadata</span><span class="w"> </span><span class="n">methodMetadata</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">beanMethods</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">configClass</span><span class="p">.</span><span class="na">addBeanMethod</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">BeanMethod</span><span class="p">(</span><span class="n">methodMetadata</span><span class="p">,</span><span class="w"> </span><span class="n">configClass</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Process default methods on interfaces</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">processInterfaces</span><span class="p">(</span><span class="n">configClass</span><span class="p">,</span><span class="w"> </span><span class="n">sourceClass</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Process superclass, if any</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sourceClass</span><span class="p">.</span><span class="na">getMetadata</span><span class="p">().</span><span class="na">hasSuperClass</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">String</span><span class="w"> </span><span class="n">superclass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sourceClass</span><span class="p">.</span><span class="na">getMetadata</span><span class="p">().</span><span class="na">getSuperClassName</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">superclass</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">superclass</span><span class="p">.</span><span class="na">startsWith</span><span class="p">(</span><span class="s">&#34;java&#34;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">boolean</span><span class="w"> </span><span class="n">superclassKnown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">knownSuperclasses</span><span class="p">.</span><span class="na">containsKey</span><span class="p">(</span><span class="n">superclass</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">knownSuperclasses</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">superclass</span><span class="p">,</span><span class="w"> </span><span class="n">configClass</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">superclassKnown</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">// Superclass found, return its annotation metadata and recurse</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">sourceClass</span><span class="p">.</span><span class="na">getSuperClass</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// No superclass -&gt; processing is complete</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>该函数依次解决如下问题：</p>
<ul>
<li><strong>处理@Component注解</strong></li>
<li><strong>处理@PropertySource和@PropertySources注解</strong></li>
<li><strong>处理@ComponentScan和@ComponentScans</strong></li>
<li><strong>处理@Import注解</strong></li>
<li><strong>处理@ImportResource注解</strong></li>
<li><strong>处理@Bean注解的方法</strong></li>
<li><strong>处理接口上的默认方法和超类</strong></li>
</ul>
<p>其中的核心是处理<code>@Import</code>注解，通过调用 <strong>[ConfigurationClassParser#processImports](#<code>ConfigurationClassParser processImports</code> &ldquo;wikilink&rdquo;)</strong></p>
<h4 id="configurationclassparserprocessimports" class="heading-element"><span><code>ConfigurationClassParser#processImports</code></span>
  <a href="#configurationclassparserprocessimports" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>注意其第三个入参<code>Collection&lt;SourceClass&gt; importCandidates</code>，它是通过调用<code>getImports(sourceClass)</code>方法，从给定的<code>sourceClass</code>中提取所有<code>@Import</code>注解指定的类，如果sourceClass是普通的配置类，直接通过<code>isEmpty()</code>返回</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">processImports</span><span class="p">(</span><span class="n">ConfigurationClass</span><span class="w"> </span><span class="n">configClass</span><span class="p">,</span><span class="w"> </span><span class="n">SourceClass</span><span class="w"> </span><span class="n">currentSourceClass</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">SourceClass</span><span class="o">&gt;</span><span class="w"> </span><span class="n">importCandidates</span><span class="p">,</span><span class="w"> </span><span class="n">Predicate</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">filter</span><span class="p">,</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">checkForCircularImports</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">importCandidates</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">checkForCircularImports</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">isChainedImportOnStack</span><span class="p">(</span><span class="n">configClass</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">problemReporter</span><span class="p">.</span><span class="na">error</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">CircularImportProblem</span><span class="p">(</span><span class="n">configClass</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">importStack</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">importStack</span><span class="p">.</span><span class="na">push</span><span class="p">(</span><span class="n">configClass</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">SourceClass</span><span class="w"> </span><span class="n">candidate</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">importCandidates</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">candidate</span><span class="p">.</span><span class="na">isAssignable</span><span class="p">(</span><span class="n">ImportSelector</span><span class="p">.</span><span class="na">class</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">// Candidate class is an ImportSelector -&gt; delegate to it to determine imports</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">Class</span><span class="o">&lt;?&gt;</span><span class="w"> </span><span class="n">candidateClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">candidate</span><span class="p">.</span><span class="na">loadClass</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">ImportSelector</span><span class="w"> </span><span class="n">selector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParserStrategyUtils</span><span class="p">.</span><span class="na">instantiateClass</span><span class="p">(</span><span class="n">candidateClass</span><span class="p">,</span><span class="w"> </span><span class="n">ImportSelector</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="k">this</span><span class="p">.</span><span class="na">environment</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">resourceLoader</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">registry</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">Predicate</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">selectorFilter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">selector</span><span class="p">.</span><span class="na">getExclusionFilter</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">selectorFilter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">filter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">filter</span><span class="p">.</span><span class="na">or</span><span class="p">(</span><span class="n">selectorFilter</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">selector</span><span class="w"> </span><span class="k">instanceof</span><span class="w"> </span><span class="n">DeferredImportSelector</span><span class="w"> </span><span class="n">deferredImportSelector</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">this</span><span class="p">.</span><span class="na">deferredImportSelectorHandler</span><span class="p">.</span><span class="na">handle</span><span class="p">(</span><span class="n">configClass</span><span class="p">,</span><span class="w"> </span><span class="n">deferredImportSelector</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">importClassNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">selector</span><span class="p">.</span><span class="na">selectImports</span><span class="p">(</span><span class="n">currentSourceClass</span><span class="p">.</span><span class="na">getMetadata</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">SourceClass</span><span class="o">&gt;</span><span class="w"> </span><span class="n">importSourceClasses</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">asSourceClasses</span><span class="p">(</span><span class="n">importClassNames</span><span class="p">,</span><span class="w"> </span><span class="n">filter</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">processImports</span><span class="p">(</span><span class="n">configClass</span><span class="p">,</span><span class="w"> </span><span class="n">currentSourceClass</span><span class="p">,</span><span class="w"> </span><span class="n">importSourceClasses</span><span class="p">,</span><span class="w"> </span><span class="n">filter</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">candidate</span><span class="p">.</span><span class="na">isAssignable</span><span class="p">(</span><span class="n">ImportBeanDefinitionRegistrar</span><span class="p">.</span><span class="na">class</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">// Candidate class is an ImportBeanDefinitionRegistrar -&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">// delegate to it to register additional bean definitions</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">Class</span><span class="o">&lt;?&gt;</span><span class="w"> </span><span class="n">candidateClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">candidate</span><span class="p">.</span><span class="na">loadClass</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">ImportBeanDefinitionRegistrar</span><span class="w"> </span><span class="n">registrar</span><span class="w"> </span><span class="o">=</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="n">ParserStrategyUtils</span><span class="p">.</span><span class="na">instantiateClass</span><span class="p">(</span><span class="n">candidateClass</span><span class="p">,</span><span class="w"> </span><span class="n">ImportBeanDefinitionRegistrar</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                    </span><span class="k">this</span><span class="p">.</span><span class="na">environment</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">resourceLoader</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">registry</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">configClass</span><span class="p">.</span><span class="na">addImportBeanDefinitionRegistrar</span><span class="p">(</span><span class="n">registrar</span><span class="p">,</span><span class="w"> </span><span class="n">currentSourceClass</span><span class="p">.</span><span class="na">getMetadata</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">// Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">// process it as an @Configuration class</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">this</span><span class="p">.</span><span class="na">importStack</span><span class="p">.</span><span class="na">registerImport</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="n">currentSourceClass</span><span class="p">.</span><span class="na">getMetadata</span><span class="p">(),</span><span class="w"> </span><span class="n">candidate</span><span class="p">.</span><span class="na">getMetadata</span><span class="p">().</span><span class="na">getClassName</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">processConfigurationClass</span><span class="p">(</span><span class="n">candidate</span><span class="p">.</span><span class="na">asConfigClass</span><span class="p">(</span><span class="n">configClass</span><span class="p">),</span><span class="w"> </span><span class="n">filter</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">BeanDefinitionStoreException</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="n">ex</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">Throwable</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BeanDefinitionStoreException</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="s">&#34;Failed to process import candidates for configuration class [&#34;</span><span class="w"> </span><span class="o">+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">configClass</span><span class="p">.</span><span class="na">getMetadata</span><span class="p">().</span><span class="na">getClassName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;]: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ex</span><span class="p">.</span><span class="na">getMessage</span><span class="p">(),</span><span class="w"> </span><span class="n">ex</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">importStack</span><span class="p">.</span><span class="na">pop</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>代码遍历每一个<code>@Import</code>注解指定的候选类，根据不同类型进行处理</p>
<ul>
<li><code>ImportSelector</code>实现</li>
<li><code>ImportSelector</code></li>
<li><code>DeferredImportSelector</code></li>
<li><code>ImportBeanDefinitionRegistar</code>实现</li>
<li>普通的配置类</li>
</ul>
<h5 id="针对importselector" class="heading-element"><span>针对<code>ImportSelector</code></span>
  <a href="#%e9%92%88%e5%af%b9importselector" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>通过<code>selector.selectImports()</code>与<code>asSourceClasses()</code>方法将需要导入的类重新封装为<code>SourceClass</code>，递归调用<code>processImports</code></p>
<h5 id="针对deferredimportselector" class="heading-element"><span>针对<code>DeferredImportSelector</code></span>
  <a href="#%e9%92%88%e5%af%b9deferredimportselector" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>通过调用<code>ConfigurationClassParser</code>的内部类<code>DeferredImportSelectorHandler#handle()</code>方法，将其封装为<code>DeferredImportSelectorHolder</code> ，加入待处理的List - <code>deferredImportSelectors</code></p>
<p>在<code>ConfigurationClassParser#parse</code>[处理完所有候选配置类后](#<code>ConfigurationClassParser parse(candidates)</code> &ldquo;wikilink&rdquo;)，调用<code>DeferredImportSelectorHandler#process()</code>方法，该方法将加入<code>deferredImportSelectors</code>中的所有<code>DeferredImportSelectorHolder</code>执行内部类的<code>DeferredImportSelectorGroupingHandler#register</code>方法，得到包装好的、已经分组完毕的<code>DeferredImportSelectorGrouping</code>，然后调用<code>DeferredImportSelectorGroupingHandler#processGroupImports()</code>，处理组内所有的延迟导入 (<code>DeferredImportSelector</code>)</p>
<h6 id="deferredimportselectorgroupinghandlerregister" class="heading-element"><span><code>DeferredImportSelectorGroupingHandler#register</code></span>
  <a href="#deferredimportselectorgroupinghandlerregister" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">void</span><span class="w"> </span><span class="nf">register</span><span class="p">(</span><span class="n">DeferredImportSelectorHolder</span><span class="w"> </span><span class="n">deferredImport</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Class</span><span class="o">&lt;?</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Group</span><span class="o">&gt;</span><span class="w"> </span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">deferredImport</span><span class="p">.</span><span class="na">getImportSelector</span><span class="p">().</span><span class="na">getImportGroup</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">DeferredImportSelectorGrouping</span><span class="w"> </span><span class="n">grouping</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">groupings</span><span class="p">.</span><span class="na">computeIfAbsent</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">(</span><span class="n">group</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">group</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">deferredImport</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">key</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DeferredImportSelectorGrouping</span><span class="p">(</span><span class="n">createGroup</span><span class="p">(</span><span class="n">group</span><span class="p">)));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">grouping</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">deferredImport</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">configurationClasses</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">deferredImport</span><span class="p">.</span><span class="na">getConfigurationClass</span><span class="p">().</span><span class="na">getMetadata</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">deferredImport</span><span class="p">.</span><span class="na">getConfigurationClass</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>首先尝试获取<code>DeferredImportSelector</code>指定的导入组 (<code>ImportGroup</code>)，如果没有指定特定的导入组，则使用<code>DeferredImportSelector</code>本身作为组的Key</li>
<li>尝试从一个名为<code>groupings</code>的映射中获取或创建一个与导入组对应的<code>DeferredImportSelectorGrouping</code>对象。如果映射中尚未存在与当前组对应的分组，那么将创建一个新的分组，并将其加入到映射中
<ul>
<li>注意，此处的Group逻辑是将<code>DeferredImportSelector.Group</code>这个内部接口包装到<code>ConfigurationClassParser.DeferredImportSelectorGourping</code>这个内部类中，其内部维护了一个<code>DeferredImportSelector.Group</code>对象和<code>List&lt;DeferredImportSelectorHolder&gt;</code>对象</li>
</ul>
</li>
<li>调用<code>DeferredImportSelectGrouping#add(DeferredImportSelectorHolder)</code>，将<code>DeferredImportSelectorHolder</code>加入内部类维护的<code>Grouping</code>中 (静态类)</li>
<li>最后，代码将当前<code>DeferredImportSelectorHolder</code>对应的配置类(<code>ConfigurationClass</code>)及其元数据添加到一个名为<code>configurationClasses</code>的映射中。这确保了后续能够快速访问到与特定<code>DeferredImportSelector</code>相关联的配置类</li>
</ul>
<h6 id="deferredimportselectorgroupinghandlerprocessgroupimports" class="heading-element"><span><code>DeferredImportSelectorGroupingHandler#processGroupImports</code></span>
  <a href="#deferredimportselectorgroupinghandlerprocessgroupimports" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h6><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">void</span><span class="w"> </span><span class="nf">processGroupImports</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">DeferredImportSelectorGrouping</span><span class="w"> </span><span class="n">grouping</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">groupings</span><span class="p">.</span><span class="na">values</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Predicate</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grouping</span><span class="p">.</span><span class="na">getCandidateFilter</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">grouping</span><span class="p">.</span><span class="na">getImports</span><span class="p">().</span><span class="na">forEach</span><span class="p">(</span><span class="n">entry</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">ConfigurationClass</span><span class="w"> </span><span class="n">configurationClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">configurationClasses</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="na">getMetadata</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">processImports</span><span class="p">(</span><span class="n">configurationClass</span><span class="p">,</span><span class="w"> </span><span class="n">asSourceClass</span><span class="p">(</span><span class="n">configurationClass</span><span class="p">,</span><span class="w"> </span><span class="n">filter</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">Collections</span><span class="p">.</span><span class="na">singleton</span><span class="p">(</span><span class="n">asSourceClass</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="na">getImportClassName</span><span class="p">(),</span><span class="w"> </span><span class="n">filter</span><span class="p">)),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">filter</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">BeanDefinitionStoreException</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">throw</span><span class="w"> </span><span class="n">ex</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">Throwable</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BeanDefinitionStoreException</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="s">&#34;Failed to process import candidates for configuration class [&#34;</span><span class="w"> </span><span class="o">+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="n">configurationClass</span><span class="p">.</span><span class="na">getMetadata</span><span class="p">().</span><span class="na">getClassName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;]&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">ex</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>遍历保存在<code>Groups - DeferredImportSelectorGroupingHandler</code>中的 <code>DeferredImportSelectorGroup</code>对象，调用 <code>DeferredImportSelectorGroup#getImports()</code>方法</li>
<li><code>DeferredImportSelectorGroup#getImports()</code>方法调用<code>DeferredImportSelectorGroup</code>中维护的真实的Group - <code>DeferredImportSelector.Group#process</code>方法，然后返回含有<code>meta-info</code>的<code>Entry</code></li>
<li>使用内部维护的<code>Map</code>(在<code>register</code>中put)，根据<code>Entry.meta-info</code>得到对应的<code>ConfigurationClass</code> ，调用<code>ConfigurationClassParser#processImports</code>，和[前面](#<code>ConfigurationClassParser processImports</code> &ldquo;wikilink&rdquo;)一样递归调用进行处理</li>
</ul>
<p>所以根据以上分析，<code>DeferredImportSelector</code>最终的处理逻辑在于<code>DeferredImportSelector.Group#process()</code> ^db8805</p>
<h5 id="针对importbeandefinitionregistar" class="heading-element"><span>针对<code>ImportBeanDefinitionRegistar</code></span>
  <a href="#%e9%92%88%e5%af%b9importbeandefinitionregistar" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">ImportBeanDefinitionRegistrar</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">default</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">registerBeanDefinitions</span><span class="p">(</span><span class="n">AnnotationMetadata</span><span class="w"> </span><span class="n">importingClassMetadata</span><span class="p">,</span><span class="w"> </span><span class="n">BeanDefinitionRegistry</span><span class="w"> </span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="n">BeanNameGenerator</span><span class="w"> </span><span class="n">importBeanNameGenerator</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">registerBeanDefinitions</span><span class="p">(</span><span class="n">importingClassMetadata</span><span class="p">,</span><span class="w"> </span><span class="n">registry</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">default</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">registerBeanDefinitions</span><span class="p">(</span><span class="n">AnnotationMetadata</span><span class="w"> </span><span class="n">importingClassMetadata</span><span class="p">,</span><span class="w"> </span><span class="n">BeanDefinitionRegistry</span><span class="w"> </span><span class="n">registry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>调用<code>ConfigurationClass#addImportBeanDefinitionRegistrar</code>方法，将对应的实例加入configClass对应的Collection类中，后续在[loadBeanDefinitions](#<code>ConfigurationClassBeanDefinitionReader loadBeanDefinitions</code> &ldquo;wikilink&rdquo;)中调用其<code>registerBeanDefinitions</code>，注册相应的BeanDefinition</p>
<h5 id="针对普通配置类" class="heading-element"><span>针对普通配置类</span>
  <a href="#%e9%92%88%e5%af%b9%e6%99%ae%e9%80%9a%e9%85%8d%e7%bd%ae%e7%b1%bb" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>不使用特殊机制，直接递归调用<a href="#%5eprocessConfigurationClass" title="wikilink">processConfigurationClass</a></p>
<h3 id="configurationclassparsergetconfigurationclasses" class="heading-element"><span><code>ConfigurationClassParser#getConfigurationClasses</code></span>
  <a href="#configurationclassparsergetconfigurationclasses" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>返回从前面得到的所有待配置的配置类</p>
<h3 id="configurationclassbeandefinitionreaderloadbeandefinitions" class="heading-element"><span><code>ConfigurationClassBeanDefinitionReader#loadBeanDefinitions</code></span>
  <a href="#configurationclassbeandefinitionreaderloadbeandefinitions" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>^98f726</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">loadBeanDefinitions</span><span class="p">(</span><span class="n">Set</span><span class="o">&lt;</span><span class="n">ConfigurationClass</span><span class="o">&gt;</span><span class="w"> </span><span class="n">configurationModel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">TrackedConditionEvaluator</span><span class="w"> </span><span class="n">trackedConditionEvaluator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">TrackedConditionEvaluator</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ConfigurationClass</span><span class="w"> </span><span class="n">configClass</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">configurationModel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">loadBeanDefinitionsForConfigurationClass</span><span class="p">(</span><span class="n">configClass</span><span class="p">,</span><span class="w"> </span><span class="n">trackedConditionEvaluator</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Read a particular {@link ConfigurationClass}, registering bean definitions
</span></span></span><span class="line"><span class="cl"><span class="cm"> * for the class itself and all of its {@link Bean} methods.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">loadBeanDefinitionsForConfigurationClass</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ConfigurationClass</span><span class="w"> </span><span class="n">configClass</span><span class="p">,</span><span class="w"> </span><span class="n">TrackedConditionEvaluator</span><span class="w"> </span><span class="n">trackedConditionEvaluator</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">trackedConditionEvaluator</span><span class="p">.</span><span class="na">shouldSkip</span><span class="p">(</span><span class="n">configClass</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">configClass</span><span class="p">.</span><span class="na">getBeanName</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">StringUtils</span><span class="p">.</span><span class="na">hasLength</span><span class="p">(</span><span class="n">beanName</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">registry</span><span class="p">.</span><span class="na">containsBeanDefinition</span><span class="p">(</span><span class="n">beanName</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">registry</span><span class="p">.</span><span class="na">removeBeanDefinition</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">importRegistry</span><span class="p">.</span><span class="na">removeImportingClass</span><span class="p">(</span><span class="n">configClass</span><span class="p">.</span><span class="na">getMetadata</span><span class="p">().</span><span class="na">getClassName</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">configClass</span><span class="p">.</span><span class="na">isImported</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">registerBeanDefinitionForImportedConfigurationClass</span><span class="p">(</span><span class="n">configClass</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">BeanMethod</span><span class="w"> </span><span class="n">beanMethod</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">configClass</span><span class="p">.</span><span class="na">getBeanMethods</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">loadBeanDefinitionsForBeanMethod</span><span class="p">(</span><span class="n">beanMethod</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">loadBeanDefinitionsFromImportedResources</span><span class="p">(</span><span class="n">configClass</span><span class="p">.</span><span class="na">getImportedResources</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">loadBeanDefinitionsFromRegistrars</span><span class="p">(</span><span class="n">configClass</span><span class="p">.</span><span class="na">getImportBeanDefinitionRegistrars</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通过遍历每一个配置类，调用<code>loadBeanDefinitionsForConfigurationClass</code>方法 ^f6a27a</p>
<ul>
<li>registerBeanDefinitionForImportedConfigurationClass(configClass)
注册配置类自身</li>
<li>loadBeanDefinitionsForBeanMethod(beanMethod)
注册@Bean注解标识的方法</li>
<li>loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
注册@ImportResource引入的XML配置文件中读取的bean定义</li>
<li>loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
注册configClass中经过解析后保存的所有ImportBeanDefinitionRegistrar，注册对应的BeanDefinition</li>
</ul>
<h1 id="aop" class="heading-element"><span>AOP</span>
  <a href="#aop" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h1><p>AOP的实现类是<code>AnnotationAwareAspectJAutoProxyCreator</code>，其是<code>BeanPostProcessor</code>的实现类，具体来说，是<code>InstantiationAwareBeanPostProcessor</code>的实现类，在实例化Bean过程中，通过调用<a href="#%5efcb215" title="wikilink">BeanPostProcessor中的实例化前处理器</a>进行短路，得到相应的代理Bean</p>
<h2 id="enableaspectjautoproxy" class="heading-element"><span><code>@EnableAspectJAutoProxy</code></span>
  <a href="#enableaspectjautoproxy" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Target</span><span class="p">({</span><span class="n">ElementType</span><span class="p">.</span><span class="na">TYPE</span><span class="p">})</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Retention</span><span class="p">(</span><span class="n">RetentionPolicy</span><span class="p">.</span><span class="na">RUNTIME</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Documented</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Import</span><span class="p">({</span><span class="n">AspectJAutoProxyRegistrar</span><span class="p">.</span><span class="na">class</span><span class="p">})</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="nd">@interface</span><span class="w"> </span><span class="n">EnableAspectJAutoProxy</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">proxyTargetClass</span><span class="p">()</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">exposeProxy</span><span class="p">()</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个注解使用<code>@Import</code>导入了<code>AspectJAutoProxyRegistrar</code>，其是<code>ImportBeanDefinitionRegistrar</code>的实现类，会在<a href="#%5ef6a27a" title="wikilink">处理配置类</a>相应<code>@Import</code>机制的时候将<code>AnnotationAwareAspectJAutoProxyCreator</code>实现类注册到容器中，即注册到BeanDefinition中，实现相应的实例化前处理器功能 (<code>InstantiationAwareBeanPostProcessor</code>)</p></div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title="Updated on 2024-05-13 11:26:20">Updated on 2024-05-13&nbsp;</span>
      </div></div><div class="post-info-line">
        <div class="post-info-md"><span><a href="/posts/6e2a775/index.md" title="Read Markdown" class="link-to-markdown">Read Markdown</a></span><span><a href="https://github.com/GRedComeT/blob/main/content/posts%5cSpring.md?plain=1" title="View source"target="_blank" rel="external nofollow noopener noreferrer" class="link-to-source">View source</a></span><span><a href="https://github.com/GRedComeT/edit/main/content/posts%5cSpring.md" title="Edit this page"target="_blank" rel="external nofollow noopener noreferrer" class="link-to-edit">Edit this page</a></span><span><a href="https://github.com/GRedComeT/issues/new?title=[BUG]%20Spring&#43;%E4%B8%BB%E8%A6%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7cSpring&#43;%E4%B8%BB%E8%A6%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%7c%0A%7cURL%7chttp://localhost:1313/posts/6e2a775/%7c%0A%7cFilename%7chttps://github.com/GRedComeT/blob/main/content/posts%5cSpring.md?plain=1%7c" title="Report issue"target="_blank" rel="external nofollow noopener noreferrer" class="link-to-report">Report issue</a></span></div>
        <div class="post-info-share">
          <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="http://localhost:1313/posts/6e2a775/" data-title="Spring 主要源码分析" data-hashtags="Java,Spring"><i class="fa-brands fa-twitter fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="http://localhost:1313/posts/6e2a775/" data-hashtag="Java"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="http://localhost:1313/posts/6e2a775/" data-title="Spring 主要源码分析"><i class="fa-brands fa-weibo fa-fw" aria-hidden="true"></i></a>
  </span>
        </div>
      </div></div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href="/tags/java/" class="post-tag" title="Tags - Java">Java</a><a href="/tags/spring/" class="post-tag" title="Tags - Spring">Spring</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/posts/583bc6c/" class="post-nav-item" rel="prev" title="多线程基础"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>多线程基础</a>
      <a href="/posts/0840a16/" class="post-nav-item" rel="next" title="JVM">JVM<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article>

  <aside class="toc" id="toc-auto" aria-label="Contents"><h2 class="toc-title">Contents&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered">Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer" title="Hugo 0.125.7"><img class="hugo-icon" src="/images/hugo.min.svg" alt="Hugo logo" /> Hugo</a> | Theme - <a href="https://github.com/hugo-fixit/FixIt" target="_blank" rel="external" title="FixIt v0.3.6"><img class="fixit-icon" src="/images/fixit.min.svg" alt="FixIt logo" /> FixIt</a>
        </div><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2024</span><span class="author" itemprop="copyrightHolder">
              <a href="https://github.com/GRedComeT"target="_blank" rel="external nofollow noopener noreferrer">Dionysun</a></span></div><div class="footer-line visitor">
          <span id="busuanzi_container_site_uv" title='Total visitors'><i class="fa-regular fa-user fa-fw" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></span><span id="busuanzi_container_site_pv" class="footer-divider" title='Total visits'><i class="fa-regular fa-eye fa-fw" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></span>
        </div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="Back to Top"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div></div><a href="https://github.com/GRedComeT" title="View source on GitHub"target="_blank" rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><div id="mask"></div><noscript>
    <div class="noscript-warning">Theme FixIt works best with JavaScript enabled.</div>
  </noscript>
</div><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/typeit/index.umd.js" defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async defer></script><script>window.config={"code":{"copyTitle":"Copy to clipboard","editLockTitle":"Lock editable code block","editUnLockTitle":"Unlock editable code block","editable":true,"maxShownLines":10},"comment":{"enable":false},"cookieconsent":{"content":{"dismiss":"Got it!","link":"Learn more","message":"This website uses Cookies to improve your experience."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"duration":-1,"loop":false,"speed":100},"version":"v0.3.6"};</script><script src="/js/theme.min.js" defer></script></body>
</html>
